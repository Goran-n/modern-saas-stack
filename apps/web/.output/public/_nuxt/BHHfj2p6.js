var __defProp=Object.defineProperty;var __typeError=msg=>{throw TypeError(msg)};var __name=(target,value)=>__defProp(target,"name",{value,configurable:!0});var __accessCheck=(obj,member,msg)=>member.has(obj)||__typeError("Cannot "+msg);var __privateGet=(obj,member,getter)=>(__accessCheck(obj,member,"read from private field"),getter?getter.call(obj):member.get(obj)),__privateAdd=(obj,member,value)=>member.has(obj)?__typeError("Cannot add the same private member more than once"):member instanceof WeakSet?member.add(obj):member.set(obj,value),__privateSet=(obj,member,value,setter)=>(__accessCheck(obj,member,"write to private field"),setter?setter.call(obj,value):member.set(obj,value),value),__privateMethod=(obj,member,method)=>(__accessCheck(obj,member,"access private method"),method);import{S as Subscribable,p as pendingThenable,r as resolveEnabled,s as shallowEqualObjects,k as resolveStaleTime,l as noop,m as isServer,o as isValidTimeout,t as timeUntilStale,q as focusManager,v as fetchState,w as replaceData,x as notifyManager,y as getClientKey,z as cloneDeepUnref,A as shouldThrowError,B as updateState}from"./BGn8T2aB.js";import{h as hasInjectionContext,i as inject,E as computed,s as shallowReactive,r as reactive,y as watch,H as onScopeDispose,af as shallowReadonly,F as readonly,ag as toRefs}from"./BRSJK7Xo.js";var _client,_currentQuery,_currentQueryInitialState,_currentResult,_currentResultState,_currentResultOptions,_currentThenable,_selectError,_selectFn,_selectResult,_lastQueryWithDefinedData,_staleTimeoutId,_refetchIntervalId,_currentRefetchInterval,_trackedProps,__this_instances,executeFetch_fn,updateStaleTimeout_fn,computeRefetchInterval_fn,updateRefetchInterval_fn,updateTimers_fn,clearStaleTimeout_fn,clearRefetchInterval_fn,updateQuery_fn,notify_fn,_a,QueryObserver=(_a=class extends Subscribable{constructor(client,options){super();__privateAdd(this,__this_instances);__privateAdd(this,_client);__privateAdd(this,_currentQuery);__privateAdd(this,_currentQueryInitialState);__privateAdd(this,_currentResult);__privateAdd(this,_currentResultState);__privateAdd(this,_currentResultOptions);__privateAdd(this,_currentThenable);__privateAdd(this,_selectError);__privateAdd(this,_selectFn);__privateAdd(this,_selectResult);__privateAdd(this,_lastQueryWithDefinedData);__privateAdd(this,_staleTimeoutId);__privateAdd(this,_refetchIntervalId);__privateAdd(this,_currentRefetchInterval);__privateAdd(this,_trackedProps,new Set);this.options=options,__privateSet(this,_client,client),__privateSet(this,_selectError,null),__privateSet(this,_currentThenable,pendingThenable()),this.options.experimental_prefetchInRender||__privateGet(this,_currentThenable).reject(new Error("experimental_prefetchInRender feature flag is not enabled")),this.bindMethods(),this.setOptions(options)}bindMethods(){this.refetch=this.refetch.bind(this)}onSubscribe(){this.listeners.size===1&&(__privateGet(this,_currentQuery).addObserver(this),shouldFetchOnMount(__privateGet(this,_currentQuery),this.options)?__privateMethod(this,__this_instances,executeFetch_fn).call(this):this.updateResult(),__privateMethod(this,__this_instances,updateTimers_fn).call(this))}onUnsubscribe(){this.hasListeners()||this.destroy()}shouldFetchOnReconnect(){return shouldFetchOn(__privateGet(this,_currentQuery),this.options,this.options.refetchOnReconnect)}shouldFetchOnWindowFocus(){return shouldFetchOn(__privateGet(this,_currentQuery),this.options,this.options.refetchOnWindowFocus)}destroy(){this.listeners=new Set,__privateMethod(this,__this_instances,clearStaleTimeout_fn).call(this),__privateMethod(this,__this_instances,clearRefetchInterval_fn).call(this),__privateGet(this,_currentQuery).removeObserver(this)}setOptions(options){const prevOptions=this.options,prevQuery=__privateGet(this,_currentQuery);if(this.options=__privateGet(this,_client).defaultQueryOptions(options),this.options.enabled!==void 0&&typeof this.options.enabled!="boolean"&&typeof this.options.enabled!="function"&&typeof resolveEnabled(this.options.enabled,__privateGet(this,_currentQuery))!="boolean")throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");__privateMethod(this,__this_instances,updateQuery_fn).call(this),__privateGet(this,_currentQuery).setOptions(this.options),prevOptions._defaulted&&!shallowEqualObjects(this.options,prevOptions)&&__privateGet(this,_client).getQueryCache().notify({type:"observerOptionsUpdated",query:__privateGet(this,_currentQuery),observer:this});const mounted=this.hasListeners();mounted&&shouldFetchOptionally(__privateGet(this,_currentQuery),prevQuery,this.options,prevOptions)&&__privateMethod(this,__this_instances,executeFetch_fn).call(this),this.updateResult(),mounted&&(__privateGet(this,_currentQuery)!==prevQuery||resolveEnabled(this.options.enabled,__privateGet(this,_currentQuery))!==resolveEnabled(prevOptions.enabled,__privateGet(this,_currentQuery))||resolveStaleTime(this.options.staleTime,__privateGet(this,_currentQuery))!==resolveStaleTime(prevOptions.staleTime,__privateGet(this,_currentQuery)))&&__privateMethod(this,__this_instances,updateStaleTimeout_fn).call(this);const nextRefetchInterval=__privateMethod(this,__this_instances,computeRefetchInterval_fn).call(this);mounted&&(__privateGet(this,_currentQuery)!==prevQuery||resolveEnabled(this.options.enabled,__privateGet(this,_currentQuery))!==resolveEnabled(prevOptions.enabled,__privateGet(this,_currentQuery))||nextRefetchInterval!==__privateGet(this,_currentRefetchInterval))&&__privateMethod(this,__this_instances,updateRefetchInterval_fn).call(this,nextRefetchInterval)}getOptimisticResult(options){const query=__privateGet(this,_client).getQueryCache().build(__privateGet(this,_client),options),result=this.createResult(query,options);return shouldAssignObserverCurrentProperties(this,result)&&(__privateSet(this,_currentResult,result),__privateSet(this,_currentResultOptions,this.options),__privateSet(this,_currentResultState,__privateGet(this,_currentQuery).state)),result}getCurrentResult(){return __privateGet(this,_currentResult)}trackResult(result,onPropTracked){return new Proxy(result,{get:__name((target,key)=>(this.trackProp(key),onPropTracked?.(key),Reflect.get(target,key)),"get")})}trackProp(key){__privateGet(this,_trackedProps).add(key)}getCurrentQuery(){return __privateGet(this,_currentQuery)}refetch({...options}={}){return this.fetch({...options})}fetchOptimistic(options){const defaultedOptions=__privateGet(this,_client).defaultQueryOptions(options),query=__privateGet(this,_client).getQueryCache().build(__privateGet(this,_client),defaultedOptions);return query.fetch().then(()=>this.createResult(query,defaultedOptions))}fetch(fetchOptions){return __privateMethod(this,__this_instances,executeFetch_fn).call(this,{...fetchOptions,cancelRefetch:fetchOptions.cancelRefetch??!0}).then(()=>(this.updateResult(),__privateGet(this,_currentResult)))}createResult(query,options){const prevQuery=__privateGet(this,_currentQuery),prevOptions=this.options,prevResult=__privateGet(this,_currentResult),prevResultState=__privateGet(this,_currentResultState),prevResultOptions=__privateGet(this,_currentResultOptions),queryInitialState=query!==prevQuery?query.state:__privateGet(this,_currentQueryInitialState),{state}=query;let newState={...state},isPlaceholderData=!1,data;if(options._optimisticResults){const mounted=this.hasListeners(),fetchOnMount=!mounted&&shouldFetchOnMount(query,options),fetchOptionally=mounted&&shouldFetchOptionally(query,prevQuery,options,prevOptions);(fetchOnMount||fetchOptionally)&&(newState={...newState,...fetchState(state.data,query.options)}),options._optimisticResults==="isRestoring"&&(newState.fetchStatus="idle")}let{error,errorUpdatedAt,status}=newState;data=newState.data;let skipSelect=!1;if(options.placeholderData!==void 0&&data===void 0&&status==="pending"){let placeholderData;prevResult?.isPlaceholderData&&options.placeholderData===prevResultOptions?.placeholderData?(placeholderData=prevResult.data,skipSelect=!0):placeholderData=typeof options.placeholderData=="function"?options.placeholderData(__privateGet(this,_lastQueryWithDefinedData)?.state.data,__privateGet(this,_lastQueryWithDefinedData)):options.placeholderData,placeholderData!==void 0&&(status="success",data=replaceData(prevResult?.data,placeholderData,options),isPlaceholderData=!0)}if(options.select&&data!==void 0&&!skipSelect)if(prevResult&&data===prevResultState?.data&&options.select===__privateGet(this,_selectFn))data=__privateGet(this,_selectResult);else try{__privateSet(this,_selectFn,options.select),data=options.select(data),data=replaceData(prevResult?.data,data,options),__privateSet(this,_selectResult,data),__privateSet(this,_selectError,null)}catch(selectError){__privateSet(this,_selectError,selectError)}__privateGet(this,_selectError)&&(error=__privateGet(this,_selectError),data=__privateGet(this,_selectResult),errorUpdatedAt=Date.now(),status="error");const isFetching=newState.fetchStatus==="fetching",isPending=status==="pending",isError=status==="error",isLoading=isPending&&isFetching,hasData=data!==void 0,nextResult={status,fetchStatus:newState.fetchStatus,isPending,isSuccess:status==="success",isError,isInitialLoading:isLoading,isLoading,data,dataUpdatedAt:newState.dataUpdatedAt,error,errorUpdatedAt,failureCount:newState.fetchFailureCount,failureReason:newState.fetchFailureReason,errorUpdateCount:newState.errorUpdateCount,isFetched:newState.dataUpdateCount>0||newState.errorUpdateCount>0,isFetchedAfterMount:newState.dataUpdateCount>queryInitialState.dataUpdateCount||newState.errorUpdateCount>queryInitialState.errorUpdateCount,isFetching,isRefetching:isFetching&&!isPending,isLoadingError:isError&&!hasData,isPaused:newState.fetchStatus==="paused",isPlaceholderData,isRefetchError:isError&&hasData,isStale:isStale(query,options),refetch:this.refetch,promise:__privateGet(this,_currentThenable),isEnabled:resolveEnabled(options.enabled,query)!==!1};if(this.options.experimental_prefetchInRender){const finalizeThenableIfPossible=__name(thenable=>{nextResult.status==="error"?thenable.reject(nextResult.error):nextResult.data!==void 0&&thenable.resolve(nextResult.data)},"finalizeThenableIfPossible"),recreateThenable=__name(()=>{const pending=__privateSet(this,_currentThenable,nextResult.promise=pendingThenable());finalizeThenableIfPossible(pending)},"recreateThenable"),prevThenable=__privateGet(this,_currentThenable);switch(prevThenable.status){case"pending":query.queryHash===prevQuery.queryHash&&finalizeThenableIfPossible(prevThenable);break;case"fulfilled":(nextResult.status==="error"||nextResult.data!==prevThenable.value)&&recreateThenable();break;case"rejected":(nextResult.status!=="error"||nextResult.error!==prevThenable.reason)&&recreateThenable();break}}return nextResult}updateResult(){const prevResult=__privateGet(this,_currentResult),nextResult=this.createResult(__privateGet(this,_currentQuery),this.options);if(__privateSet(this,_currentResultState,__privateGet(this,_currentQuery).state),__privateSet(this,_currentResultOptions,this.options),__privateGet(this,_currentResultState).data!==void 0&&__privateSet(this,_lastQueryWithDefinedData,__privateGet(this,_currentQuery)),shallowEqualObjects(nextResult,prevResult))return;__privateSet(this,_currentResult,nextResult);const shouldNotifyListeners=__name(()=>{if(!prevResult)return!0;const{notifyOnChangeProps}=this.options,notifyOnChangePropsValue=typeof notifyOnChangeProps=="function"?notifyOnChangeProps():notifyOnChangeProps;if(notifyOnChangePropsValue==="all"||!notifyOnChangePropsValue&&!__privateGet(this,_trackedProps).size)return!0;const includedProps=new Set(notifyOnChangePropsValue??__privateGet(this,_trackedProps));return this.options.throwOnError&&includedProps.add("error"),Object.keys(__privateGet(this,_currentResult)).some(key=>{const typedKey=key;return __privateGet(this,_currentResult)[typedKey]!==prevResult[typedKey]&&includedProps.has(typedKey)})},"shouldNotifyListeners");__privateMethod(this,__this_instances,notify_fn).call(this,{listeners:shouldNotifyListeners()})}onQueryUpdate(){this.updateResult(),this.hasListeners()&&__privateMethod(this,__this_instances,updateTimers_fn).call(this)}},_client=new WeakMap,_currentQuery=new WeakMap,_currentQueryInitialState=new WeakMap,_currentResult=new WeakMap,_currentResultState=new WeakMap,_currentResultOptions=new WeakMap,_currentThenable=new WeakMap,_selectError=new WeakMap,_selectFn=new WeakMap,_selectResult=new WeakMap,_lastQueryWithDefinedData=new WeakMap,_staleTimeoutId=new WeakMap,_refetchIntervalId=new WeakMap,_currentRefetchInterval=new WeakMap,_trackedProps=new WeakMap,__this_instances=new WeakSet,executeFetch_fn=__name(function(fetchOptions){__privateMethod(this,__this_instances,updateQuery_fn).call(this);let promise=__privateGet(this,_currentQuery).fetch(this.options,fetchOptions);return fetchOptions?.throwOnError||(promise=promise.catch(noop)),promise},"#executeFetch"),updateStaleTimeout_fn=__name(function(){__privateMethod(this,__this_instances,clearStaleTimeout_fn).call(this);const staleTime=resolveStaleTime(this.options.staleTime,__privateGet(this,_currentQuery));if(isServer||__privateGet(this,_currentResult).isStale||!isValidTimeout(staleTime))return;const timeout=timeUntilStale(__privateGet(this,_currentResult).dataUpdatedAt,staleTime)+1;__privateSet(this,_staleTimeoutId,setTimeout(()=>{__privateGet(this,_currentResult).isStale||this.updateResult()},timeout))},"#updateStaleTimeout"),computeRefetchInterval_fn=__name(function(){return(typeof this.options.refetchInterval=="function"?this.options.refetchInterval(__privateGet(this,_currentQuery)):this.options.refetchInterval)??!1},"#computeRefetchInterval"),updateRefetchInterval_fn=__name(function(nextInterval){__privateMethod(this,__this_instances,clearRefetchInterval_fn).call(this),__privateSet(this,_currentRefetchInterval,nextInterval),!(isServer||resolveEnabled(this.options.enabled,__privateGet(this,_currentQuery))===!1||!isValidTimeout(__privateGet(this,_currentRefetchInterval))||__privateGet(this,_currentRefetchInterval)===0)&&__privateSet(this,_refetchIntervalId,setInterval(()=>{(this.options.refetchIntervalInBackground||focusManager.isFocused())&&__privateMethod(this,__this_instances,executeFetch_fn).call(this)},__privateGet(this,_currentRefetchInterval)))},"#updateRefetchInterval"),updateTimers_fn=__name(function(){__privateMethod(this,__this_instances,updateStaleTimeout_fn).call(this),__privateMethod(this,__this_instances,updateRefetchInterval_fn).call(this,__privateMethod(this,__this_instances,computeRefetchInterval_fn).call(this))},"#updateTimers"),clearStaleTimeout_fn=__name(function(){__privateGet(this,_staleTimeoutId)&&(clearTimeout(__privateGet(this,_staleTimeoutId)),__privateSet(this,_staleTimeoutId,void 0))},"#clearStaleTimeout"),clearRefetchInterval_fn=__name(function(){__privateGet(this,_refetchIntervalId)&&(clearInterval(__privateGet(this,_refetchIntervalId)),__privateSet(this,_refetchIntervalId,void 0))},"#clearRefetchInterval"),updateQuery_fn=__name(function(){const query=__privateGet(this,_client).getQueryCache().build(__privateGet(this,_client),this.options);if(query===__privateGet(this,_currentQuery))return;const prevQuery=__privateGet(this,_currentQuery);__privateSet(this,_currentQuery,query),__privateSet(this,_currentQueryInitialState,query.state),this.hasListeners()&&(prevQuery?.removeObserver(this),query.addObserver(this))},"#updateQuery"),notify_fn=__name(function(notifyOptions){notifyManager.batch(()=>{notifyOptions.listeners&&this.listeners.forEach(listener=>{listener(__privateGet(this,_currentResult))}),__privateGet(this,_client).getQueryCache().notify({query:__privateGet(this,_currentQuery),type:"observerResultsUpdated"})})},"#notify"),__name(_a,"QueryObserver"),_a);function shouldLoadOnMount(query,options){return resolveEnabled(options.enabled,query)!==!1&&query.state.data===void 0&&!(query.state.status==="error"&&options.retryOnMount===!1)}__name(shouldLoadOnMount,"shouldLoadOnMount");function shouldFetchOnMount(query,options){return shouldLoadOnMount(query,options)||query.state.data!==void 0&&shouldFetchOn(query,options,options.refetchOnMount)}__name(shouldFetchOnMount,"shouldFetchOnMount");function shouldFetchOn(query,options,field){if(resolveEnabled(options.enabled,query)!==!1&&resolveStaleTime(options.staleTime,query)!=="static"){const value=typeof field=="function"?field(query):field;return value==="always"||value!==!1&&isStale(query,options)}return!1}__name(shouldFetchOn,"shouldFetchOn");function shouldFetchOptionally(query,prevQuery,options,prevOptions){return(query!==prevQuery||resolveEnabled(prevOptions.enabled,query)===!1)&&(!options.suspense||query.state.status!=="error")&&isStale(query,options)}__name(shouldFetchOptionally,"shouldFetchOptionally");function isStale(query,options){return resolveEnabled(options.enabled,query)!==!1&&query.isStaleByTime(resolveStaleTime(options.staleTime,query))}__name(isStale,"isStale");function shouldAssignObserverCurrentProperties(observer,optimisticResult){return!shallowEqualObjects(observer.getCurrentResult(),optimisticResult)}__name(shouldAssignObserverCurrentProperties,"shouldAssignObserverCurrentProperties");function useQueryClient(id=""){if(!hasInjectionContext())throw new Error("vue-query hooks can only be used inside setup() function or functions that support injection context.");const key=getClientKey(id),queryClient=inject(key);if(!queryClient)throw new Error("No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library.");return queryClient}__name(useQueryClient,"useQueryClient");function useBaseQuery(Observer,options,queryClient){const client=useQueryClient(),defaultedOptions=computed(()=>{const clonedOptions=cloneDeepUnref(options);typeof clonedOptions.enabled=="function"&&(clonedOptions.enabled=clonedOptions.enabled());const defaulted=client.defaultQueryOptions(clonedOptions);return defaulted._optimisticResults=client.isRestoring?.value?"isRestoring":"optimistic",defaulted}),observer=new Observer(client,defaultedOptions.value),state=defaultedOptions.value.shallow?shallowReactive(observer.getCurrentResult()):reactive(observer.getCurrentResult());let unsubscribe=__name(()=>{},"unsubscribe");client.isRestoring&&watch(client.isRestoring,isRestoring=>{isRestoring||(unsubscribe(),unsubscribe=observer.subscribe(result=>{updateState(state,result)}))},{immediate:!0});const updater=__name(()=>{observer.setOptions(defaultedOptions.value),updateState(state,observer.getCurrentResult())},"updater");watch(defaultedOptions,updater),onScopeDispose(()=>{unsubscribe()});const refetch=__name((...args)=>(updater(),state.refetch(...args)),"refetch"),suspense=__name(()=>new Promise((resolve,reject)=>{let stopWatch=__name(()=>{},"stopWatch");const run=__name(()=>{if(defaultedOptions.value.enabled!==!1){observer.setOptions(defaultedOptions.value);const optimisticResult=observer.getOptimisticResult(defaultedOptions.value);optimisticResult.isStale?(stopWatch(),observer.fetchOptimistic(defaultedOptions.value).then(resolve,error=>{shouldThrowError(defaultedOptions.value.throwOnError,[error,observer.getCurrentQuery()])?reject(error):resolve(observer.getCurrentResult())})):(stopWatch(),resolve(optimisticResult))}},"run");run(),stopWatch=watch(defaultedOptions,run)}),"suspense");watch(()=>state.error,error=>{if(state.isError&&!state.isFetching&&shouldThrowError(defaultedOptions.value.throwOnError,[error,observer.getCurrentQuery()]))throw error});const readonlyState=defaultedOptions.value.shallow?shallowReadonly(state):readonly(state),object=toRefs(readonlyState);for(const key in state)typeof state[key]=="function"&&(object[key]=state[key]);return object.suspense=suspense,object.refetch=refetch,object}__name(useBaseQuery,"useBaseQuery");function useQuery(options,queryClient){return useBaseQuery(QueryObserver,options)}__name(useQuery,"useQuery");export{useQuery as u};
