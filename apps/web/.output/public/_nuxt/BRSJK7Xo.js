var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,"name",{value,configurable:!0});/**
* @vue/shared v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function makeMap(str){const map=Object.create(null);for(const key of str.split(","))map[key]=1;return val=>val in map}__name(makeMap,"makeMap");const EMPTY_OBJ={},EMPTY_ARR=[],NOOP=__name(()=>{},"NOOP"),NO=__name(()=>!1,"NO"),isOn=__name(key=>key.charCodeAt(0)===111&&key.charCodeAt(1)===110&&(key.charCodeAt(2)>122||key.charCodeAt(2)<97),"isOn"),isModelListener=__name(key=>key.startsWith("onUpdate:"),"isModelListener"),extend=Object.assign,remove=__name((arr,el)=>{const i=arr.indexOf(el);i>-1&&arr.splice(i,1)},"remove"),hasOwnProperty$1=Object.prototype.hasOwnProperty,hasOwn=__name((val,key)=>hasOwnProperty$1.call(val,key),"hasOwn"),isArray$1=Array.isArray,isMap=__name(val=>toTypeString(val)==="[object Map]","isMap"),isSet=__name(val=>toTypeString(val)==="[object Set]","isSet"),isDate=__name(val=>toTypeString(val)==="[object Date]","isDate"),isRegExp=__name(val=>toTypeString(val)==="[object RegExp]","isRegExp"),isFunction=__name(val=>typeof val=="function","isFunction"),isString=__name(val=>typeof val=="string","isString"),isSymbol=__name(val=>typeof val=="symbol","isSymbol"),isObject=__name(val=>val!==null&&typeof val=="object","isObject"),isPromise=__name(val=>(isObject(val)||isFunction(val))&&isFunction(val.then)&&isFunction(val.catch),"isPromise"),objectToString=Object.prototype.toString,toTypeString=__name(value=>objectToString.call(value),"toTypeString"),toRawType=__name(value=>toTypeString(value).slice(8,-1),"toRawType"),isPlainObject$1=__name(val=>toTypeString(val)==="[object Object]","isPlainObject$1"),isIntegerKey=__name(key=>isString(key)&&key!=="NaN"&&key[0]!=="-"&&""+parseInt(key,10)===key,"isIntegerKey"),isReservedProp=makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),cacheStringFunction=__name(fn=>{const cache=Object.create(null);return str=>cache[str]||(cache[str]=fn(str))},"cacheStringFunction"),camelizeRE=/-(\w)/g,camelize=cacheStringFunction(str=>str.replace(camelizeRE,(_,c)=>c?c.toUpperCase():"")),hyphenateRE=/\B([A-Z])/g,hyphenate=cacheStringFunction(str=>str.replace(hyphenateRE,"-$1").toLowerCase()),capitalize=cacheStringFunction(str=>str.charAt(0).toUpperCase()+str.slice(1)),toHandlerKey=cacheStringFunction(str=>str?`on${capitalize(str)}`:""),hasChanged=__name((value,oldValue)=>!Object.is(value,oldValue),"hasChanged"),invokeArrayFns=__name((fns,...arg)=>{for(let i=0;i<fns.length;i++)fns[i](...arg)},"invokeArrayFns"),def=__name((obj,key,value,writable=!1)=>{Object.defineProperty(obj,key,{configurable:!0,enumerable:!1,writable,value})},"def"),looseToNumber=__name(val=>{const n=parseFloat(val);return isNaN(n)?val:n},"looseToNumber"),toNumber=__name(val=>{const n=isString(val)?Number(val):NaN;return isNaN(n)?val:n},"toNumber");let _globalThis;const getGlobalThis=__name(()=>_globalThis||(_globalThis=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{}),"getGlobalThis"),GLOBALS_ALLOWED="Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol",isGloballyAllowed=makeMap(GLOBALS_ALLOWED);function normalizeStyle(value){if(isArray$1(value)){const res={};for(let i=0;i<value.length;i++){const item=value[i],normalized=isString(item)?parseStringStyle(item):normalizeStyle(item);if(normalized)for(const key in normalized)res[key]=normalized[key]}return res}else if(isString(value)||isObject(value))return value}__name(normalizeStyle,"normalizeStyle");const listDelimiterRE=/;(?![^(]*\))/g,propertyDelimiterRE=/:([^]+)/,styleCommentRE=/\/\*[^]*?\*\//g;function parseStringStyle(cssText){const ret={};return cssText.replace(styleCommentRE,"").split(listDelimiterRE).forEach(item=>{if(item){const tmp=item.split(propertyDelimiterRE);tmp.length>1&&(ret[tmp[0].trim()]=tmp[1].trim())}}),ret}__name(parseStringStyle,"parseStringStyle");function normalizeClass(value){let res="";if(isString(value))res=value;else if(isArray$1(value))for(let i=0;i<value.length;i++){const normalized=normalizeClass(value[i]);normalized&&(res+=normalized+" ")}else if(isObject(value))for(const name in value)value[name]&&(res+=name+" ");return res.trim()}__name(normalizeClass,"normalizeClass");function normalizeProps(props){if(!props)return null;let{class:klass,style}=props;return klass&&!isString(klass)&&(props.class=normalizeClass(klass)),style&&(props.style=normalizeStyle(style)),props}__name(normalizeProps,"normalizeProps");const specialBooleanAttrs="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",isSpecialBooleanAttr=makeMap(specialBooleanAttrs);function includeBooleanAttr(value){return!!value||value===""}__name(includeBooleanAttr,"includeBooleanAttr");function looseCompareArrays(a,b){if(a.length!==b.length)return!1;let equal=!0;for(let i=0;equal&&i<a.length;i++)equal=looseEqual(a[i],b[i]);return equal}__name(looseCompareArrays,"looseCompareArrays");function looseEqual(a,b){if(a===b)return!0;let aValidType=isDate(a),bValidType=isDate(b);if(aValidType||bValidType)return aValidType&&bValidType?a.getTime()===b.getTime():!1;if(aValidType=isSymbol(a),bValidType=isSymbol(b),aValidType||bValidType)return a===b;if(aValidType=isArray$1(a),bValidType=isArray$1(b),aValidType||bValidType)return aValidType&&bValidType?looseCompareArrays(a,b):!1;if(aValidType=isObject(a),bValidType=isObject(b),aValidType||bValidType){if(!aValidType||!bValidType)return!1;const aKeysCount=Object.keys(a).length,bKeysCount=Object.keys(b).length;if(aKeysCount!==bKeysCount)return!1;for(const key in a){const aHasKey=a.hasOwnProperty(key),bHasKey=b.hasOwnProperty(key);if(aHasKey&&!bHasKey||!aHasKey&&bHasKey||!looseEqual(a[key],b[key]))return!1}}return String(a)===String(b)}__name(looseEqual,"looseEqual");function looseIndexOf(arr,val){return arr.findIndex(item=>looseEqual(item,val))}__name(looseIndexOf,"looseIndexOf");const isRef$1=__name(val=>!!(val&&val.__v_isRef===!0),"isRef$1"),toDisplayString=__name(val=>isString(val)?val:val==null?"":isArray$1(val)||isObject(val)&&(val.toString===objectToString||!isFunction(val.toString))?isRef$1(val)?toDisplayString(val.value):JSON.stringify(val,replacer,2):String(val),"toDisplayString"),replacer=__name((_key,val)=>isRef$1(val)?replacer(_key,val.value):isMap(val)?{[`Map(${val.size})`]:[...val.entries()].reduce((entries,[key,val2],i)=>(entries[stringifySymbol(key,i)+" =>"]=val2,entries),{})}:isSet(val)?{[`Set(${val.size})`]:[...val.values()].map(v=>stringifySymbol(v))}:isSymbol(val)?stringifySymbol(val):isObject(val)&&!isArray$1(val)&&!isPlainObject$1(val)?String(val):val,"replacer"),stringifySymbol=__name((v,i="")=>{var _a;return isSymbol(v)?`Symbol(${(_a=v.description)!=null?_a:i})`:v},"stringifySymbol");function normalizeCssVarValue(value){return value==null?"initial":typeof value=="string"?value===""?" ":value:String(value)}__name(normalizeCssVarValue,"normalizeCssVarValue");/**
* @vue/reactivity v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let activeEffectScope;const _EffectScope=class _EffectScope{constructor(detached=!1){this.detached=detached,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=activeEffectScope,!detached&&activeEffectScope&&(this.index=(activeEffectScope.scopes||(activeEffectScope.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let i,l;if(this.scopes)for(i=0,l=this.scopes.length;i<l;i++)this.scopes[i].pause();for(i=0,l=this.effects.length;i<l;i++)this.effects[i].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let i,l;if(this.scopes)for(i=0,l=this.scopes.length;i<l;i++)this.scopes[i].resume();for(i=0,l=this.effects.length;i<l;i++)this.effects[i].resume()}}run(fn){if(this._active){const currentEffectScope=activeEffectScope;try{return activeEffectScope=this,fn()}finally{activeEffectScope=currentEffectScope}}}on(){++this._on===1&&(this.prevScope=activeEffectScope,activeEffectScope=this)}off(){this._on>0&&--this._on===0&&(activeEffectScope=this.prevScope,this.prevScope=void 0)}stop(fromParent){if(this._active){this._active=!1;let i,l;for(i=0,l=this.effects.length;i<l;i++)this.effects[i].stop();for(this.effects.length=0,i=0,l=this.cleanups.length;i<l;i++)this.cleanups[i]();if(this.cleanups.length=0,this.scopes){for(i=0,l=this.scopes.length;i<l;i++)this.scopes[i].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!fromParent){const last=this.parent.scopes.pop();last&&last!==this&&(this.parent.scopes[this.index]=last,last.index=this.index)}this.parent=void 0}}};__name(_EffectScope,"EffectScope");let EffectScope=_EffectScope;function effectScope(detached){return new EffectScope(detached)}__name(effectScope,"effectScope");function getCurrentScope(){return activeEffectScope}__name(getCurrentScope,"getCurrentScope");function onScopeDispose(fn,failSilently=!1){activeEffectScope&&activeEffectScope.cleanups.push(fn)}__name(onScopeDispose,"onScopeDispose");let activeSub;const pausedQueueEffects=new WeakSet,_ReactiveEffect=class _ReactiveEffect{constructor(fn){this.fn=fn,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,activeEffectScope&&activeEffectScope.active&&activeEffectScope.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,pausedQueueEffects.has(this)&&(pausedQueueEffects.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||batch(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,cleanupEffect(this),prepareDeps(this);const prevEffect=activeSub,prevShouldTrack=shouldTrack;activeSub=this,shouldTrack=!0;try{return this.fn()}finally{cleanupDeps(this),activeSub=prevEffect,shouldTrack=prevShouldTrack,this.flags&=-3}}stop(){if(this.flags&1){for(let link=this.deps;link;link=link.nextDep)removeSub(link);this.deps=this.depsTail=void 0,cleanupEffect(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?pausedQueueEffects.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){isDirty(this)&&this.run()}get dirty(){return isDirty(this)}};__name(_ReactiveEffect,"ReactiveEffect");let ReactiveEffect=_ReactiveEffect,batchDepth=0,batchedSub,batchedComputed;function batch(sub,isComputed2=!1){if(sub.flags|=8,isComputed2){sub.next=batchedComputed,batchedComputed=sub;return}sub.next=batchedSub,batchedSub=sub}__name(batch,"batch");function startBatch(){batchDepth++}__name(startBatch,"startBatch");function endBatch(){if(--batchDepth>0)return;if(batchedComputed){let e=batchedComputed;for(batchedComputed=void 0;e;){const next=e.next;e.next=void 0,e.flags&=-9,e=next}}let error;for(;batchedSub;){let e=batchedSub;for(batchedSub=void 0;e;){const next=e.next;if(e.next=void 0,e.flags&=-9,e.flags&1)try{e.trigger()}catch(err){error||(error=err)}e=next}}if(error)throw error}__name(endBatch,"endBatch");function prepareDeps(sub){for(let link=sub.deps;link;link=link.nextDep)link.version=-1,link.prevActiveLink=link.dep.activeLink,link.dep.activeLink=link}__name(prepareDeps,"prepareDeps");function cleanupDeps(sub){let head,tail=sub.depsTail,link=tail;for(;link;){const prev=link.prevDep;link.version===-1?(link===tail&&(tail=prev),removeSub(link),removeDep(link)):head=link,link.dep.activeLink=link.prevActiveLink,link.prevActiveLink=void 0,link=prev}sub.deps=head,sub.depsTail=tail}__name(cleanupDeps,"cleanupDeps");function isDirty(sub){for(let link=sub.deps;link;link=link.nextDep)if(link.dep.version!==link.version||link.dep.computed&&(refreshComputed(link.dep.computed)||link.dep.version!==link.version))return!0;return!!sub._dirty}__name(isDirty,"isDirty");function refreshComputed(computed2){if(computed2.flags&4&&!(computed2.flags&16)||(computed2.flags&=-17,computed2.globalVersion===globalVersion)||(computed2.globalVersion=globalVersion,!computed2.isSSR&&computed2.flags&128&&(!computed2.deps&&!computed2._dirty||!isDirty(computed2))))return;computed2.flags|=2;const dep=computed2.dep,prevSub=activeSub,prevShouldTrack=shouldTrack;activeSub=computed2,shouldTrack=!0;try{prepareDeps(computed2);const value=computed2.fn(computed2._value);(dep.version===0||hasChanged(value,computed2._value))&&(computed2.flags|=128,computed2._value=value,dep.version++)}catch(err){throw dep.version++,err}finally{activeSub=prevSub,shouldTrack=prevShouldTrack,cleanupDeps(computed2),computed2.flags&=-3}}__name(refreshComputed,"refreshComputed");function removeSub(link,soft=!1){const{dep,prevSub,nextSub}=link;if(prevSub&&(prevSub.nextSub=nextSub,link.prevSub=void 0),nextSub&&(nextSub.prevSub=prevSub,link.nextSub=void 0),dep.subs===link&&(dep.subs=prevSub,!prevSub&&dep.computed)){dep.computed.flags&=-5;for(let l=dep.computed.deps;l;l=l.nextDep)removeSub(l,!0)}!soft&&!--dep.sc&&dep.map&&dep.map.delete(dep.key)}__name(removeSub,"removeSub");function removeDep(link){const{prevDep,nextDep}=link;prevDep&&(prevDep.nextDep=nextDep,link.prevDep=void 0),nextDep&&(nextDep.prevDep=prevDep,link.nextDep=void 0)}__name(removeDep,"removeDep");function effect(fn,options){fn.effect instanceof ReactiveEffect&&(fn=fn.effect.fn);const e=new ReactiveEffect(fn);options&&extend(e,options);try{e.run()}catch(err){throw e.stop(),err}const runner=e.run.bind(e);return runner.effect=e,runner}__name(effect,"effect");function stop(runner){runner.effect.stop()}__name(stop,"stop");let shouldTrack=!0;const trackStack=[];function pauseTracking(){trackStack.push(shouldTrack),shouldTrack=!1}__name(pauseTracking,"pauseTracking");function resetTracking(){const last=trackStack.pop();shouldTrack=last===void 0?!0:last}__name(resetTracking,"resetTracking");function cleanupEffect(e){const{cleanup}=e;if(e.cleanup=void 0,cleanup){const prevSub=activeSub;activeSub=void 0;try{cleanup()}finally{activeSub=prevSub}}}__name(cleanupEffect,"cleanupEffect");let globalVersion=0;const _Link=class _Link{constructor(sub,dep){this.sub=sub,this.dep=dep,this.version=dep.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}};__name(_Link,"Link");let Link=_Link;const _Dep=class _Dep{constructor(computed2){this.computed=computed2,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(debugInfo){if(!activeSub||!shouldTrack||activeSub===this.computed)return;let link=this.activeLink;if(link===void 0||link.sub!==activeSub)link=this.activeLink=new Link(activeSub,this),activeSub.deps?(link.prevDep=activeSub.depsTail,activeSub.depsTail.nextDep=link,activeSub.depsTail=link):activeSub.deps=activeSub.depsTail=link,addSub(link);else if(link.version===-1&&(link.version=this.version,link.nextDep)){const next=link.nextDep;next.prevDep=link.prevDep,link.prevDep&&(link.prevDep.nextDep=next),link.prevDep=activeSub.depsTail,link.nextDep=void 0,activeSub.depsTail.nextDep=link,activeSub.depsTail=link,activeSub.deps===link&&(activeSub.deps=next)}return link}trigger(debugInfo){this.version++,globalVersion++,this.notify(debugInfo)}notify(debugInfo){startBatch();try{for(let link=this.subs;link;link=link.prevSub)link.sub.notify()&&link.sub.dep.notify()}finally{endBatch()}}};__name(_Dep,"Dep");let Dep=_Dep;function addSub(link){if(link.dep.sc++,link.sub.flags&4){const computed2=link.dep.computed;if(computed2&&!link.dep.subs){computed2.flags|=20;for(let l=computed2.deps;l;l=l.nextDep)addSub(l)}const currentTail=link.dep.subs;currentTail!==link&&(link.prevSub=currentTail,currentTail&&(currentTail.nextSub=link)),link.dep.subs=link}}__name(addSub,"addSub");const targetMap=new WeakMap,ITERATE_KEY=Symbol(""),MAP_KEY_ITERATE_KEY=Symbol(""),ARRAY_ITERATE_KEY=Symbol("");function track(target,type,key){if(shouldTrack&&activeSub){let depsMap=targetMap.get(target);depsMap||targetMap.set(target,depsMap=new Map);let dep=depsMap.get(key);dep||(depsMap.set(key,dep=new Dep),dep.map=depsMap,dep.key=key),dep.track()}}__name(track,"track");function trigger(target,type,key,newValue,oldValue,oldTarget){const depsMap=targetMap.get(target);if(!depsMap){globalVersion++;return}const run=__name(dep=>{dep&&dep.trigger()},"run");if(startBatch(),type==="clear")depsMap.forEach(run);else{const targetIsArray=isArray$1(target),isArrayIndex=targetIsArray&&isIntegerKey(key);if(targetIsArray&&key==="length"){const newLength=Number(newValue);depsMap.forEach((dep,key2)=>{(key2==="length"||key2===ARRAY_ITERATE_KEY||!isSymbol(key2)&&key2>=newLength)&&run(dep)})}else switch((key!==void 0||depsMap.has(void 0))&&run(depsMap.get(key)),isArrayIndex&&run(depsMap.get(ARRAY_ITERATE_KEY)),type){case"add":targetIsArray?isArrayIndex&&run(depsMap.get("length")):(run(depsMap.get(ITERATE_KEY)),isMap(target)&&run(depsMap.get(MAP_KEY_ITERATE_KEY)));break;case"delete":targetIsArray||(run(depsMap.get(ITERATE_KEY)),isMap(target)&&run(depsMap.get(MAP_KEY_ITERATE_KEY)));break;case"set":isMap(target)&&run(depsMap.get(ITERATE_KEY));break}}endBatch()}__name(trigger,"trigger");function getDepFromReactive(object,key){const depMap=targetMap.get(object);return depMap&&depMap.get(key)}__name(getDepFromReactive,"getDepFromReactive");function reactiveReadArray(array){const raw=toRaw(array);return raw===array?raw:(track(raw,"iterate",ARRAY_ITERATE_KEY),isShallow(array)?raw:raw.map(toReactive))}__name(reactiveReadArray,"reactiveReadArray");function shallowReadArray(arr){return track(arr=toRaw(arr),"iterate",ARRAY_ITERATE_KEY),arr}__name(shallowReadArray,"shallowReadArray");const arrayInstrumentations={__proto__:null,[Symbol.iterator](){return iterator(this,Symbol.iterator,toReactive)},concat(...args){return reactiveReadArray(this).concat(...args.map(x=>isArray$1(x)?reactiveReadArray(x):x))},entries(){return iterator(this,"entries",value=>(value[1]=toReactive(value[1]),value))},every(fn,thisArg){return apply(this,"every",fn,thisArg,void 0,arguments)},filter(fn,thisArg){return apply(this,"filter",fn,thisArg,v=>v.map(toReactive),arguments)},find(fn,thisArg){return apply(this,"find",fn,thisArg,toReactive,arguments)},findIndex(fn,thisArg){return apply(this,"findIndex",fn,thisArg,void 0,arguments)},findLast(fn,thisArg){return apply(this,"findLast",fn,thisArg,toReactive,arguments)},findLastIndex(fn,thisArg){return apply(this,"findLastIndex",fn,thisArg,void 0,arguments)},forEach(fn,thisArg){return apply(this,"forEach",fn,thisArg,void 0,arguments)},includes(...args){return searchProxy(this,"includes",args)},indexOf(...args){return searchProxy(this,"indexOf",args)},join(separator){return reactiveReadArray(this).join(separator)},lastIndexOf(...args){return searchProxy(this,"lastIndexOf",args)},map(fn,thisArg){return apply(this,"map",fn,thisArg,void 0,arguments)},pop(){return noTracking(this,"pop")},push(...args){return noTracking(this,"push",args)},reduce(fn,...args){return reduce(this,"reduce",fn,args)},reduceRight(fn,...args){return reduce(this,"reduceRight",fn,args)},shift(){return noTracking(this,"shift")},some(fn,thisArg){return apply(this,"some",fn,thisArg,void 0,arguments)},splice(...args){return noTracking(this,"splice",args)},toReversed(){return reactiveReadArray(this).toReversed()},toSorted(comparer){return reactiveReadArray(this).toSorted(comparer)},toSpliced(...args){return reactiveReadArray(this).toSpliced(...args)},unshift(...args){return noTracking(this,"unshift",args)},values(){return iterator(this,"values",toReactive)}};function iterator(self2,method,wrapValue){const arr=shallowReadArray(self2),iter=arr[method]();return arr!==self2&&!isShallow(self2)&&(iter._next=iter.next,iter.next=()=>{const result=iter._next();return result.value&&(result.value=wrapValue(result.value)),result}),iter}__name(iterator,"iterator");const arrayProto=Array.prototype;function apply(self2,method,fn,thisArg,wrappedRetFn,args){const arr=shallowReadArray(self2),needsWrap=arr!==self2&&!isShallow(self2),methodFn=arr[method];if(methodFn!==arrayProto[method]){const result2=methodFn.apply(self2,args);return needsWrap?toReactive(result2):result2}let wrappedFn=fn;arr!==self2&&(needsWrap?wrappedFn=__name(function(item,index){return fn.call(this,toReactive(item),index,self2)},"wrappedFn"):fn.length>2&&(wrappedFn=__name(function(item,index){return fn.call(this,item,index,self2)},"wrappedFn")));const result=methodFn.call(arr,wrappedFn,thisArg);return needsWrap&&wrappedRetFn?wrappedRetFn(result):result}__name(apply,"apply");function reduce(self2,method,fn,args){const arr=shallowReadArray(self2);let wrappedFn=fn;return arr!==self2&&(isShallow(self2)?fn.length>3&&(wrappedFn=__name(function(acc,item,index){return fn.call(this,acc,item,index,self2)},"wrappedFn")):wrappedFn=__name(function(acc,item,index){return fn.call(this,acc,toReactive(item),index,self2)},"wrappedFn")),arr[method](wrappedFn,...args)}__name(reduce,"reduce");function searchProxy(self2,method,args){const arr=toRaw(self2);track(arr,"iterate",ARRAY_ITERATE_KEY);const res=arr[method](...args);return(res===-1||res===!1)&&isProxy(args[0])?(args[0]=toRaw(args[0]),arr[method](...args)):res}__name(searchProxy,"searchProxy");function noTracking(self2,method,args=[]){pauseTracking(),startBatch();const res=toRaw(self2)[method].apply(self2,args);return endBatch(),resetTracking(),res}__name(noTracking,"noTracking");const isNonTrackableKeys=makeMap("__proto__,__v_isRef,__isVue"),builtInSymbols=new Set(Object.getOwnPropertyNames(Symbol).filter(key=>key!=="arguments"&&key!=="caller").map(key=>Symbol[key]).filter(isSymbol));function hasOwnProperty(key){isSymbol(key)||(key=String(key));const obj=toRaw(this);return track(obj,"has",key),obj.hasOwnProperty(key)}__name(hasOwnProperty,"hasOwnProperty");const _BaseReactiveHandler=class _BaseReactiveHandler{constructor(_isReadonly=!1,_isShallow=!1){this._isReadonly=_isReadonly,this._isShallow=_isShallow}get(target,key,receiver){if(key==="__v_skip")return target.__v_skip;const isReadonly2=this._isReadonly,isShallow2=this._isShallow;if(key==="__v_isReactive")return!isReadonly2;if(key==="__v_isReadonly")return isReadonly2;if(key==="__v_isShallow")return isShallow2;if(key==="__v_raw")return receiver===(isReadonly2?isShallow2?shallowReadonlyMap:readonlyMap:isShallow2?shallowReactiveMap:reactiveMap).get(target)||Object.getPrototypeOf(target)===Object.getPrototypeOf(receiver)?target:void 0;const targetIsArray=isArray$1(target);if(!isReadonly2){let fn;if(targetIsArray&&(fn=arrayInstrumentations[key]))return fn;if(key==="hasOwnProperty")return hasOwnProperty}const res=Reflect.get(target,key,isRef(target)?target:receiver);return(isSymbol(key)?builtInSymbols.has(key):isNonTrackableKeys(key))||(isReadonly2||track(target,"get",key),isShallow2)?res:isRef(res)?targetIsArray&&isIntegerKey(key)?res:res.value:isObject(res)?isReadonly2?readonly(res):reactive(res):res}};__name(_BaseReactiveHandler,"BaseReactiveHandler");let BaseReactiveHandler=_BaseReactiveHandler;const _MutableReactiveHandler=class _MutableReactiveHandler extends BaseReactiveHandler{constructor(isShallow2=!1){super(!1,isShallow2)}set(target,key,value,receiver){let oldValue=target[key];if(!this._isShallow){const isOldValueReadonly=isReadonly(oldValue);if(!isShallow(value)&&!isReadonly(value)&&(oldValue=toRaw(oldValue),value=toRaw(value)),!isArray$1(target)&&isRef(oldValue)&&!isRef(value))return isOldValueReadonly?!1:(oldValue.value=value,!0)}const hadKey=isArray$1(target)&&isIntegerKey(key)?Number(key)<target.length:hasOwn(target,key),result=Reflect.set(target,key,value,isRef(target)?target:receiver);return target===toRaw(receiver)&&(hadKey?hasChanged(value,oldValue)&&trigger(target,"set",key,value):trigger(target,"add",key,value)),result}deleteProperty(target,key){const hadKey=hasOwn(target,key);target[key];const result=Reflect.deleteProperty(target,key);return result&&hadKey&&trigger(target,"delete",key,void 0),result}has(target,key){const result=Reflect.has(target,key);return(!isSymbol(key)||!builtInSymbols.has(key))&&track(target,"has",key),result}ownKeys(target){return track(target,"iterate",isArray$1(target)?"length":ITERATE_KEY),Reflect.ownKeys(target)}};__name(_MutableReactiveHandler,"MutableReactiveHandler");let MutableReactiveHandler=_MutableReactiveHandler;const _ReadonlyReactiveHandler=class _ReadonlyReactiveHandler extends BaseReactiveHandler{constructor(isShallow2=!1){super(!0,isShallow2)}set(target,key){return!0}deleteProperty(target,key){return!0}};__name(_ReadonlyReactiveHandler,"ReadonlyReactiveHandler");let ReadonlyReactiveHandler=_ReadonlyReactiveHandler;const mutableHandlers=new MutableReactiveHandler,readonlyHandlers=new ReadonlyReactiveHandler,shallowReactiveHandlers=new MutableReactiveHandler(!0),shallowReadonlyHandlers=new ReadonlyReactiveHandler(!0),toShallow=__name(value=>value,"toShallow"),getProto=__name(v=>Reflect.getPrototypeOf(v),"getProto");function createIterableMethod(method,isReadonly2,isShallow2){return function(...args){const target=this.__v_raw,rawTarget=toRaw(target),targetIsMap=isMap(rawTarget),isPair=method==="entries"||method===Symbol.iterator&&targetIsMap,isKeyOnly=method==="keys"&&targetIsMap,innerIterator=target[method](...args),wrap=isShallow2?toShallow:isReadonly2?toReadonly:toReactive;return!isReadonly2&&track(rawTarget,"iterate",isKeyOnly?MAP_KEY_ITERATE_KEY:ITERATE_KEY),{next(){const{value,done}=innerIterator.next();return done?{value,done}:{value:isPair?[wrap(value[0]),wrap(value[1])]:wrap(value),done}},[Symbol.iterator](){return this}}}}__name(createIterableMethod,"createIterableMethod");function createReadonlyMethod(type){return function(...args){return type==="delete"?!1:type==="clear"?void 0:this}}__name(createReadonlyMethod,"createReadonlyMethod");function createInstrumentations(readonly2,shallow){const instrumentations={get(key){const target=this.__v_raw,rawTarget=toRaw(target),rawKey=toRaw(key);readonly2||(hasChanged(key,rawKey)&&track(rawTarget,"get",key),track(rawTarget,"get",rawKey));const{has}=getProto(rawTarget),wrap=shallow?toShallow:readonly2?toReadonly:toReactive;if(has.call(rawTarget,key))return wrap(target.get(key));if(has.call(rawTarget,rawKey))return wrap(target.get(rawKey));target!==rawTarget&&target.get(key)},get size(){const target=this.__v_raw;return!readonly2&&track(toRaw(target),"iterate",ITERATE_KEY),Reflect.get(target,"size",target)},has(key){const target=this.__v_raw,rawTarget=toRaw(target),rawKey=toRaw(key);return readonly2||(hasChanged(key,rawKey)&&track(rawTarget,"has",key),track(rawTarget,"has",rawKey)),key===rawKey?target.has(key):target.has(key)||target.has(rawKey)},forEach(callback,thisArg){const observed=this,target=observed.__v_raw,rawTarget=toRaw(target),wrap=shallow?toShallow:readonly2?toReadonly:toReactive;return!readonly2&&track(rawTarget,"iterate",ITERATE_KEY),target.forEach((value,key)=>callback.call(thisArg,wrap(value),wrap(key),observed))}};return extend(instrumentations,readonly2?{add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear")}:{add(value){!shallow&&!isShallow(value)&&!isReadonly(value)&&(value=toRaw(value));const target=toRaw(this);return getProto(target).has.call(target,value)||(target.add(value),trigger(target,"add",value,value)),this},set(key,value){!shallow&&!isShallow(value)&&!isReadonly(value)&&(value=toRaw(value));const target=toRaw(this),{has,get}=getProto(target);let hadKey=has.call(target,key);hadKey||(key=toRaw(key),hadKey=has.call(target,key));const oldValue=get.call(target,key);return target.set(key,value),hadKey?hasChanged(value,oldValue)&&trigger(target,"set",key,value):trigger(target,"add",key,value),this},delete(key){const target=toRaw(this),{has,get}=getProto(target);let hadKey=has.call(target,key);hadKey||(key=toRaw(key),hadKey=has.call(target,key)),get&&get.call(target,key);const result=target.delete(key);return hadKey&&trigger(target,"delete",key,void 0),result},clear(){const target=toRaw(this),hadItems=target.size!==0,result=target.clear();return hadItems&&trigger(target,"clear",void 0,void 0),result}}),["keys","values","entries",Symbol.iterator].forEach(method=>{instrumentations[method]=createIterableMethod(method,readonly2,shallow)}),instrumentations}__name(createInstrumentations,"createInstrumentations");function createInstrumentationGetter(isReadonly2,shallow){const instrumentations=createInstrumentations(isReadonly2,shallow);return(target,key,receiver)=>key==="__v_isReactive"?!isReadonly2:key==="__v_isReadonly"?isReadonly2:key==="__v_raw"?target:Reflect.get(hasOwn(instrumentations,key)&&key in target?instrumentations:target,key,receiver)}__name(createInstrumentationGetter,"createInstrumentationGetter");const mutableCollectionHandlers={get:createInstrumentationGetter(!1,!1)},shallowCollectionHandlers={get:createInstrumentationGetter(!1,!0)},readonlyCollectionHandlers={get:createInstrumentationGetter(!0,!1)},shallowReadonlyCollectionHandlers={get:createInstrumentationGetter(!0,!0)},reactiveMap=new WeakMap,shallowReactiveMap=new WeakMap,readonlyMap=new WeakMap,shallowReadonlyMap=new WeakMap;function targetTypeMap(rawType){switch(rawType){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}__name(targetTypeMap,"targetTypeMap");function getTargetType(value){return value.__v_skip||!Object.isExtensible(value)?0:targetTypeMap(toRawType(value))}__name(getTargetType,"getTargetType");function reactive(target){return isReadonly(target)?target:createReactiveObject(target,!1,mutableHandlers,mutableCollectionHandlers,reactiveMap)}__name(reactive,"reactive");function shallowReactive(target){return createReactiveObject(target,!1,shallowReactiveHandlers,shallowCollectionHandlers,shallowReactiveMap)}__name(shallowReactive,"shallowReactive");function readonly(target){return createReactiveObject(target,!0,readonlyHandlers,readonlyCollectionHandlers,readonlyMap)}__name(readonly,"readonly");function shallowReadonly(target){return createReactiveObject(target,!0,shallowReadonlyHandlers,shallowReadonlyCollectionHandlers,shallowReadonlyMap)}__name(shallowReadonly,"shallowReadonly");function createReactiveObject(target,isReadonly2,baseHandlers,collectionHandlers,proxyMap){if(!isObject(target)||target.__v_raw&&!(isReadonly2&&target.__v_isReactive))return target;const targetType=getTargetType(target);if(targetType===0)return target;const existingProxy=proxyMap.get(target);if(existingProxy)return existingProxy;const proxy=new Proxy(target,targetType===2?collectionHandlers:baseHandlers);return proxyMap.set(target,proxy),proxy}__name(createReactiveObject,"createReactiveObject");function isReactive(value){return isReadonly(value)?isReactive(value.__v_raw):!!(value&&value.__v_isReactive)}__name(isReactive,"isReactive");function isReadonly(value){return!!(value&&value.__v_isReadonly)}__name(isReadonly,"isReadonly");function isShallow(value){return!!(value&&value.__v_isShallow)}__name(isShallow,"isShallow");function isProxy(value){return value?!!value.__v_raw:!1}__name(isProxy,"isProxy");function toRaw(observed){const raw=observed&&observed.__v_raw;return raw?toRaw(raw):observed}__name(toRaw,"toRaw");function markRaw(value){return!hasOwn(value,"__v_skip")&&Object.isExtensible(value)&&def(value,"__v_skip",!0),value}__name(markRaw,"markRaw");const toReactive=__name(value=>isObject(value)?reactive(value):value,"toReactive"),toReadonly=__name(value=>isObject(value)?readonly(value):value,"toReadonly");function isRef(r){return r?r.__v_isRef===!0:!1}__name(isRef,"isRef");function ref(value){return createRef(value,!1)}__name(ref,"ref");function shallowRef(value){return createRef(value,!0)}__name(shallowRef,"shallowRef");function createRef(rawValue,shallow){return isRef(rawValue)?rawValue:new RefImpl(rawValue,shallow)}__name(createRef,"createRef");const _RefImpl=class _RefImpl{constructor(value,isShallow2){this.dep=new Dep,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=isShallow2?value:toRaw(value),this._value=isShallow2?value:toReactive(value),this.__v_isShallow=isShallow2}get value(){return this.dep.track(),this._value}set value(newValue){const oldValue=this._rawValue,useDirectValue=this.__v_isShallow||isShallow(newValue)||isReadonly(newValue);newValue=useDirectValue?newValue:toRaw(newValue),hasChanged(newValue,oldValue)&&(this._rawValue=newValue,this._value=useDirectValue?newValue:toReactive(newValue),this.dep.trigger())}};__name(_RefImpl,"RefImpl");let RefImpl=_RefImpl;function triggerRef(ref2){ref2.dep&&ref2.dep.trigger()}__name(triggerRef,"triggerRef");function unref(ref2){return isRef(ref2)?ref2.value:ref2}__name(unref,"unref");function toValue(source){return isFunction(source)?source():unref(source)}__name(toValue,"toValue");const shallowUnwrapHandlers={get:__name((target,key,receiver)=>key==="__v_raw"?target:unref(Reflect.get(target,key,receiver)),"get"),set:__name((target,key,value,receiver)=>{const oldValue=target[key];return isRef(oldValue)&&!isRef(value)?(oldValue.value=value,!0):Reflect.set(target,key,value,receiver)},"set")};function proxyRefs(objectWithRefs){return isReactive(objectWithRefs)?objectWithRefs:new Proxy(objectWithRefs,shallowUnwrapHandlers)}__name(proxyRefs,"proxyRefs");const _CustomRefImpl=class _CustomRefImpl{constructor(factory){this.__v_isRef=!0,this._value=void 0;const dep=this.dep=new Dep,{get,set}=factory(dep.track.bind(dep),dep.trigger.bind(dep));this._get=get,this._set=set}get value(){return this._value=this._get()}set value(newVal){this._set(newVal)}};__name(_CustomRefImpl,"CustomRefImpl");let CustomRefImpl=_CustomRefImpl;function customRef(factory){return new CustomRefImpl(factory)}__name(customRef,"customRef");function toRefs(object){const ret=isArray$1(object)?new Array(object.length):{};for(const key in object)ret[key]=propertyToRef(object,key);return ret}__name(toRefs,"toRefs");const _ObjectRefImpl=class _ObjectRefImpl{constructor(_object,_key,_defaultValue){this._object=_object,this._key=_key,this._defaultValue=_defaultValue,this.__v_isRef=!0,this._value=void 0}get value(){const val=this._object[this._key];return this._value=val===void 0?this._defaultValue:val}set value(newVal){this._object[this._key]=newVal}get dep(){return getDepFromReactive(toRaw(this._object),this._key)}};__name(_ObjectRefImpl,"ObjectRefImpl");let ObjectRefImpl=_ObjectRefImpl;const _GetterRefImpl=class _GetterRefImpl{constructor(_getter){this._getter=_getter,this.__v_isRef=!0,this.__v_isReadonly=!0,this._value=void 0}get value(){return this._value=this._getter()}};__name(_GetterRefImpl,"GetterRefImpl");let GetterRefImpl=_GetterRefImpl;function toRef(source,key,defaultValue){return isRef(source)?source:isFunction(source)?new GetterRefImpl(source):isObject(source)&&arguments.length>1?propertyToRef(source,key,defaultValue):ref(source)}__name(toRef,"toRef");function propertyToRef(source,key,defaultValue){const val=source[key];return isRef(val)?val:new ObjectRefImpl(source,key,defaultValue)}__name(propertyToRef,"propertyToRef");const _ComputedRefImpl=class _ComputedRefImpl{constructor(fn,setter,isSSR){this.fn=fn,this.setter=setter,this._value=void 0,this.dep=new Dep(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=globalVersion-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!setter,this.isSSR=isSSR}notify(){if(this.flags|=16,!(this.flags&8)&&activeSub!==this)return batch(this,!0),!0}get value(){const link=this.dep.track();return refreshComputed(this),link&&(link.version=this.dep.version),this._value}set value(newValue){this.setter&&this.setter(newValue)}};__name(_ComputedRefImpl,"ComputedRefImpl");let ComputedRefImpl=_ComputedRefImpl;function computed$1(getterOrOptions,debugOptions,isSSR=!1){let getter,setter;return isFunction(getterOrOptions)?getter=getterOrOptions:(getter=getterOrOptions.get,setter=getterOrOptions.set),new ComputedRefImpl(getter,setter,isSSR)}__name(computed$1,"computed$1");const TrackOpTypes={GET:"get",HAS:"has",ITERATE:"iterate"},TriggerOpTypes={SET:"set",ADD:"add",DELETE:"delete",CLEAR:"clear"},INITIAL_WATCHER_VALUE={},cleanupMap=new WeakMap;let activeWatcher;function getCurrentWatcher(){return activeWatcher}__name(getCurrentWatcher,"getCurrentWatcher");function onWatcherCleanup(cleanupFn,failSilently=!1,owner=activeWatcher){if(owner){let cleanups=cleanupMap.get(owner);cleanups||cleanupMap.set(owner,cleanups=[]),cleanups.push(cleanupFn)}}__name(onWatcherCleanup,"onWatcherCleanup");function watch$1(source,cb,options=EMPTY_OBJ){const{immediate,deep,once,scheduler,augmentJob,call}=options,reactiveGetter=__name(source2=>deep?source2:isShallow(source2)||deep===!1||deep===0?traverse(source2,1):traverse(source2),"reactiveGetter");let effect2,getter,cleanup,boundCleanup,forceTrigger=!1,isMultiSource=!1;if(isRef(source)?(getter=__name(()=>source.value,"getter"),forceTrigger=isShallow(source)):isReactive(source)?(getter=__name(()=>reactiveGetter(source),"getter"),forceTrigger=!0):isArray$1(source)?(isMultiSource=!0,forceTrigger=source.some(s=>isReactive(s)||isShallow(s)),getter=__name(()=>source.map(s=>{if(isRef(s))return s.value;if(isReactive(s))return reactiveGetter(s);if(isFunction(s))return call?call(s,2):s()}),"getter")):isFunction(source)?cb?getter=call?()=>call(source,2):source:getter=__name(()=>{if(cleanup){pauseTracking();try{cleanup()}finally{resetTracking()}}const currentEffect=activeWatcher;activeWatcher=effect2;try{return call?call(source,3,[boundCleanup]):source(boundCleanup)}finally{activeWatcher=currentEffect}},"getter"):getter=NOOP,cb&&deep){const baseGetter=getter,depth=deep===!0?1/0:deep;getter=__name(()=>traverse(baseGetter(),depth),"getter")}const scope=getCurrentScope(),watchHandle=__name(()=>{effect2.stop(),scope&&scope.active&&remove(scope.effects,effect2)},"watchHandle");if(once&&cb){const _cb=cb;cb=__name((...args)=>{_cb(...args),watchHandle()},"cb")}let oldValue=isMultiSource?new Array(source.length).fill(INITIAL_WATCHER_VALUE):INITIAL_WATCHER_VALUE;const job=__name(immediateFirstRun=>{if(!(!(effect2.flags&1)||!effect2.dirty&&!immediateFirstRun))if(cb){const newValue=effect2.run();if(deep||forceTrigger||(isMultiSource?newValue.some((v,i)=>hasChanged(v,oldValue[i])):hasChanged(newValue,oldValue))){cleanup&&cleanup();const currentWatcher=activeWatcher;activeWatcher=effect2;try{const args=[newValue,oldValue===INITIAL_WATCHER_VALUE?void 0:isMultiSource&&oldValue[0]===INITIAL_WATCHER_VALUE?[]:oldValue,boundCleanup];oldValue=newValue,call?call(cb,3,args):cb(...args)}finally{activeWatcher=currentWatcher}}}else effect2.run()},"job");return augmentJob&&augmentJob(job),effect2=new ReactiveEffect(getter),effect2.scheduler=scheduler?()=>scheduler(job,!1):job,boundCleanup=__name(fn=>onWatcherCleanup(fn,!1,effect2),"boundCleanup"),cleanup=effect2.onStop=()=>{const cleanups=cleanupMap.get(effect2);if(cleanups){if(call)call(cleanups,4);else for(const cleanup2 of cleanups)cleanup2();cleanupMap.delete(effect2)}},cb?immediate?job(!0):oldValue=effect2.run():scheduler?scheduler(job.bind(null,!0),!0):effect2.run(),watchHandle.pause=effect2.pause.bind(effect2),watchHandle.resume=effect2.resume.bind(effect2),watchHandle.stop=watchHandle,watchHandle}__name(watch$1,"watch$1");function traverse(value,depth=1/0,seen){if(depth<=0||!isObject(value)||value.__v_skip||(seen=seen||new Set,seen.has(value)))return value;if(seen.add(value),depth--,isRef(value))traverse(value.value,depth,seen);else if(isArray$1(value))for(let i=0;i<value.length;i++)traverse(value[i],depth,seen);else if(isSet(value)||isMap(value))value.forEach(v=>{traverse(v,depth,seen)});else if(isPlainObject$1(value)){for(const key in value)traverse(value[key],depth,seen);for(const key of Object.getOwnPropertySymbols(value))Object.prototype.propertyIsEnumerable.call(value,key)&&traverse(value[key],depth,seen)}return value}__name(traverse,"traverse");/**
* @vue/runtime-core v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const stack=[];function pushWarningContext(vnode){stack.push(vnode)}__name(pushWarningContext,"pushWarningContext");function popWarningContext(){stack.pop()}__name(popWarningContext,"popWarningContext");function assertNumber(val,type){}__name(assertNumber,"assertNumber");const ErrorCodes={SETUP_FUNCTION:0,0:"SETUP_FUNCTION",RENDER_FUNCTION:1,1:"RENDER_FUNCTION",NATIVE_EVENT_HANDLER:5,5:"NATIVE_EVENT_HANDLER",COMPONENT_EVENT_HANDLER:6,6:"COMPONENT_EVENT_HANDLER",VNODE_HOOK:7,7:"VNODE_HOOK",DIRECTIVE_HOOK:8,8:"DIRECTIVE_HOOK",TRANSITION_HOOK:9,9:"TRANSITION_HOOK",APP_ERROR_HANDLER:10,10:"APP_ERROR_HANDLER",APP_WARN_HANDLER:11,11:"APP_WARN_HANDLER",FUNCTION_REF:12,12:"FUNCTION_REF",ASYNC_COMPONENT_LOADER:13,13:"ASYNC_COMPONENT_LOADER",SCHEDULER:14,14:"SCHEDULER",COMPONENT_UPDATE:15,15:"COMPONENT_UPDATE",APP_UNMOUNT_CLEANUP:16,16:"APP_UNMOUNT_CLEANUP"},ErrorTypeStrings$1={sp:"serverPrefetch hook",bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush",15:"component update",16:"app unmount cleanup function"};function callWithErrorHandling(fn,instance,type,args){try{return args?fn(...args):fn()}catch(err){handleError(err,instance,type)}}__name(callWithErrorHandling,"callWithErrorHandling");function callWithAsyncErrorHandling(fn,instance,type,args){if(isFunction(fn)){const res=callWithErrorHandling(fn,instance,type,args);return res&&isPromise(res)&&res.catch(err=>{handleError(err,instance,type)}),res}if(isArray$1(fn)){const values=[];for(let i=0;i<fn.length;i++)values.push(callWithAsyncErrorHandling(fn[i],instance,type,args));return values}}__name(callWithAsyncErrorHandling,"callWithAsyncErrorHandling");function handleError(err,instance,type,throwInDev=!0){const contextVNode=instance?instance.vnode:null,{errorHandler,throwUnhandledErrorInProduction}=instance&&instance.appContext.config||EMPTY_OBJ;if(instance){let cur=instance.parent;const exposedInstance=instance.proxy,errorInfo=`https://vuejs.org/error-reference/#runtime-${type}`;for(;cur;){const errorCapturedHooks=cur.ec;if(errorCapturedHooks){for(let i=0;i<errorCapturedHooks.length;i++)if(errorCapturedHooks[i](err,exposedInstance,errorInfo)===!1)return}cur=cur.parent}if(errorHandler){pauseTracking(),callWithErrorHandling(errorHandler,null,10,[err,exposedInstance,errorInfo]),resetTracking();return}}logError(err,type,contextVNode,throwInDev,throwUnhandledErrorInProduction)}__name(handleError,"handleError");function logError(err,type,contextVNode,throwInDev=!0,throwInProd=!1){if(throwInProd)throw err;console.error(err)}__name(logError,"logError");const queue=[];let flushIndex=-1;const pendingPostFlushCbs=[];let activePostFlushCbs=null,postFlushIndex=0;const resolvedPromise=Promise.resolve();let currentFlushPromise=null;function nextTick(fn){const p2=currentFlushPromise||resolvedPromise;return fn?p2.then(this?fn.bind(this):fn):p2}__name(nextTick,"nextTick");function findInsertionIndex$1(id){let start=flushIndex+1,end=queue.length;for(;start<end;){const middle=start+end>>>1,middleJob=queue[middle],middleJobId=getId(middleJob);middleJobId<id||middleJobId===id&&middleJob.flags&2?start=middle+1:end=middle}return start}__name(findInsertionIndex$1,"findInsertionIndex$1");function queueJob(job){if(!(job.flags&1)){const jobId=getId(job),lastJob=queue[queue.length-1];!lastJob||!(job.flags&2)&&jobId>=getId(lastJob)?queue.push(job):queue.splice(findInsertionIndex$1(jobId),0,job),job.flags|=1,queueFlush()}}__name(queueJob,"queueJob");function queueFlush(){currentFlushPromise||(currentFlushPromise=resolvedPromise.then(flushJobs))}__name(queueFlush,"queueFlush");function queuePostFlushCb(cb){isArray$1(cb)?pendingPostFlushCbs.push(...cb):activePostFlushCbs&&cb.id===-1?activePostFlushCbs.splice(postFlushIndex+1,0,cb):cb.flags&1||(pendingPostFlushCbs.push(cb),cb.flags|=1),queueFlush()}__name(queuePostFlushCb,"queuePostFlushCb");function flushPreFlushCbs(instance,seen,i=flushIndex+1){for(;i<queue.length;i++){const cb=queue[i];if(cb&&cb.flags&2){if(instance&&cb.id!==instance.uid)continue;queue.splice(i,1),i--,cb.flags&4&&(cb.flags&=-2),cb(),cb.flags&4||(cb.flags&=-2)}}}__name(flushPreFlushCbs,"flushPreFlushCbs");function flushPostFlushCbs(seen){if(pendingPostFlushCbs.length){const deduped=[...new Set(pendingPostFlushCbs)].sort((a,b)=>getId(a)-getId(b));if(pendingPostFlushCbs.length=0,activePostFlushCbs){activePostFlushCbs.push(...deduped);return}for(activePostFlushCbs=deduped,postFlushIndex=0;postFlushIndex<activePostFlushCbs.length;postFlushIndex++){const cb=activePostFlushCbs[postFlushIndex];cb.flags&4&&(cb.flags&=-2),cb.flags&8||cb(),cb.flags&=-2}activePostFlushCbs=null,postFlushIndex=0}}__name(flushPostFlushCbs,"flushPostFlushCbs");const getId=__name(job=>job.id==null?job.flags&2?-1:1/0:job.id,"getId");function flushJobs(seen){try{for(flushIndex=0;flushIndex<queue.length;flushIndex++){const job=queue[flushIndex];job&&!(job.flags&8)&&(job.flags&4&&(job.flags&=-2),callWithErrorHandling(job,job.i,job.i?15:14),job.flags&4||(job.flags&=-2))}}finally{for(;flushIndex<queue.length;flushIndex++){const job=queue[flushIndex];job&&(job.flags&=-2)}flushIndex=-1,queue.length=0,flushPostFlushCbs(),currentFlushPromise=null,(queue.length||pendingPostFlushCbs.length)&&flushJobs()}}__name(flushJobs,"flushJobs");let devtools$1,buffer=[];function setDevtoolsHook$1(hook,target){var _a,_b;devtools$1=hook,devtools$1?(devtools$1.enabled=!0,buffer.forEach(({event,args})=>devtools$1.emit(event,...args)),buffer=[]):typeof window<"u"&&window.HTMLElement&&!((_b=(_a=window.navigator)==null?void 0:_a.userAgent)!=null&&_b.includes("jsdom"))?((target.__VUE_DEVTOOLS_HOOK_REPLAY__=target.__VUE_DEVTOOLS_HOOK_REPLAY__||[]).push(newHook=>{setDevtoolsHook$1(newHook,target)}),setTimeout(()=>{devtools$1||(target.__VUE_DEVTOOLS_HOOK_REPLAY__=null,buffer=[])},3e3)):buffer=[]}__name(setDevtoolsHook$1,"setDevtoolsHook$1");let currentRenderingInstance=null,currentScopeId=null;function setCurrentRenderingInstance(instance){const prev=currentRenderingInstance;return currentRenderingInstance=instance,currentScopeId=instance&&instance.type.__scopeId||null,prev}__name(setCurrentRenderingInstance,"setCurrentRenderingInstance");function pushScopeId(id){currentScopeId=id}__name(pushScopeId,"pushScopeId");function popScopeId(){currentScopeId=null}__name(popScopeId,"popScopeId");const withScopeId=__name(_id=>withCtx,"withScopeId");function withCtx(fn,ctx=currentRenderingInstance,isNonScopedSlot){if(!ctx||fn._n)return fn;const renderFnWithContext=__name((...args)=>{renderFnWithContext._d&&setBlockTracking(-1);const prevInstance=setCurrentRenderingInstance(ctx);let res;try{res=fn(...args)}finally{setCurrentRenderingInstance(prevInstance),renderFnWithContext._d&&setBlockTracking(1)}return res},"renderFnWithContext");return renderFnWithContext._n=!0,renderFnWithContext._c=!0,renderFnWithContext._d=!0,renderFnWithContext}__name(withCtx,"withCtx");function withDirectives(vnode,directives){if(currentRenderingInstance===null)return vnode;const instance=getComponentPublicInstance(currentRenderingInstance),bindings=vnode.dirs||(vnode.dirs=[]);for(let i=0;i<directives.length;i++){let[dir,value,arg,modifiers=EMPTY_OBJ]=directives[i];dir&&(isFunction(dir)&&(dir={mounted:dir,updated:dir}),dir.deep&&traverse(value),bindings.push({dir,instance,value,oldValue:void 0,arg,modifiers}))}return vnode}__name(withDirectives,"withDirectives");function invokeDirectiveHook(vnode,prevVNode,instance,name){const bindings=vnode.dirs,oldBindings=prevVNode&&prevVNode.dirs;for(let i=0;i<bindings.length;i++){const binding=bindings[i];oldBindings&&(binding.oldValue=oldBindings[i].value);let hook=binding.dir[name];hook&&(pauseTracking(),callWithAsyncErrorHandling(hook,instance,8,[vnode.el,binding,vnode,prevVNode]),resetTracking())}}__name(invokeDirectiveHook,"invokeDirectiveHook");const TeleportEndKey=Symbol("_vte"),isTeleport=__name(type=>type.__isTeleport,"isTeleport"),isTeleportDisabled=__name(props=>props&&(props.disabled||props.disabled===""),"isTeleportDisabled"),isTeleportDeferred=__name(props=>props&&(props.defer||props.defer===""),"isTeleportDeferred"),isTargetSVG=__name(target=>typeof SVGElement<"u"&&target instanceof SVGElement,"isTargetSVG"),isTargetMathML=__name(target=>typeof MathMLElement=="function"&&target instanceof MathMLElement,"isTargetMathML"),resolveTarget=__name((props,select)=>{const targetSelector=props&&props.to;return isString(targetSelector)?select?select(targetSelector):null:targetSelector},"resolveTarget"),TeleportImpl={name:"Teleport",__isTeleport:!0,process(n1,n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized,internals){const{mc:mountChildren,pc:patchChildren,pbc:patchBlockChildren,o:{insert,querySelector,createText,createComment}}=internals,disabled=isTeleportDisabled(n2.props);let{shapeFlag,children,dynamicChildren}=n2;if(n1==null){const placeholder=n2.el=createText(""),mainAnchor=n2.anchor=createText("");insert(placeholder,container,anchor),insert(mainAnchor,container,anchor);const mount=__name((container2,anchor2)=>{shapeFlag&16&&(parentComponent&&parentComponent.isCE&&(parentComponent.ce._teleportTarget=container2),mountChildren(children,container2,anchor2,parentComponent,parentSuspense,namespace,slotScopeIds,optimized))},"mount"),mountToTarget=__name(()=>{const target=n2.target=resolveTarget(n2.props,querySelector),targetAnchor=prepareAnchor(target,n2,createText,insert);target&&(namespace!=="svg"&&isTargetSVG(target)?namespace="svg":namespace!=="mathml"&&isTargetMathML(target)&&(namespace="mathml"),disabled||(mount(target,targetAnchor),updateCssVars(n2,!1)))},"mountToTarget");disabled&&(mount(container,mainAnchor),updateCssVars(n2,!0)),isTeleportDeferred(n2.props)?(n2.el.__isMounted=!1,queuePostRenderEffect(()=>{mountToTarget(),delete n2.el.__isMounted},parentSuspense)):mountToTarget()}else{if(isTeleportDeferred(n2.props)&&n1.el.__isMounted===!1){queuePostRenderEffect(()=>{TeleportImpl.process(n1,n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized,internals)},parentSuspense);return}n2.el=n1.el,n2.targetStart=n1.targetStart;const mainAnchor=n2.anchor=n1.anchor,target=n2.target=n1.target,targetAnchor=n2.targetAnchor=n1.targetAnchor,wasDisabled=isTeleportDisabled(n1.props),currentContainer=wasDisabled?container:target,currentAnchor=wasDisabled?mainAnchor:targetAnchor;if(namespace==="svg"||isTargetSVG(target)?namespace="svg":(namespace==="mathml"||isTargetMathML(target))&&(namespace="mathml"),dynamicChildren?(patchBlockChildren(n1.dynamicChildren,dynamicChildren,currentContainer,parentComponent,parentSuspense,namespace,slotScopeIds),traverseStaticChildren(n1,n2,!0)):optimized||patchChildren(n1,n2,currentContainer,currentAnchor,parentComponent,parentSuspense,namespace,slotScopeIds,!1),disabled)wasDisabled?n2.props&&n1.props&&n2.props.to!==n1.props.to&&(n2.props.to=n1.props.to):moveTeleport(n2,container,mainAnchor,internals,1);else if((n2.props&&n2.props.to)!==(n1.props&&n1.props.to)){const nextTarget=n2.target=resolveTarget(n2.props,querySelector);nextTarget&&moveTeleport(n2,nextTarget,null,internals,0)}else wasDisabled&&moveTeleport(n2,target,targetAnchor,internals,1);updateCssVars(n2,disabled)}},remove(vnode,parentComponent,parentSuspense,{um:unmount,o:{remove:hostRemove}},doRemove){const{shapeFlag,children,anchor,targetStart,targetAnchor,target,props}=vnode;if(target&&(hostRemove(targetStart),hostRemove(targetAnchor)),doRemove&&hostRemove(anchor),shapeFlag&16){const shouldRemove=doRemove||!isTeleportDisabled(props);for(let i=0;i<children.length;i++){const child=children[i];unmount(child,parentComponent,parentSuspense,shouldRemove,!!child.dynamicChildren)}}},move:moveTeleport,hydrate:hydrateTeleport};function moveTeleport(vnode,container,parentAnchor,{o:{insert},m:move},moveType=2){moveType===0&&insert(vnode.targetAnchor,container,parentAnchor);const{el,anchor,shapeFlag,children,props}=vnode,isReorder=moveType===2;if(isReorder&&insert(el,container,parentAnchor),(!isReorder||isTeleportDisabled(props))&&shapeFlag&16)for(let i=0;i<children.length;i++)move(children[i],container,parentAnchor,2);isReorder&&insert(anchor,container,parentAnchor)}__name(moveTeleport,"moveTeleport");function hydrateTeleport(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized,{o:{nextSibling,parentNode,querySelector,insert,createText}},hydrateChildren){const target=vnode.target=resolveTarget(vnode.props,querySelector);if(target){const disabled=isTeleportDisabled(vnode.props),targetNode=target._lpa||target.firstChild;if(vnode.shapeFlag&16)if(disabled)vnode.anchor=hydrateChildren(nextSibling(node),vnode,parentNode(node),parentComponent,parentSuspense,slotScopeIds,optimized),vnode.targetStart=targetNode,vnode.targetAnchor=targetNode&&nextSibling(targetNode);else{vnode.anchor=nextSibling(node);let targetAnchor=targetNode;for(;targetAnchor;){if(targetAnchor&&targetAnchor.nodeType===8){if(targetAnchor.data==="teleport start anchor")vnode.targetStart=targetAnchor;else if(targetAnchor.data==="teleport anchor"){vnode.targetAnchor=targetAnchor,target._lpa=vnode.targetAnchor&&nextSibling(vnode.targetAnchor);break}}targetAnchor=nextSibling(targetAnchor)}vnode.targetAnchor||prepareAnchor(target,vnode,createText,insert),hydrateChildren(targetNode&&nextSibling(targetNode),vnode,target,parentComponent,parentSuspense,slotScopeIds,optimized)}updateCssVars(vnode,disabled)}return vnode.anchor&&nextSibling(vnode.anchor)}__name(hydrateTeleport,"hydrateTeleport");const Teleport=TeleportImpl;function updateCssVars(vnode,isDisabled){const ctx=vnode.ctx;if(ctx&&ctx.ut){let node,anchor;for(isDisabled?(node=vnode.el,anchor=vnode.anchor):(node=vnode.targetStart,anchor=vnode.targetAnchor);node&&node!==anchor;)node.nodeType===1&&node.setAttribute("data-v-owner",ctx.uid),node=node.nextSibling;ctx.ut()}}__name(updateCssVars,"updateCssVars");function prepareAnchor(target,vnode,createText,insert){const targetStart=vnode.targetStart=createText(""),targetAnchor=vnode.targetAnchor=createText("");return targetStart[TeleportEndKey]=targetAnchor,target&&(insert(targetStart,target),insert(targetAnchor,target)),targetAnchor}__name(prepareAnchor,"prepareAnchor");const leaveCbKey=Symbol("_leaveCb"),enterCbKey$1=Symbol("_enterCb");function useTransitionState(){const state={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return onMounted(()=>{state.isMounted=!0}),onBeforeUnmount(()=>{state.isUnmounting=!0}),state}__name(useTransitionState,"useTransitionState");const TransitionHookValidator=[Function,Array],BaseTransitionPropsValidators={mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:TransitionHookValidator,onEnter:TransitionHookValidator,onAfterEnter:TransitionHookValidator,onEnterCancelled:TransitionHookValidator,onBeforeLeave:TransitionHookValidator,onLeave:TransitionHookValidator,onAfterLeave:TransitionHookValidator,onLeaveCancelled:TransitionHookValidator,onBeforeAppear:TransitionHookValidator,onAppear:TransitionHookValidator,onAfterAppear:TransitionHookValidator,onAppearCancelled:TransitionHookValidator},recursiveGetSubtree=__name(instance=>{const subTree=instance.subTree;return subTree.component?recursiveGetSubtree(subTree.component):subTree},"recursiveGetSubtree"),BaseTransitionImpl={name:"BaseTransition",props:BaseTransitionPropsValidators,setup(props,{slots}){const instance=getCurrentInstance(),state=useTransitionState();return()=>{const children=slots.default&&getTransitionRawChildren(slots.default(),!0);if(!children||!children.length)return;const child=findNonCommentChild(children),rawProps=toRaw(props),{mode}=rawProps;if(state.isLeaving)return emptyPlaceholder(child);const innerChild=getInnerChild$1(child);if(!innerChild)return emptyPlaceholder(child);let enterHooks=resolveTransitionHooks(innerChild,rawProps,state,instance,hooks=>enterHooks=hooks);innerChild.type!==Comment&&setTransitionHooks(innerChild,enterHooks);let oldInnerChild=instance.subTree&&getInnerChild$1(instance.subTree);if(oldInnerChild&&oldInnerChild.type!==Comment&&!isSameVNodeType(innerChild,oldInnerChild)&&recursiveGetSubtree(instance).type!==Comment){let leavingHooks=resolveTransitionHooks(oldInnerChild,rawProps,state,instance);if(setTransitionHooks(oldInnerChild,leavingHooks),mode==="out-in"&&innerChild.type!==Comment)return state.isLeaving=!0,leavingHooks.afterLeave=()=>{state.isLeaving=!1,instance.job.flags&8||instance.update(),delete leavingHooks.afterLeave,oldInnerChild=void 0},emptyPlaceholder(child);mode==="in-out"&&innerChild.type!==Comment?leavingHooks.delayLeave=(el,earlyRemove,delayedLeave)=>{const leavingVNodesCache=getLeavingNodesForType(state,oldInnerChild);leavingVNodesCache[String(oldInnerChild.key)]=oldInnerChild,el[leaveCbKey]=()=>{earlyRemove(),el[leaveCbKey]=void 0,delete enterHooks.delayedLeave,oldInnerChild=void 0},enterHooks.delayedLeave=()=>{delayedLeave(),delete enterHooks.delayedLeave,oldInnerChild=void 0}}:oldInnerChild=void 0}else oldInnerChild&&(oldInnerChild=void 0);return child}}};function findNonCommentChild(children){let child=children[0];if(children.length>1){for(const c of children)if(c.type!==Comment){child=c;break}}return child}__name(findNonCommentChild,"findNonCommentChild");const BaseTransition=BaseTransitionImpl;function getLeavingNodesForType(state,vnode){const{leavingVNodes}=state;let leavingVNodesCache=leavingVNodes.get(vnode.type);return leavingVNodesCache||(leavingVNodesCache=Object.create(null),leavingVNodes.set(vnode.type,leavingVNodesCache)),leavingVNodesCache}__name(getLeavingNodesForType,"getLeavingNodesForType");function resolveTransitionHooks(vnode,props,state,instance,postClone){const{appear,mode,persisted=!1,onBeforeEnter,onEnter,onAfterEnter,onEnterCancelled,onBeforeLeave,onLeave,onAfterLeave,onLeaveCancelled,onBeforeAppear,onAppear,onAfterAppear,onAppearCancelled}=props,key=String(vnode.key),leavingVNodesCache=getLeavingNodesForType(state,vnode),callHook2=__name((hook,args)=>{hook&&callWithAsyncErrorHandling(hook,instance,9,args)},"callHook2"),callAsyncHook=__name((hook,args)=>{const done=args[1];callHook2(hook,args),isArray$1(hook)?hook.every(hook2=>hook2.length<=1)&&done():hook.length<=1&&done()},"callAsyncHook"),hooks={mode,persisted,beforeEnter(el){let hook=onBeforeEnter;if(!state.isMounted)if(appear)hook=onBeforeAppear||onBeforeEnter;else return;el[leaveCbKey]&&el[leaveCbKey](!0);const leavingVNode=leavingVNodesCache[key];leavingVNode&&isSameVNodeType(vnode,leavingVNode)&&leavingVNode.el[leaveCbKey]&&leavingVNode.el[leaveCbKey](),callHook2(hook,[el])},enter(el){let hook=onEnter,afterHook=onAfterEnter,cancelHook=onEnterCancelled;if(!state.isMounted)if(appear)hook=onAppear||onEnter,afterHook=onAfterAppear||onAfterEnter,cancelHook=onAppearCancelled||onEnterCancelled;else return;let called=!1;const done=el[enterCbKey$1]=cancelled=>{called||(called=!0,cancelled?callHook2(cancelHook,[el]):callHook2(afterHook,[el]),hooks.delayedLeave&&hooks.delayedLeave(),el[enterCbKey$1]=void 0)};hook?callAsyncHook(hook,[el,done]):done()},leave(el,remove2){const key2=String(vnode.key);if(el[enterCbKey$1]&&el[enterCbKey$1](!0),state.isUnmounting)return remove2();callHook2(onBeforeLeave,[el]);let called=!1;const done=el[leaveCbKey]=cancelled=>{called||(called=!0,remove2(),cancelled?callHook2(onLeaveCancelled,[el]):callHook2(onAfterLeave,[el]),el[leaveCbKey]=void 0,leavingVNodesCache[key2]===vnode&&delete leavingVNodesCache[key2])};leavingVNodesCache[key2]=vnode,onLeave?callAsyncHook(onLeave,[el,done]):done()},clone(vnode2){const hooks2=resolveTransitionHooks(vnode2,props,state,instance,postClone);return postClone&&postClone(hooks2),hooks2}};return hooks}__name(resolveTransitionHooks,"resolveTransitionHooks");function emptyPlaceholder(vnode){if(isKeepAlive(vnode))return vnode=cloneVNode(vnode),vnode.children=null,vnode}__name(emptyPlaceholder,"emptyPlaceholder");function getInnerChild$1(vnode){if(!isKeepAlive(vnode))return isTeleport(vnode.type)&&vnode.children?findNonCommentChild(vnode.children):vnode;if(vnode.component)return vnode.component.subTree;const{shapeFlag,children}=vnode;if(children){if(shapeFlag&16)return children[0];if(shapeFlag&32&&isFunction(children.default))return children.default()}}__name(getInnerChild$1,"getInnerChild$1");function setTransitionHooks(vnode,hooks){vnode.shapeFlag&6&&vnode.component?(vnode.transition=hooks,setTransitionHooks(vnode.component.subTree,hooks)):vnode.shapeFlag&128?(vnode.ssContent.transition=hooks.clone(vnode.ssContent),vnode.ssFallback.transition=hooks.clone(vnode.ssFallback)):vnode.transition=hooks}__name(setTransitionHooks,"setTransitionHooks");function getTransitionRawChildren(children,keepComment=!1,parentKey){let ret=[],keyedFragmentCount=0;for(let i=0;i<children.length;i++){let child=children[i];const key=parentKey==null?child.key:String(parentKey)+String(child.key!=null?child.key:i);child.type===Fragment?(child.patchFlag&128&&keyedFragmentCount++,ret=ret.concat(getTransitionRawChildren(child.children,keepComment,key))):(keepComment||child.type!==Comment)&&ret.push(key!=null?cloneVNode(child,{key}):child)}if(keyedFragmentCount>1)for(let i=0;i<ret.length;i++)ret[i].patchFlag=-2;return ret}__name(getTransitionRawChildren,"getTransitionRawChildren");/*! #__NO_SIDE_EFFECTS__ */function defineComponent(options,extraOptions){return isFunction(options)?extend({name:options.name},extraOptions,{setup:options}):options}__name(defineComponent,"defineComponent");function useId(){const i=getCurrentInstance();return i?(i.appContext.config.idPrefix||"v")+"-"+i.ids[0]+i.ids[1]++:""}__name(useId,"useId");function markAsyncBoundary(instance){instance.ids=[instance.ids[0]+instance.ids[2]+++"-",0,0]}__name(markAsyncBoundary,"markAsyncBoundary");function useTemplateRef(key){const i=getCurrentInstance(),r=shallowRef(null);if(i){const refs=i.refs===EMPTY_OBJ?i.refs={}:i.refs;Object.defineProperty(refs,key,{enumerable:!0,get:__name(()=>r.value,"get"),set:__name(val=>r.value=val,"set")})}return r}__name(useTemplateRef,"useTemplateRef");function setRef(rawRef,oldRawRef,parentSuspense,vnode,isUnmount=!1){if(isArray$1(rawRef)){rawRef.forEach((r,i)=>setRef(r,oldRawRef&&(isArray$1(oldRawRef)?oldRawRef[i]:oldRawRef),parentSuspense,vnode,isUnmount));return}if(isAsyncWrapper(vnode)&&!isUnmount){vnode.shapeFlag&512&&vnode.type.__asyncResolved&&vnode.component.subTree.component&&setRef(rawRef,oldRawRef,parentSuspense,vnode.component.subTree);return}const refValue=vnode.shapeFlag&4?getComponentPublicInstance(vnode.component):vnode.el,value=isUnmount?null:refValue,{i:owner,r:ref3}=rawRef,oldRef=oldRawRef&&oldRawRef.r,refs=owner.refs===EMPTY_OBJ?owner.refs={}:owner.refs,setupState=owner.setupState,rawSetupState=toRaw(setupState),canSetSetupRef=setupState===EMPTY_OBJ?()=>!1:key=>hasOwn(rawSetupState,key);if(oldRef!=null&&oldRef!==ref3&&(isString(oldRef)?(refs[oldRef]=null,canSetSetupRef(oldRef)&&(setupState[oldRef]=null)):isRef(oldRef)&&(oldRef.value=null)),isFunction(ref3))callWithErrorHandling(ref3,owner,12,[value,refs]);else{const _isString=isString(ref3),_isRef=isRef(ref3);if(_isString||_isRef){const doSet=__name(()=>{if(rawRef.f){const existing=_isString?canSetSetupRef(ref3)?setupState[ref3]:refs[ref3]:ref3.value;isUnmount?isArray$1(existing)&&remove(existing,refValue):isArray$1(existing)?existing.includes(refValue)||existing.push(refValue):_isString?(refs[ref3]=[refValue],canSetSetupRef(ref3)&&(setupState[ref3]=refs[ref3])):(ref3.value=[refValue],rawRef.k&&(refs[rawRef.k]=ref3.value))}else _isString?(refs[ref3]=value,canSetSetupRef(ref3)&&(setupState[ref3]=value)):_isRef&&(ref3.value=value,rawRef.k&&(refs[rawRef.k]=value))},"doSet");value?(doSet.id=-1,queuePostRenderEffect(doSet,parentSuspense)):doSet()}}}__name(setRef,"setRef");let hasLoggedMismatchError=!1;const logMismatchError=__name(()=>{hasLoggedMismatchError||(console.error("Hydration completed but contains mismatches."),hasLoggedMismatchError=!0)},"logMismatchError"),isSVGContainer=__name(container=>container.namespaceURI.includes("svg")&&container.tagName!=="foreignObject","isSVGContainer"),isMathMLContainer=__name(container=>container.namespaceURI.includes("MathML"),"isMathMLContainer"),getContainerType=__name(container=>{if(container.nodeType===1){if(isSVGContainer(container))return"svg";if(isMathMLContainer(container))return"mathml"}},"getContainerType"),isComment=__name(node=>node.nodeType===8,"isComment");function createHydrationFunctions(rendererInternals){const{mt:mountComponent,p:patch,o:{patchProp:patchProp2,createText,nextSibling,parentNode,remove:remove2,insert,createComment}}=rendererInternals,hydrate2=__name((vnode,container)=>{if(!container.hasChildNodes()){patch(null,vnode,container),flushPostFlushCbs(),container._vnode=vnode;return}hydrateNode(container.firstChild,vnode,null,null,null),flushPostFlushCbs(),container._vnode=vnode},"hydrate"),hydrateNode=__name((node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized=!1)=>{optimized=optimized||!!vnode.dynamicChildren;const isFragmentStart=isComment(node)&&node.data==="[",onMismatch=__name(()=>handleMismatch(node,vnode,parentComponent,parentSuspense,slotScopeIds,isFragmentStart),"onMismatch"),{type,ref:ref3,shapeFlag,patchFlag}=vnode;let domType=node.nodeType;vnode.el=node,patchFlag===-2&&(optimized=!1,vnode.dynamicChildren=null);let nextNode=null;switch(type){case Text:domType!==3?vnode.children===""?(insert(vnode.el=createText(""),parentNode(node),node),nextNode=node):nextNode=onMismatch():(node.data!==vnode.children&&(logMismatchError(),node.data=vnode.children),nextNode=nextSibling(node));break;case Comment:isTemplateNode(node)?(nextNode=nextSibling(node),replaceNode(vnode.el=node.content.firstChild,node,parentComponent)):domType!==8||isFragmentStart?nextNode=onMismatch():nextNode=nextSibling(node);break;case Static:if(isFragmentStart&&(node=nextSibling(node),domType=node.nodeType),domType===1||domType===3){nextNode=node;const needToAdoptContent=!vnode.children.length;for(let i=0;i<vnode.staticCount;i++)needToAdoptContent&&(vnode.children+=nextNode.nodeType===1?nextNode.outerHTML:nextNode.data),i===vnode.staticCount-1&&(vnode.anchor=nextNode),nextNode=nextSibling(nextNode);return isFragmentStart?nextSibling(nextNode):nextNode}else onMismatch();break;case Fragment:isFragmentStart?nextNode=hydrateFragment(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized):nextNode=onMismatch();break;default:if(shapeFlag&1)(domType!==1||vnode.type.toLowerCase()!==node.tagName.toLowerCase())&&!isTemplateNode(node)?nextNode=onMismatch():nextNode=hydrateElement(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized);else if(shapeFlag&6){vnode.slotScopeIds=slotScopeIds;const container=parentNode(node);if(isFragmentStart?nextNode=locateClosingAnchor(node):isComment(node)&&node.data==="teleport start"?nextNode=locateClosingAnchor(node,node.data,"teleport end"):nextNode=nextSibling(node),mountComponent(vnode,container,null,parentComponent,parentSuspense,getContainerType(container),optimized),isAsyncWrapper(vnode)&&!vnode.type.__asyncResolved){let subTree;isFragmentStart?(subTree=createVNode(Fragment),subTree.anchor=nextNode?nextNode.previousSibling:container.lastChild):subTree=node.nodeType===3?createTextVNode(""):createVNode("div"),subTree.el=node,vnode.component.subTree=subTree}}else shapeFlag&64?domType!==8?nextNode=onMismatch():nextNode=vnode.type.hydrate(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized,rendererInternals,hydrateChildren):shapeFlag&128&&(nextNode=vnode.type.hydrate(node,vnode,parentComponent,parentSuspense,getContainerType(parentNode(node)),slotScopeIds,optimized,rendererInternals,hydrateNode))}return ref3!=null&&setRef(ref3,null,parentSuspense,vnode),nextNode},"hydrateNode"),hydrateElement=__name((el,vnode,parentComponent,parentSuspense,slotScopeIds,optimized)=>{optimized=optimized||!!vnode.dynamicChildren;const{type,props,patchFlag,shapeFlag,dirs,transition}=vnode,forcePatch=type==="input"||type==="option";if(forcePatch||patchFlag!==-1){dirs&&invokeDirectiveHook(vnode,null,parentComponent,"created");let needCallTransitionHooks=!1;if(isTemplateNode(el)){needCallTransitionHooks=needTransition(null,transition)&&parentComponent&&parentComponent.vnode.props&&parentComponent.vnode.props.appear;const content=el.content.firstChild;if(needCallTransitionHooks){const cls=content.getAttribute("class");cls&&(content.$cls=cls),transition.beforeEnter(content)}replaceNode(content,el,parentComponent),vnode.el=el=content}if(shapeFlag&16&&!(props&&(props.innerHTML||props.textContent))){let next=hydrateChildren(el.firstChild,vnode,el,parentComponent,parentSuspense,slotScopeIds,optimized);for(;next;){isMismatchAllowed(el,1)||logMismatchError();const cur=next;next=next.nextSibling,remove2(cur)}}else if(shapeFlag&8){let clientText=vnode.children;clientText[0]===`
`&&(el.tagName==="PRE"||el.tagName==="TEXTAREA")&&(clientText=clientText.slice(1)),el.textContent!==clientText&&(isMismatchAllowed(el,0)||logMismatchError(),el.textContent=vnode.children)}if(props){if(forcePatch||!optimized||patchFlag&48){const isCustomElement=el.tagName.includes("-");for(const key in props)(forcePatch&&(key.endsWith("value")||key==="indeterminate")||isOn(key)&&!isReservedProp(key)||key[0]==="."||isCustomElement)&&patchProp2(el,key,null,props[key],void 0,parentComponent)}else if(props.onClick)patchProp2(el,"onClick",null,props.onClick,void 0,parentComponent);else if(patchFlag&4&&isReactive(props.style))for(const key in props.style)props.style[key]}let vnodeHooks;(vnodeHooks=props&&props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHooks,parentComponent,vnode),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeMount"),((vnodeHooks=props&&props.onVnodeMounted)||dirs||needCallTransitionHooks)&&queueEffectWithSuspense(()=>{vnodeHooks&&invokeVNodeHook(vnodeHooks,parentComponent,vnode),needCallTransitionHooks&&transition.enter(el),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"mounted")},parentSuspense)}return el.nextSibling},"hydrateElement"),hydrateChildren=__name((node,parentVNode,container,parentComponent,parentSuspense,slotScopeIds,optimized)=>{optimized=optimized||!!parentVNode.dynamicChildren;const children=parentVNode.children,l=children.length;for(let i=0;i<l;i++){const vnode=optimized?children[i]:children[i]=normalizeVNode(children[i]),isText=vnode.type===Text;node?(isText&&!optimized&&i+1<l&&normalizeVNode(children[i+1]).type===Text&&(insert(createText(node.data.slice(vnode.children.length)),container,nextSibling(node)),node.data=vnode.children),node=hydrateNode(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized)):isText&&!vnode.children?insert(vnode.el=createText(""),container):(isMismatchAllowed(container,1)||logMismatchError(),patch(null,vnode,container,null,parentComponent,parentSuspense,getContainerType(container),slotScopeIds))}return node},"hydrateChildren"),hydrateFragment=__name((node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized)=>{const{slotScopeIds:fragmentSlotScopeIds}=vnode;fragmentSlotScopeIds&&(slotScopeIds=slotScopeIds?slotScopeIds.concat(fragmentSlotScopeIds):fragmentSlotScopeIds);const container=parentNode(node),next=hydrateChildren(nextSibling(node),vnode,container,parentComponent,parentSuspense,slotScopeIds,optimized);return next&&isComment(next)&&next.data==="]"?nextSibling(vnode.anchor=next):(logMismatchError(),insert(vnode.anchor=createComment("]"),container,next),next)},"hydrateFragment"),handleMismatch=__name((node,vnode,parentComponent,parentSuspense,slotScopeIds,isFragment)=>{if(isMismatchAllowed(node.parentElement,1)||logMismatchError(),vnode.el=null,isFragment){const end=locateClosingAnchor(node);for(;;){const next2=nextSibling(node);if(next2&&next2!==end)remove2(next2);else break}}const next=nextSibling(node),container=parentNode(node);return remove2(node),patch(null,vnode,container,next,parentComponent,parentSuspense,getContainerType(container),slotScopeIds),parentComponent&&(parentComponent.vnode.el=vnode.el,updateHOCHostEl(parentComponent,vnode.el)),next},"handleMismatch"),locateClosingAnchor=__name((node,open="[",close="]")=>{let match=0;for(;node;)if(node=nextSibling(node),node&&isComment(node)&&(node.data===open&&match++,node.data===close)){if(match===0)return nextSibling(node);match--}return node},"locateClosingAnchor"),replaceNode=__name((newNode,oldNode,parentComponent)=>{const parentNode2=oldNode.parentNode;parentNode2&&parentNode2.replaceChild(newNode,oldNode);let parent=parentComponent;for(;parent;)parent.vnode.el===oldNode&&(parent.vnode.el=parent.subTree.el=newNode),parent=parent.parent},"replaceNode"),isTemplateNode=__name(node=>node.nodeType===1&&node.tagName==="TEMPLATE","isTemplateNode");return[hydrate2,hydrateNode]}__name(createHydrationFunctions,"createHydrationFunctions");const allowMismatchAttr="data-allow-mismatch",MismatchTypeString={0:"text",1:"children",2:"class",3:"style",4:"attribute"};function isMismatchAllowed(el,allowedType){if(allowedType===0||allowedType===1)for(;el&&!el.hasAttribute(allowMismatchAttr);)el=el.parentElement;const allowedAttr=el&&el.getAttribute(allowMismatchAttr);if(allowedAttr==null)return!1;if(allowedAttr==="")return!0;{const list=allowedAttr.split(",");return allowedType===0&&list.includes("children")?!0:list.includes(MismatchTypeString[allowedType])}}__name(isMismatchAllowed,"isMismatchAllowed");const requestIdleCallback=getGlobalThis().requestIdleCallback||(cb=>setTimeout(cb,1)),cancelIdleCallback=getGlobalThis().cancelIdleCallback||(id=>clearTimeout(id)),hydrateOnIdle=__name((timeout=1e4)=>hydrate2=>{const id=requestIdleCallback(hydrate2,{timeout});return()=>cancelIdleCallback(id)},"hydrateOnIdle");function elementIsVisibleInViewport(el){const{top,left,bottom,right}=el.getBoundingClientRect(),{innerHeight,innerWidth}=window;return(top>0&&top<innerHeight||bottom>0&&bottom<innerHeight)&&(left>0&&left<innerWidth||right>0&&right<innerWidth)}__name(elementIsVisibleInViewport,"elementIsVisibleInViewport");const hydrateOnVisible=__name(opts=>(hydrate2,forEach)=>{const ob=new IntersectionObserver(entries=>{for(const e of entries)if(e.isIntersecting){ob.disconnect(),hydrate2();break}},opts);return forEach(el=>{if(el instanceof Element){if(elementIsVisibleInViewport(el))return hydrate2(),ob.disconnect(),!1;ob.observe(el)}}),()=>ob.disconnect()},"hydrateOnVisible"),hydrateOnMediaQuery=__name(query=>hydrate2=>{if(query){const mql=matchMedia(query);if(mql.matches)hydrate2();else return mql.addEventListener("change",hydrate2,{once:!0}),()=>mql.removeEventListener("change",hydrate2)}},"hydrateOnMediaQuery"),hydrateOnInteraction=__name((interactions=[])=>(hydrate2,forEach)=>{isString(interactions)&&(interactions=[interactions]);let hasHydrated=!1;const doHydrate=__name(e=>{hasHydrated||(hasHydrated=!0,teardown(),hydrate2(),e.target.dispatchEvent(new e.constructor(e.type,e)))},"doHydrate"),teardown=__name(()=>{forEach(el=>{for(const i of interactions)el.removeEventListener(i,doHydrate)})},"teardown");return forEach(el=>{for(const i of interactions)el.addEventListener(i,doHydrate,{once:!0})}),teardown},"hydrateOnInteraction");function forEachElement(node,cb){if(isComment(node)&&node.data==="["){let depth=1,next=node.nextSibling;for(;next;){if(next.nodeType===1){if(cb(next)===!1)break}else if(isComment(next))if(next.data==="]"){if(--depth===0)break}else next.data==="["&&depth++;next=next.nextSibling}}else cb(node)}__name(forEachElement,"forEachElement");const isAsyncWrapper=__name(i=>!!i.type.__asyncLoader,"isAsyncWrapper");/*! #__NO_SIDE_EFFECTS__ */function defineAsyncComponent(source){isFunction(source)&&(source={loader:source});const{loader,loadingComponent,errorComponent,delay=200,hydrate:hydrateStrategy,timeout,suspensible=!0,onError:userOnError}=source;let pendingRequest=null,resolvedComp,retries=0;const retry=__name(()=>(retries++,pendingRequest=null,load()),"retry"),load=__name(()=>{let thisRequest;return pendingRequest||(thisRequest=pendingRequest=loader().catch(err=>{if(err=err instanceof Error?err:new Error(String(err)),userOnError)return new Promise((resolve2,reject)=>{userOnError(err,__name(()=>resolve2(retry()),"userRetry"),__name(()=>reject(err),"userFail"),retries+1)});throw err}).then(comp=>thisRequest!==pendingRequest&&pendingRequest?pendingRequest:(comp&&(comp.__esModule||comp[Symbol.toStringTag]==="Module")&&(comp=comp.default),resolvedComp=comp,comp)))},"load");return defineComponent({name:"AsyncComponentWrapper",__asyncLoader:load,__asyncHydrate(el,instance,hydrate2){let patched=!1;(instance.bu||(instance.bu=[])).push(()=>patched=!0);const performHydrate=__name(()=>{patched||hydrate2()},"performHydrate"),doHydrate=hydrateStrategy?()=>{const teardown=hydrateStrategy(performHydrate,cb=>forEachElement(el,cb));teardown&&(instance.bum||(instance.bum=[])).push(teardown)}:performHydrate;resolvedComp?doHydrate():load().then(()=>!instance.isUnmounted&&doHydrate())},get __asyncResolved(){return resolvedComp},setup(){const instance=currentInstance;if(markAsyncBoundary(instance),resolvedComp)return()=>createInnerComp(resolvedComp,instance);const onError=__name(err=>{pendingRequest=null,handleError(err,instance,13,!errorComponent)},"onError");if(suspensible&&instance.suspense||isInSSRComponentSetup)return load().then(comp=>()=>createInnerComp(comp,instance)).catch(err=>(onError(err),()=>errorComponent?createVNode(errorComponent,{error:err}):null));const loaded=ref(!1),error=ref(),delayed=ref(!!delay);return delay&&setTimeout(()=>{delayed.value=!1},delay),timeout!=null&&setTimeout(()=>{if(!loaded.value&&!error.value){const err=new Error(`Async component timed out after ${timeout}ms.`);onError(err),error.value=err}},timeout),load().then(()=>{loaded.value=!0,instance.parent&&isKeepAlive(instance.parent.vnode)&&instance.parent.update()}).catch(err=>{onError(err),error.value=err}),()=>{if(loaded.value&&resolvedComp)return createInnerComp(resolvedComp,instance);if(error.value&&errorComponent)return createVNode(errorComponent,{error:error.value});if(loadingComponent&&!delayed.value)return createVNode(loadingComponent)}}})}__name(defineAsyncComponent,"defineAsyncComponent");function createInnerComp(comp,parent){const{ref:ref22,props,children,ce}=parent.vnode,vnode=createVNode(comp,props,children);return vnode.ref=ref22,vnode.ce=ce,delete parent.vnode.ce,vnode}__name(createInnerComp,"createInnerComp");const isKeepAlive=__name(vnode=>vnode.type.__isKeepAlive,"isKeepAlive"),KeepAliveImpl={name:"KeepAlive",__isKeepAlive:!0,props:{include:[String,RegExp,Array],exclude:[String,RegExp,Array],max:[String,Number]},setup(props,{slots}){const instance=getCurrentInstance(),sharedContext=instance.ctx;if(!sharedContext.renderer)return()=>{const children=slots.default&&slots.default();return children&&children.length===1?children[0]:children};const cache=new Map,keys=new Set;let current=null;const parentSuspense=instance.suspense,{renderer:{p:patch,m:move,um:_unmount,o:{createElement}}}=sharedContext,storageContainer=createElement("div");sharedContext.activate=(vnode,container,anchor,namespace,optimized)=>{const instance2=vnode.component;move(vnode,container,anchor,0,parentSuspense),patch(instance2.vnode,vnode,container,anchor,instance2,parentSuspense,namespace,vnode.slotScopeIds,optimized),queuePostRenderEffect(()=>{instance2.isDeactivated=!1,instance2.a&&invokeArrayFns(instance2.a);const vnodeHook=vnode.props&&vnode.props.onVnodeMounted;vnodeHook&&invokeVNodeHook(vnodeHook,instance2.parent,vnode)},parentSuspense)},sharedContext.deactivate=vnode=>{const instance2=vnode.component;invalidateMount(instance2.m),invalidateMount(instance2.a),move(vnode,storageContainer,null,1,parentSuspense),queuePostRenderEffect(()=>{instance2.da&&invokeArrayFns(instance2.da);const vnodeHook=vnode.props&&vnode.props.onVnodeUnmounted;vnodeHook&&invokeVNodeHook(vnodeHook,instance2.parent,vnode),instance2.isDeactivated=!0},parentSuspense)};function unmount(vnode){resetShapeFlag(vnode),_unmount(vnode,instance,parentSuspense,!0)}__name(unmount,"unmount");function pruneCache(filter){cache.forEach((vnode,key)=>{const name=getComponentName(vnode.type);name&&!filter(name)&&pruneCacheEntry(key)})}__name(pruneCache,"pruneCache");function pruneCacheEntry(key){const cached=cache.get(key);cached&&(!current||!isSameVNodeType(cached,current))?unmount(cached):current&&resetShapeFlag(current),cache.delete(key),keys.delete(key)}__name(pruneCacheEntry,"pruneCacheEntry"),watch(()=>[props.include,props.exclude],([include,exclude])=>{include&&pruneCache(name=>matches(include,name)),exclude&&pruneCache(name=>!matches(exclude,name))},{flush:"post",deep:!0});let pendingCacheKey=null;const cacheSubtree=__name(()=>{pendingCacheKey!=null&&(isSuspense(instance.subTree.type)?queuePostRenderEffect(()=>{cache.set(pendingCacheKey,getInnerChild(instance.subTree))},instance.subTree.suspense):cache.set(pendingCacheKey,getInnerChild(instance.subTree)))},"cacheSubtree");return onMounted(cacheSubtree),onUpdated(cacheSubtree),onBeforeUnmount(()=>{cache.forEach(cached=>{const{subTree,suspense}=instance,vnode=getInnerChild(subTree);if(cached.type===vnode.type&&cached.key===vnode.key){resetShapeFlag(vnode);const da=vnode.component.da;da&&queuePostRenderEffect(da,suspense);return}unmount(cached)})}),()=>{if(pendingCacheKey=null,!slots.default)return current=null;const children=slots.default(),rawVNode=children[0];if(children.length>1)return current=null,children;if(!isVNode(rawVNode)||!(rawVNode.shapeFlag&4)&&!(rawVNode.shapeFlag&128))return current=null,rawVNode;let vnode=getInnerChild(rawVNode);if(vnode.type===Comment)return current=null,vnode;const comp=vnode.type,name=getComponentName(isAsyncWrapper(vnode)?vnode.type.__asyncResolved||{}:comp),{include,exclude,max}=props;if(include&&(!name||!matches(include,name))||exclude&&name&&matches(exclude,name))return vnode.shapeFlag&=-257,current=vnode,rawVNode;const key=vnode.key==null?comp:vnode.key,cachedVNode=cache.get(key);return vnode.el&&(vnode=cloneVNode(vnode),rawVNode.shapeFlag&128&&(rawVNode.ssContent=vnode)),pendingCacheKey=key,cachedVNode?(vnode.el=cachedVNode.el,vnode.component=cachedVNode.component,vnode.transition&&setTransitionHooks(vnode,vnode.transition),vnode.shapeFlag|=512,keys.delete(key),keys.add(key)):(keys.add(key),max&&keys.size>parseInt(max,10)&&pruneCacheEntry(keys.values().next().value)),vnode.shapeFlag|=256,current=vnode,isSuspense(rawVNode.type)?rawVNode:vnode}}},KeepAlive=KeepAliveImpl;function matches(pattern,name){return isArray$1(pattern)?pattern.some(p2=>matches(p2,name)):isString(pattern)?pattern.split(",").includes(name):isRegExp(pattern)?(pattern.lastIndex=0,pattern.test(name)):!1}__name(matches,"matches");function onActivated(hook,target){registerKeepAliveHook(hook,"a",target)}__name(onActivated,"onActivated");function onDeactivated(hook,target){registerKeepAliveHook(hook,"da",target)}__name(onDeactivated,"onDeactivated");function registerKeepAliveHook(hook,type,target=currentInstance){const wrappedHook=hook.__wdc||(hook.__wdc=()=>{let current=target;for(;current;){if(current.isDeactivated)return;current=current.parent}return hook()});if(injectHook(type,wrappedHook,target),target){let current=target.parent;for(;current&&current.parent;)isKeepAlive(current.parent.vnode)&&injectToKeepAliveRoot(wrappedHook,type,target,current),current=current.parent}}__name(registerKeepAliveHook,"registerKeepAliveHook");function injectToKeepAliveRoot(hook,type,target,keepAliveRoot){const injected=injectHook(type,hook,keepAliveRoot,!0);onUnmounted(()=>{remove(keepAliveRoot[type],injected)},target)}__name(injectToKeepAliveRoot,"injectToKeepAliveRoot");function resetShapeFlag(vnode){vnode.shapeFlag&=-257,vnode.shapeFlag&=-513}__name(resetShapeFlag,"resetShapeFlag");function getInnerChild(vnode){return vnode.shapeFlag&128?vnode.ssContent:vnode}__name(getInnerChild,"getInnerChild");function injectHook(type,hook,target=currentInstance,prepend=!1){if(target){const hooks=target[type]||(target[type]=[]),wrappedHook=hook.__weh||(hook.__weh=(...args)=>{pauseTracking();const reset=setCurrentInstance(target),res=callWithAsyncErrorHandling(hook,target,type,args);return reset(),resetTracking(),res});return prepend?hooks.unshift(wrappedHook):hooks.push(wrappedHook),wrappedHook}}__name(injectHook,"injectHook");const createHook=__name(lifecycle=>(hook,target=currentInstance)=>{(!isInSSRComponentSetup||lifecycle==="sp")&&injectHook(lifecycle,(...args)=>hook(...args),target)},"createHook"),onBeforeMount=createHook("bm"),onMounted=createHook("m"),onBeforeUpdate=createHook("bu"),onUpdated=createHook("u"),onBeforeUnmount=createHook("bum"),onUnmounted=createHook("um"),onServerPrefetch=createHook("sp"),onRenderTriggered=createHook("rtg"),onRenderTracked=createHook("rtc");function onErrorCaptured(hook,target=currentInstance){injectHook("ec",hook,target)}__name(onErrorCaptured,"onErrorCaptured");const COMPONENTS="components",DIRECTIVES="directives";function resolveComponent(name,maybeSelfReference){return resolveAsset(COMPONENTS,name,!0,maybeSelfReference)||name}__name(resolveComponent,"resolveComponent");const NULL_DYNAMIC_COMPONENT=Symbol.for("v-ndc");function resolveDynamicComponent(component){return isString(component)?resolveAsset(COMPONENTS,component,!1)||component:component||NULL_DYNAMIC_COMPONENT}__name(resolveDynamicComponent,"resolveDynamicComponent");function resolveDirective(name){return resolveAsset(DIRECTIVES,name)}__name(resolveDirective,"resolveDirective");function resolveAsset(type,name,warnMissing=!0,maybeSelfReference=!1){const instance=currentRenderingInstance||currentInstance;if(instance){const Component=instance.type;if(type===COMPONENTS){const selfName=getComponentName(Component,!1);if(selfName&&(selfName===name||selfName===camelize(name)||selfName===capitalize(camelize(name))))return Component}const res=resolve(instance[type]||Component[type],name)||resolve(instance.appContext[type],name);return!res&&maybeSelfReference?Component:res}}__name(resolveAsset,"resolveAsset");function resolve(registry,name){return registry&&(registry[name]||registry[camelize(name)]||registry[capitalize(camelize(name))])}__name(resolve,"resolve");function renderList(source,renderItem,cache,index){let ret;const cached=cache&&cache[index],sourceIsArray=isArray$1(source);if(sourceIsArray||isString(source)){const sourceIsReactiveArray=sourceIsArray&&isReactive(source);let needsWrap=!1,isReadonlySource=!1;sourceIsReactiveArray&&(needsWrap=!isShallow(source),isReadonlySource=isReadonly(source),source=shallowReadArray(source)),ret=new Array(source.length);for(let i=0,l=source.length;i<l;i++)ret[i]=renderItem(needsWrap?isReadonlySource?toReadonly(toReactive(source[i])):toReactive(source[i]):source[i],i,void 0,cached&&cached[i])}else if(typeof source=="number"){ret=new Array(source);for(let i=0;i<source;i++)ret[i]=renderItem(i+1,i,void 0,cached&&cached[i])}else if(isObject(source))if(source[Symbol.iterator])ret=Array.from(source,(item,i)=>renderItem(item,i,void 0,cached&&cached[i]));else{const keys=Object.keys(source);ret=new Array(keys.length);for(let i=0,l=keys.length;i<l;i++){const key=keys[i];ret[i]=renderItem(source[key],key,i,cached&&cached[i])}}else ret=[];return cache&&(cache[index]=ret),ret}__name(renderList,"renderList");function createSlots(slots,dynamicSlots){for(let i=0;i<dynamicSlots.length;i++){const slot=dynamicSlots[i];if(isArray$1(slot))for(let j=0;j<slot.length;j++)slots[slot[j].name]=slot[j].fn;else slot&&(slots[slot.name]=slot.key?(...args)=>{const res=slot.fn(...args);return res&&(res.key=slot.key),res}:slot.fn)}return slots}__name(createSlots,"createSlots");function renderSlot(slots,name,props={},fallback,noSlotted){if(currentRenderingInstance.ce||currentRenderingInstance.parent&&isAsyncWrapper(currentRenderingInstance.parent)&&currentRenderingInstance.parent.ce)return name!=="default"&&(props.name=name),openBlock(),createBlock(Fragment,null,[createVNode("slot",props,fallback&&fallback())],64);let slot=slots[name];slot&&slot._c&&(slot._d=!1),openBlock();const validSlotContent=slot&&ensureValidVNode(slot(props)),slotKey=props.key||validSlotContent&&validSlotContent.key,rendered=createBlock(Fragment,{key:(slotKey&&!isSymbol(slotKey)?slotKey:`_${name}`)+(!validSlotContent&&fallback?"_fb":"")},validSlotContent||(fallback?fallback():[]),validSlotContent&&slots._===1?64:-2);return!noSlotted&&rendered.scopeId&&(rendered.slotScopeIds=[rendered.scopeId+"-s"]),slot&&slot._c&&(slot._d=!0),rendered}__name(renderSlot,"renderSlot");function ensureValidVNode(vnodes){return vnodes.some(child=>isVNode(child)?!(child.type===Comment||child.type===Fragment&&!ensureValidVNode(child.children)):!0)?vnodes:null}__name(ensureValidVNode,"ensureValidVNode");function toHandlers(obj,preserveCaseIfNecessary){const ret={};for(const key in obj)ret[preserveCaseIfNecessary&&/[A-Z]/.test(key)?`on:${key}`:toHandlerKey(key)]=obj[key];return ret}__name(toHandlers,"toHandlers");const getPublicInstance=__name(i=>i?isStatefulComponent(i)?getComponentPublicInstance(i):getPublicInstance(i.parent):null,"getPublicInstance"),publicPropertiesMap=extend(Object.create(null),{$:__name(i=>i,"$"),$el:__name(i=>i.vnode.el,"$el"),$data:__name(i=>i.data,"$data"),$props:__name(i=>i.props,"$props"),$attrs:__name(i=>i.attrs,"$attrs"),$slots:__name(i=>i.slots,"$slots"),$refs:__name(i=>i.refs,"$refs"),$parent:__name(i=>getPublicInstance(i.parent),"$parent"),$root:__name(i=>getPublicInstance(i.root),"$root"),$host:__name(i=>i.ce,"$host"),$emit:__name(i=>i.emit,"$emit"),$options:__name(i=>resolveMergedOptions(i),"$options"),$forceUpdate:__name(i=>i.f||(i.f=()=>{queueJob(i.update)}),"$forceUpdate"),$nextTick:__name(i=>i.n||(i.n=nextTick.bind(i.proxy)),"$nextTick"),$watch:__name(i=>instanceWatch.bind(i),"$watch")}),hasSetupBinding=__name((state,key)=>state!==EMPTY_OBJ&&!state.__isScriptSetup&&hasOwn(state,key),"hasSetupBinding"),PublicInstanceProxyHandlers={get({_:instance},key){if(key==="__v_skip")return!0;const{ctx,setupState,data,props,accessCache,type,appContext}=instance;let normalizedProps;if(key[0]!=="$"){const n=accessCache[key];if(n!==void 0)switch(n){case 1:return setupState[key];case 2:return data[key];case 4:return ctx[key];case 3:return props[key]}else{if(hasSetupBinding(setupState,key))return accessCache[key]=1,setupState[key];if(data!==EMPTY_OBJ&&hasOwn(data,key))return accessCache[key]=2,data[key];if((normalizedProps=instance.propsOptions[0])&&hasOwn(normalizedProps,key))return accessCache[key]=3,props[key];if(ctx!==EMPTY_OBJ&&hasOwn(ctx,key))return accessCache[key]=4,ctx[key];shouldCacheAccess&&(accessCache[key]=0)}}const publicGetter=publicPropertiesMap[key];let cssModule,globalProperties;if(publicGetter)return key==="$attrs"&&track(instance.attrs,"get",""),publicGetter(instance);if((cssModule=type.__cssModules)&&(cssModule=cssModule[key]))return cssModule;if(ctx!==EMPTY_OBJ&&hasOwn(ctx,key))return accessCache[key]=4,ctx[key];if(globalProperties=appContext.config.globalProperties,hasOwn(globalProperties,key))return globalProperties[key]},set({_:instance},key,value){const{data,setupState,ctx}=instance;return hasSetupBinding(setupState,key)?(setupState[key]=value,!0):data!==EMPTY_OBJ&&hasOwn(data,key)?(data[key]=value,!0):hasOwn(instance.props,key)||key[0]==="$"&&key.slice(1)in instance?!1:(ctx[key]=value,!0)},has({_:{data,setupState,accessCache,ctx,appContext,propsOptions}},key){let normalizedProps;return!!accessCache[key]||data!==EMPTY_OBJ&&hasOwn(data,key)||hasSetupBinding(setupState,key)||(normalizedProps=propsOptions[0])&&hasOwn(normalizedProps,key)||hasOwn(ctx,key)||hasOwn(publicPropertiesMap,key)||hasOwn(appContext.config.globalProperties,key)},defineProperty(target,key,descriptor){return descriptor.get!=null?target._.accessCache[key]=0:hasOwn(descriptor,"value")&&this.set(target,key,descriptor.value,null),Reflect.defineProperty(target,key,descriptor)}},RuntimeCompiledPublicInstanceProxyHandlers=extend({},PublicInstanceProxyHandlers,{get(target,key){if(key!==Symbol.unscopables)return PublicInstanceProxyHandlers.get(target,key,target)},has(_,key){return key[0]!=="_"&&!isGloballyAllowed(key)}});function defineProps(){return null}__name(defineProps,"defineProps");function defineEmits(){return null}__name(defineEmits,"defineEmits");function defineExpose(exposed){}__name(defineExpose,"defineExpose");function defineOptions(options){}__name(defineOptions,"defineOptions");function defineSlots(){return null}__name(defineSlots,"defineSlots");function defineModel(){}__name(defineModel,"defineModel");function withDefaults(props,defaults){return null}__name(withDefaults,"withDefaults");function useSlots(){return getContext().slots}__name(useSlots,"useSlots");function useAttrs(){return getContext().attrs}__name(useAttrs,"useAttrs");function getContext(calledFunctionName){const i=getCurrentInstance();return i.setupContext||(i.setupContext=createSetupContext(i))}__name(getContext,"getContext");function normalizePropsOrEmits(props){return isArray$1(props)?props.reduce((normalized,p2)=>(normalized[p2]=null,normalized),{}):props}__name(normalizePropsOrEmits,"normalizePropsOrEmits");function mergeDefaults(raw,defaults){const props=normalizePropsOrEmits(raw);for(const key in defaults){if(key.startsWith("__skip"))continue;let opt=props[key];opt?isArray$1(opt)||isFunction(opt)?opt=props[key]={type:opt,default:defaults[key]}:opt.default=defaults[key]:opt===null&&(opt=props[key]={default:defaults[key]}),opt&&defaults[`__skip_${key}`]&&(opt.skipFactory=!0)}return props}__name(mergeDefaults,"mergeDefaults");function mergeModels(a,b){return!a||!b?a||b:isArray$1(a)&&isArray$1(b)?a.concat(b):extend({},normalizePropsOrEmits(a),normalizePropsOrEmits(b))}__name(mergeModels,"mergeModels");function createPropsRestProxy(props,excludedKeys){const ret={};for(const key in props)excludedKeys.includes(key)||Object.defineProperty(ret,key,{enumerable:!0,get:__name(()=>props[key],"get")});return ret}__name(createPropsRestProxy,"createPropsRestProxy");function withAsyncContext(getAwaitable){const ctx=getCurrentInstance();let awaitable=getAwaitable();return unsetCurrentInstance(),isPromise(awaitable)&&(awaitable=awaitable.catch(e=>{throw setCurrentInstance(ctx),e})),[awaitable,()=>setCurrentInstance(ctx)]}__name(withAsyncContext,"withAsyncContext");let shouldCacheAccess=!0;function applyOptions(instance){const options=resolveMergedOptions(instance),publicThis=instance.proxy,ctx=instance.ctx;shouldCacheAccess=!1,options.beforeCreate&&callHook$1(options.beforeCreate,instance,"bc");const{data:dataOptions,computed:computedOptions,methods,watch:watchOptions,provide:provideOptions,inject:injectOptions,created,beforeMount,mounted,beforeUpdate,updated,activated,deactivated,beforeDestroy,beforeUnmount,destroyed,unmounted,render:render2,renderTracked,renderTriggered,errorCaptured,serverPrefetch,expose,inheritAttrs,components,directives,filters}=options;if(injectOptions&&resolveInjections(injectOptions,ctx,null),methods)for(const key in methods){const methodHandler=methods[key];isFunction(methodHandler)&&(ctx[key]=methodHandler.bind(publicThis))}if(dataOptions){const data=dataOptions.call(publicThis,publicThis);isObject(data)&&(instance.data=reactive(data))}if(shouldCacheAccess=!0,computedOptions)for(const key in computedOptions){const opt=computedOptions[key],get=isFunction(opt)?opt.bind(publicThis,publicThis):isFunction(opt.get)?opt.get.bind(publicThis,publicThis):NOOP,set=!isFunction(opt)&&isFunction(opt.set)?opt.set.bind(publicThis):NOOP,c=computed({get,set});Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,get:__name(()=>c.value,"get"),set:__name(v=>c.value=v,"set")})}if(watchOptions)for(const key in watchOptions)createWatcher(watchOptions[key],ctx,publicThis,key);if(provideOptions){const provides=isFunction(provideOptions)?provideOptions.call(publicThis):provideOptions;Reflect.ownKeys(provides).forEach(key=>{provide(key,provides[key])})}created&&callHook$1(created,instance,"c");function registerLifecycleHook(register,hook){isArray$1(hook)?hook.forEach(_hook=>register(_hook.bind(publicThis))):hook&&register(hook.bind(publicThis))}if(__name(registerLifecycleHook,"registerLifecycleHook"),registerLifecycleHook(onBeforeMount,beforeMount),registerLifecycleHook(onMounted,mounted),registerLifecycleHook(onBeforeUpdate,beforeUpdate),registerLifecycleHook(onUpdated,updated),registerLifecycleHook(onActivated,activated),registerLifecycleHook(onDeactivated,deactivated),registerLifecycleHook(onErrorCaptured,errorCaptured),registerLifecycleHook(onRenderTracked,renderTracked),registerLifecycleHook(onRenderTriggered,renderTriggered),registerLifecycleHook(onBeforeUnmount,beforeUnmount),registerLifecycleHook(onUnmounted,unmounted),registerLifecycleHook(onServerPrefetch,serverPrefetch),isArray$1(expose))if(expose.length){const exposed=instance.exposed||(instance.exposed={});expose.forEach(key=>{Object.defineProperty(exposed,key,{get:__name(()=>publicThis[key],"get"),set:__name(val=>publicThis[key]=val,"set"),enumerable:!0})})}else instance.exposed||(instance.exposed={});render2&&instance.render===NOOP&&(instance.render=render2),inheritAttrs!=null&&(instance.inheritAttrs=inheritAttrs),components&&(instance.components=components),directives&&(instance.directives=directives),serverPrefetch&&markAsyncBoundary(instance)}__name(applyOptions,"applyOptions");function resolveInjections(injectOptions,ctx,checkDuplicateProperties=NOOP){isArray$1(injectOptions)&&(injectOptions=normalizeInject(injectOptions));for(const key in injectOptions){const opt=injectOptions[key];let injected;isObject(opt)?"default"in opt?injected=inject(opt.from||key,opt.default,!0):injected=inject(opt.from||key):injected=inject(opt),isRef(injected)?Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,get:__name(()=>injected.value,"get"),set:__name(v=>injected.value=v,"set")}):ctx[key]=injected}}__name(resolveInjections,"resolveInjections");function callHook$1(hook,instance,type){callWithAsyncErrorHandling(isArray$1(hook)?hook.map(h2=>h2.bind(instance.proxy)):hook.bind(instance.proxy),instance,type)}__name(callHook$1,"callHook$1");function createWatcher(raw,ctx,publicThis,key){let getter=key.includes(".")?createPathGetter(publicThis,key):()=>publicThis[key];if(isString(raw)){const handler=ctx[raw];isFunction(handler)&&watch(getter,handler)}else if(isFunction(raw))watch(getter,raw.bind(publicThis));else if(isObject(raw))if(isArray$1(raw))raw.forEach(r=>createWatcher(r,ctx,publicThis,key));else{const handler=isFunction(raw.handler)?raw.handler.bind(publicThis):ctx[raw.handler];isFunction(handler)&&watch(getter,handler,raw)}}__name(createWatcher,"createWatcher");function resolveMergedOptions(instance){const base=instance.type,{mixins,extends:extendsOptions}=base,{mixins:globalMixins,optionsCache:cache,config:{optionMergeStrategies}}=instance.appContext,cached=cache.get(base);let resolved;return cached?resolved=cached:!globalMixins.length&&!mixins&&!extendsOptions?resolved=base:(resolved={},globalMixins.length&&globalMixins.forEach(m=>mergeOptions$1(resolved,m,optionMergeStrategies,!0)),mergeOptions$1(resolved,base,optionMergeStrategies)),isObject(base)&&cache.set(base,resolved),resolved}__name(resolveMergedOptions,"resolveMergedOptions");function mergeOptions$1(to,from,strats,asMixin=!1){const{mixins,extends:extendsOptions}=from;extendsOptions&&mergeOptions$1(to,extendsOptions,strats,!0),mixins&&mixins.forEach(m=>mergeOptions$1(to,m,strats,!0));for(const key in from)if(!(asMixin&&key==="expose")){const strat=internalOptionMergeStrats[key]||strats&&strats[key];to[key]=strat?strat(to[key],from[key]):from[key]}return to}__name(mergeOptions$1,"mergeOptions$1");const internalOptionMergeStrats={data:mergeDataFn,props:mergeEmitsOrPropsOptions,emits:mergeEmitsOrPropsOptions,methods:mergeObjectOptions,computed:mergeObjectOptions,beforeCreate:mergeAsArray,created:mergeAsArray,beforeMount:mergeAsArray,mounted:mergeAsArray,beforeUpdate:mergeAsArray,updated:mergeAsArray,beforeDestroy:mergeAsArray,beforeUnmount:mergeAsArray,destroyed:mergeAsArray,unmounted:mergeAsArray,activated:mergeAsArray,deactivated:mergeAsArray,errorCaptured:mergeAsArray,serverPrefetch:mergeAsArray,components:mergeObjectOptions,directives:mergeObjectOptions,watch:mergeWatchOptions,provide:mergeDataFn,inject:mergeInject};function mergeDataFn(to,from){return from?to?__name(function(){return extend(isFunction(to)?to.call(this,this):to,isFunction(from)?from.call(this,this):from)},"mergedDataFn"):from:to}__name(mergeDataFn,"mergeDataFn");function mergeInject(to,from){return mergeObjectOptions(normalizeInject(to),normalizeInject(from))}__name(mergeInject,"mergeInject");function normalizeInject(raw){if(isArray$1(raw)){const res={};for(let i=0;i<raw.length;i++)res[raw[i]]=raw[i];return res}return raw}__name(normalizeInject,"normalizeInject");function mergeAsArray(to,from){return to?[...new Set([].concat(to,from))]:from}__name(mergeAsArray,"mergeAsArray");function mergeObjectOptions(to,from){return to?extend(Object.create(null),to,from):from}__name(mergeObjectOptions,"mergeObjectOptions");function mergeEmitsOrPropsOptions(to,from){return to?isArray$1(to)&&isArray$1(from)?[...new Set([...to,...from])]:extend(Object.create(null),normalizePropsOrEmits(to),normalizePropsOrEmits(from??{})):from}__name(mergeEmitsOrPropsOptions,"mergeEmitsOrPropsOptions");function mergeWatchOptions(to,from){if(!to)return from;if(!from)return to;const merged=extend(Object.create(null),to);for(const key in from)merged[key]=mergeAsArray(to[key],from[key]);return merged}__name(mergeWatchOptions,"mergeWatchOptions");function createAppContext(){return{app:null,config:{isNativeTag:NO,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}__name(createAppContext,"createAppContext");let uid$1=0;function createAppAPI(render2,hydrate2){return __name(function(rootComponent,rootProps=null){isFunction(rootComponent)||(rootComponent=extend({},rootComponent)),rootProps!=null&&!isObject(rootProps)&&(rootProps=null);const context=createAppContext(),installedPlugins=new WeakSet,pluginCleanupFns=[];let isMounted=!1;const app=context.app={_uid:uid$1++,_component:rootComponent,_props:rootProps,_container:null,_context:context,_instance:null,version,get config(){return context.config},set config(v){},use(plugin,...options){return installedPlugins.has(plugin)||(plugin&&isFunction(plugin.install)?(installedPlugins.add(plugin),plugin.install(app,...options)):isFunction(plugin)&&(installedPlugins.add(plugin),plugin(app,...options))),app},mixin(mixin){return context.mixins.includes(mixin)||context.mixins.push(mixin),app},component(name,component){return component?(context.components[name]=component,app):context.components[name]},directive(name,directive){return directive?(context.directives[name]=directive,app):context.directives[name]},mount(rootContainer,isHydrate,namespace){if(!isMounted){const vnode=app._ceVNode||createVNode(rootComponent,rootProps);return vnode.appContext=context,namespace===!0?namespace="svg":namespace===!1&&(namespace=void 0),isHydrate&&hydrate2?hydrate2(vnode,rootContainer):render2(vnode,rootContainer,namespace),isMounted=!0,app._container=rootContainer,rootContainer.__vue_app__=app,getComponentPublicInstance(vnode.component)}},onUnmount(cleanupFn){pluginCleanupFns.push(cleanupFn)},unmount(){isMounted&&(callWithAsyncErrorHandling(pluginCleanupFns,app._instance,16),render2(null,app._container),delete app._container.__vue_app__)},provide(key,value){return context.provides[key]=value,app},runWithContext(fn){const lastApp=currentApp;currentApp=app;try{return fn()}finally{currentApp=lastApp}}};return app},"createApp")}__name(createAppAPI,"createAppAPI");let currentApp=null;function provide(key,value){if(currentInstance){let provides=currentInstance.provides;const parentProvides=currentInstance.parent&&currentInstance.parent.provides;parentProvides===provides&&(provides=currentInstance.provides=Object.create(parentProvides)),provides[key]=value}}__name(provide,"provide");function inject(key,defaultValue,treatDefaultAsFactory=!1){const instance=getCurrentInstance();if(instance||currentApp){let provides=currentApp?currentApp._context.provides:instance?instance.parent==null||instance.ce?instance.vnode.appContext&&instance.vnode.appContext.provides:instance.parent.provides:void 0;if(provides&&key in provides)return provides[key];if(arguments.length>1)return treatDefaultAsFactory&&isFunction(defaultValue)?defaultValue.call(instance&&instance.proxy):defaultValue}}__name(inject,"inject");function hasInjectionContext(){return!!(getCurrentInstance()||currentApp)}__name(hasInjectionContext,"hasInjectionContext");const internalObjectProto={},createInternalObject=__name(()=>Object.create(internalObjectProto),"createInternalObject"),isInternalObject=__name(obj=>Object.getPrototypeOf(obj)===internalObjectProto,"isInternalObject");function initProps(instance,rawProps,isStateful,isSSR=!1){const props={},attrs=createInternalObject();instance.propsDefaults=Object.create(null),setFullProps(instance,rawProps,props,attrs);for(const key in instance.propsOptions[0])key in props||(props[key]=void 0);isStateful?instance.props=isSSR?props:shallowReactive(props):instance.type.props?instance.props=props:instance.props=attrs,instance.attrs=attrs}__name(initProps,"initProps");function updateProps(instance,rawProps,rawPrevProps,optimized){const{props,attrs,vnode:{patchFlag}}=instance,rawCurrentProps=toRaw(props),[options]=instance.propsOptions;let hasAttrsChanged=!1;if((optimized||patchFlag>0)&&!(patchFlag&16)){if(patchFlag&8){const propsToUpdate=instance.vnode.dynamicProps;for(let i=0;i<propsToUpdate.length;i++){let key=propsToUpdate[i];if(isEmitListener(instance.emitsOptions,key))continue;const value=rawProps[key];if(options)if(hasOwn(attrs,key))value!==attrs[key]&&(attrs[key]=value,hasAttrsChanged=!0);else{const camelizedKey=camelize(key);props[camelizedKey]=resolvePropValue(options,rawCurrentProps,camelizedKey,value,instance,!1)}else value!==attrs[key]&&(attrs[key]=value,hasAttrsChanged=!0)}}}else{setFullProps(instance,rawProps,props,attrs)&&(hasAttrsChanged=!0);let kebabKey;for(const key in rawCurrentProps)(!rawProps||!hasOwn(rawProps,key)&&((kebabKey=hyphenate(key))===key||!hasOwn(rawProps,kebabKey)))&&(options?rawPrevProps&&(rawPrevProps[key]!==void 0||rawPrevProps[kebabKey]!==void 0)&&(props[key]=resolvePropValue(options,rawCurrentProps,key,void 0,instance,!0)):delete props[key]);if(attrs!==rawCurrentProps)for(const key in attrs)(!rawProps||!hasOwn(rawProps,key))&&(delete attrs[key],hasAttrsChanged=!0)}hasAttrsChanged&&trigger(instance.attrs,"set","")}__name(updateProps,"updateProps");function setFullProps(instance,rawProps,props,attrs){const[options,needCastKeys]=instance.propsOptions;let hasAttrsChanged=!1,rawCastValues;if(rawProps)for(let key in rawProps){if(isReservedProp(key))continue;const value=rawProps[key];let camelKey;options&&hasOwn(options,camelKey=camelize(key))?!needCastKeys||!needCastKeys.includes(camelKey)?props[camelKey]=value:(rawCastValues||(rawCastValues={}))[camelKey]=value:isEmitListener(instance.emitsOptions,key)||(!(key in attrs)||value!==attrs[key])&&(attrs[key]=value,hasAttrsChanged=!0)}if(needCastKeys){const rawCurrentProps=toRaw(props),castValues=rawCastValues||EMPTY_OBJ;for(let i=0;i<needCastKeys.length;i++){const key=needCastKeys[i];props[key]=resolvePropValue(options,rawCurrentProps,key,castValues[key],instance,!hasOwn(castValues,key))}}return hasAttrsChanged}__name(setFullProps,"setFullProps");function resolvePropValue(options,props,key,value,instance,isAbsent){const opt=options[key];if(opt!=null){const hasDefault=hasOwn(opt,"default");if(hasDefault&&value===void 0){const defaultValue=opt.default;if(opt.type!==Function&&!opt.skipFactory&&isFunction(defaultValue)){const{propsDefaults}=instance;if(key in propsDefaults)value=propsDefaults[key];else{const reset=setCurrentInstance(instance);value=propsDefaults[key]=defaultValue.call(null,props),reset()}}else value=defaultValue;instance.ce&&instance.ce._setProp(key,value)}opt[0]&&(isAbsent&&!hasDefault?value=!1:opt[1]&&(value===""||value===hyphenate(key))&&(value=!0))}return value}__name(resolvePropValue,"resolvePropValue");const mixinPropsCache=new WeakMap;function normalizePropsOptions(comp,appContext,asMixin=!1){const cache=asMixin?mixinPropsCache:appContext.propsCache,cached=cache.get(comp);if(cached)return cached;const raw=comp.props,normalized={},needCastKeys=[];let hasExtends=!1;if(!isFunction(comp)){const extendProps=__name(raw2=>{hasExtends=!0;const[props,keys]=normalizePropsOptions(raw2,appContext,!0);extend(normalized,props),keys&&needCastKeys.push(...keys)},"extendProps");!asMixin&&appContext.mixins.length&&appContext.mixins.forEach(extendProps),comp.extends&&extendProps(comp.extends),comp.mixins&&comp.mixins.forEach(extendProps)}if(!raw&&!hasExtends)return isObject(comp)&&cache.set(comp,EMPTY_ARR),EMPTY_ARR;if(isArray$1(raw))for(let i=0;i<raw.length;i++){const normalizedKey=camelize(raw[i]);validatePropName(normalizedKey)&&(normalized[normalizedKey]=EMPTY_OBJ)}else if(raw)for(const key in raw){const normalizedKey=camelize(key);if(validatePropName(normalizedKey)){const opt=raw[key],prop=normalized[normalizedKey]=isArray$1(opt)||isFunction(opt)?{type:opt}:extend({},opt),propType=prop.type;let shouldCast=!1,shouldCastTrue=!0;if(isArray$1(propType))for(let index=0;index<propType.length;++index){const type=propType[index],typeName=isFunction(type)&&type.name;if(typeName==="Boolean"){shouldCast=!0;break}else typeName==="String"&&(shouldCastTrue=!1)}else shouldCast=isFunction(propType)&&propType.name==="Boolean";prop[0]=shouldCast,prop[1]=shouldCastTrue,(shouldCast||hasOwn(prop,"default"))&&needCastKeys.push(normalizedKey)}}const res=[normalized,needCastKeys];return isObject(comp)&&cache.set(comp,res),res}__name(normalizePropsOptions,"normalizePropsOptions");function validatePropName(key){return key[0]!=="$"&&!isReservedProp(key)}__name(validatePropName,"validatePropName");const isInternalKey=__name(key=>key==="_"||key==="__"||key==="_ctx"||key==="$stable","isInternalKey"),normalizeSlotValue=__name(value=>isArray$1(value)?value.map(normalizeVNode):[normalizeVNode(value)],"normalizeSlotValue"),normalizeSlot$1=__name((key,rawSlot,ctx)=>{if(rawSlot._n)return rawSlot;const normalized=withCtx((...args)=>normalizeSlotValue(rawSlot(...args)),ctx);return normalized._c=!1,normalized},"normalizeSlot$1"),normalizeObjectSlots=__name((rawSlots,slots,instance)=>{const ctx=rawSlots._ctx;for(const key in rawSlots){if(isInternalKey(key))continue;const value=rawSlots[key];if(isFunction(value))slots[key]=normalizeSlot$1(key,value,ctx);else if(value!=null){const normalized=normalizeSlotValue(value);slots[key]=()=>normalized}}},"normalizeObjectSlots"),normalizeVNodeSlots=__name((instance,children)=>{const normalized=normalizeSlotValue(children);instance.slots.default=()=>normalized},"normalizeVNodeSlots"),assignSlots=__name((slots,children,optimized)=>{for(const key in children)(optimized||!isInternalKey(key))&&(slots[key]=children[key])},"assignSlots"),initSlots=__name((instance,children,optimized)=>{const slots=instance.slots=createInternalObject();if(instance.vnode.shapeFlag&32){const cacheIndexes=children.__;cacheIndexes&&def(slots,"__",cacheIndexes,!0);const type=children._;type?(assignSlots(slots,children,optimized),optimized&&def(slots,"_",type,!0)):normalizeObjectSlots(children,slots)}else children&&normalizeVNodeSlots(instance,children)},"initSlots"),updateSlots=__name((instance,children,optimized)=>{const{vnode,slots}=instance;let needDeletionCheck=!0,deletionComparisonTarget=EMPTY_OBJ;if(vnode.shapeFlag&32){const type=children._;type?optimized&&type===1?needDeletionCheck=!1:assignSlots(slots,children,optimized):(needDeletionCheck=!children.$stable,normalizeObjectSlots(children,slots)),deletionComparisonTarget=children}else children&&(normalizeVNodeSlots(instance,children),deletionComparisonTarget={default:1});if(needDeletionCheck)for(const key in slots)!isInternalKey(key)&&deletionComparisonTarget[key]==null&&delete slots[key]},"updateSlots"),queuePostRenderEffect=queueEffectWithSuspense;function createRenderer(options){return baseCreateRenderer(options)}__name(createRenderer,"createRenderer");function createHydrationRenderer(options){return baseCreateRenderer(options,createHydrationFunctions)}__name(createHydrationRenderer,"createHydrationRenderer");function baseCreateRenderer(options,createHydrationFns){const target=getGlobalThis();target.__VUE__=!0;const{insert:hostInsert,remove:hostRemove,patchProp:hostPatchProp,createElement:hostCreateElement,createText:hostCreateText,createComment:hostCreateComment,setText:hostSetText,setElementText:hostSetElementText,parentNode:hostParentNode,nextSibling:hostNextSibling,setScopeId:hostSetScopeId=NOOP,insertStaticContent:hostInsertStaticContent}=options,patch=__name((n1,n2,container,anchor=null,parentComponent=null,parentSuspense=null,namespace=void 0,slotScopeIds=null,optimized=!!n2.dynamicChildren)=>{if(n1===n2)return;n1&&!isSameVNodeType(n1,n2)&&(anchor=getNextHostNode(n1),unmount(n1,parentComponent,parentSuspense,!0),n1=null),n2.patchFlag===-2&&(optimized=!1,n2.dynamicChildren=null);const{type,ref:ref3,shapeFlag}=n2;switch(type){case Text:processText(n1,n2,container,anchor);break;case Comment:processCommentNode(n1,n2,container,anchor);break;case Static:n1==null&&mountStaticNode(n2,container,anchor,namespace);break;case Fragment:processFragment(n1,n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized);break;default:shapeFlag&1?processElement(n1,n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized):shapeFlag&6?processComponent(n1,n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized):(shapeFlag&64||shapeFlag&128)&&type.process(n1,n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized,internals)}ref3!=null&&parentComponent?setRef(ref3,n1&&n1.ref,parentSuspense,n2||n1,!n2):ref3==null&&n1&&n1.ref!=null&&setRef(n1.ref,null,parentSuspense,n1,!0)},"patch"),processText=__name((n1,n2,container,anchor)=>{if(n1==null)hostInsert(n2.el=hostCreateText(n2.children),container,anchor);else{const el=n2.el=n1.el;n2.children!==n1.children&&hostSetText(el,n2.children)}},"processText"),processCommentNode=__name((n1,n2,container,anchor)=>{n1==null?hostInsert(n2.el=hostCreateComment(n2.children||""),container,anchor):n2.el=n1.el},"processCommentNode"),mountStaticNode=__name((n2,container,anchor,namespace)=>{[n2.el,n2.anchor]=hostInsertStaticContent(n2.children,container,anchor,namespace,n2.el,n2.anchor)},"mountStaticNode"),moveStaticNode=__name(({el,anchor},container,nextSibling)=>{let next;for(;el&&el!==anchor;)next=hostNextSibling(el),hostInsert(el,container,nextSibling),el=next;hostInsert(anchor,container,nextSibling)},"moveStaticNode"),removeStaticNode=__name(({el,anchor})=>{let next;for(;el&&el!==anchor;)next=hostNextSibling(el),hostRemove(el),el=next;hostRemove(anchor)},"removeStaticNode"),processElement=__name((n1,n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)=>{n2.type==="svg"?namespace="svg":n2.type==="math"&&(namespace="mathml"),n1==null?mountElement(n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized):patchElement(n1,n2,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)},"processElement"),mountElement=__name((vnode,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)=>{let el,vnodeHook;const{props,shapeFlag,transition,dirs}=vnode;if(el=vnode.el=hostCreateElement(vnode.type,namespace,props&&props.is,props),shapeFlag&8?hostSetElementText(el,vnode.children):shapeFlag&16&&mountChildren(vnode.children,el,null,parentComponent,parentSuspense,resolveChildrenNamespace(vnode,namespace),slotScopeIds,optimized),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"created"),setScopeId(el,vnode,vnode.scopeId,slotScopeIds,parentComponent),props){for(const key in props)key!=="value"&&!isReservedProp(key)&&hostPatchProp(el,key,null,props[key],namespace,parentComponent);"value"in props&&hostPatchProp(el,"value",null,props.value,namespace),(vnodeHook=props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHook,parentComponent,vnode)}dirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeMount");const needCallTransitionHooks=needTransition(parentSuspense,transition);needCallTransitionHooks&&transition.beforeEnter(el),hostInsert(el,container,anchor),((vnodeHook=props&&props.onVnodeMounted)||needCallTransitionHooks||dirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,vnode),needCallTransitionHooks&&transition.enter(el),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"mounted")},parentSuspense)},"mountElement"),setScopeId=__name((el,vnode,scopeId,slotScopeIds,parentComponent)=>{if(scopeId&&hostSetScopeId(el,scopeId),slotScopeIds)for(let i=0;i<slotScopeIds.length;i++)hostSetScopeId(el,slotScopeIds[i]);if(parentComponent){let subTree=parentComponent.subTree;if(vnode===subTree||isSuspense(subTree.type)&&(subTree.ssContent===vnode||subTree.ssFallback===vnode)){const parentVNode=parentComponent.vnode;setScopeId(el,parentVNode,parentVNode.scopeId,parentVNode.slotScopeIds,parentComponent.parent)}}},"setScopeId"),mountChildren=__name((children,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized,start=0)=>{for(let i=start;i<children.length;i++){const child=children[i]=optimized?cloneIfMounted(children[i]):normalizeVNode(children[i]);patch(null,child,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)}},"mountChildren"),patchElement=__name((n1,n2,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)=>{const el=n2.el=n1.el;let{patchFlag,dynamicChildren,dirs}=n2;patchFlag|=n1.patchFlag&16;const oldProps=n1.props||EMPTY_OBJ,newProps=n2.props||EMPTY_OBJ;let vnodeHook;if(parentComponent&&toggleRecurse(parentComponent,!1),(vnodeHook=newProps.onVnodeBeforeUpdate)&&invokeVNodeHook(vnodeHook,parentComponent,n2,n1),dirs&&invokeDirectiveHook(n2,n1,parentComponent,"beforeUpdate"),parentComponent&&toggleRecurse(parentComponent,!0),(oldProps.innerHTML&&newProps.innerHTML==null||oldProps.textContent&&newProps.textContent==null)&&hostSetElementText(el,""),dynamicChildren?patchBlockChildren(n1.dynamicChildren,dynamicChildren,el,parentComponent,parentSuspense,resolveChildrenNamespace(n2,namespace),slotScopeIds):optimized||patchChildren(n1,n2,el,null,parentComponent,parentSuspense,resolveChildrenNamespace(n2,namespace),slotScopeIds,!1),patchFlag>0){if(patchFlag&16)patchProps(el,oldProps,newProps,parentComponent,namespace);else if(patchFlag&2&&oldProps.class!==newProps.class&&hostPatchProp(el,"class",null,newProps.class,namespace),patchFlag&4&&hostPatchProp(el,"style",oldProps.style,newProps.style,namespace),patchFlag&8){const propsToUpdate=n2.dynamicProps;for(let i=0;i<propsToUpdate.length;i++){const key=propsToUpdate[i],prev=oldProps[key],next=newProps[key];(next!==prev||key==="value")&&hostPatchProp(el,key,prev,next,namespace,parentComponent)}}patchFlag&1&&n1.children!==n2.children&&hostSetElementText(el,n2.children)}else!optimized&&dynamicChildren==null&&patchProps(el,oldProps,newProps,parentComponent,namespace);((vnodeHook=newProps.onVnodeUpdated)||dirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,n2,n1),dirs&&invokeDirectiveHook(n2,n1,parentComponent,"updated")},parentSuspense)},"patchElement"),patchBlockChildren=__name((oldChildren,newChildren,fallbackContainer,parentComponent,parentSuspense,namespace,slotScopeIds)=>{for(let i=0;i<newChildren.length;i++){const oldVNode=oldChildren[i],newVNode=newChildren[i],container=oldVNode.el&&(oldVNode.type===Fragment||!isSameVNodeType(oldVNode,newVNode)||oldVNode.shapeFlag&198)?hostParentNode(oldVNode.el):fallbackContainer;patch(oldVNode,newVNode,container,null,parentComponent,parentSuspense,namespace,slotScopeIds,!0)}},"patchBlockChildren"),patchProps=__name((el,oldProps,newProps,parentComponent,namespace)=>{if(oldProps!==newProps){if(oldProps!==EMPTY_OBJ)for(const key in oldProps)!isReservedProp(key)&&!(key in newProps)&&hostPatchProp(el,key,oldProps[key],null,namespace,parentComponent);for(const key in newProps){if(isReservedProp(key))continue;const next=newProps[key],prev=oldProps[key];next!==prev&&key!=="value"&&hostPatchProp(el,key,prev,next,namespace,parentComponent)}"value"in newProps&&hostPatchProp(el,"value",oldProps.value,newProps.value,namespace)}},"patchProps"),processFragment=__name((n1,n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)=>{const fragmentStartAnchor=n2.el=n1?n1.el:hostCreateText(""),fragmentEndAnchor=n2.anchor=n1?n1.anchor:hostCreateText("");let{patchFlag,dynamicChildren,slotScopeIds:fragmentSlotScopeIds}=n2;fragmentSlotScopeIds&&(slotScopeIds=slotScopeIds?slotScopeIds.concat(fragmentSlotScopeIds):fragmentSlotScopeIds),n1==null?(hostInsert(fragmentStartAnchor,container,anchor),hostInsert(fragmentEndAnchor,container,anchor),mountChildren(n2.children||[],container,fragmentEndAnchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)):patchFlag>0&&patchFlag&64&&dynamicChildren&&n1.dynamicChildren?(patchBlockChildren(n1.dynamicChildren,dynamicChildren,container,parentComponent,parentSuspense,namespace,slotScopeIds),(n2.key!=null||parentComponent&&n2===parentComponent.subTree)&&traverseStaticChildren(n1,n2,!0)):patchChildren(n1,n2,container,fragmentEndAnchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)},"processFragment"),processComponent=__name((n1,n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)=>{n2.slotScopeIds=slotScopeIds,n1==null?n2.shapeFlag&512?parentComponent.ctx.activate(n2,container,anchor,namespace,optimized):mountComponent(n2,container,anchor,parentComponent,parentSuspense,namespace,optimized):updateComponent(n1,n2,optimized)},"processComponent"),mountComponent=__name((initialVNode,container,anchor,parentComponent,parentSuspense,namespace,optimized)=>{const instance=initialVNode.component=createComponentInstance(initialVNode,parentComponent,parentSuspense);if(isKeepAlive(initialVNode)&&(instance.ctx.renderer=internals),setupComponent(instance,!1,optimized),instance.asyncDep){if(parentSuspense&&parentSuspense.registerDep(instance,setupRenderEffect,optimized),!initialVNode.el){const placeholder=instance.subTree=createVNode(Comment);processCommentNode(null,placeholder,container,anchor),initialVNode.placeholder=placeholder.el}}else setupRenderEffect(instance,initialVNode,container,anchor,parentSuspense,namespace,optimized)},"mountComponent"),updateComponent=__name((n1,n2,optimized)=>{const instance=n2.component=n1.component;if(shouldUpdateComponent(n1,n2,optimized))if(instance.asyncDep&&!instance.asyncResolved){updateComponentPreRender(instance,n2,optimized);return}else instance.next=n2,instance.update();else n2.el=n1.el,instance.vnode=n2},"updateComponent"),setupRenderEffect=__name((instance,initialVNode,container,anchor,parentSuspense,namespace,optimized)=>{const componentUpdateFn=__name(()=>{if(instance.isMounted){let{next,bu,u,parent,vnode}=instance;{const nonHydratedAsyncRoot=locateNonHydratedAsyncRoot(instance);if(nonHydratedAsyncRoot){next&&(next.el=vnode.el,updateComponentPreRender(instance,next,optimized)),nonHydratedAsyncRoot.asyncDep.then(()=>{instance.isUnmounted||componentUpdateFn()});return}}let originNext=next,vnodeHook;toggleRecurse(instance,!1),next?(next.el=vnode.el,updateComponentPreRender(instance,next,optimized)):next=vnode,bu&&invokeArrayFns(bu),(vnodeHook=next.props&&next.props.onVnodeBeforeUpdate)&&invokeVNodeHook(vnodeHook,parent,next,vnode),toggleRecurse(instance,!0);const nextTree=renderComponentRoot(instance),prevTree=instance.subTree;instance.subTree=nextTree,patch(prevTree,nextTree,hostParentNode(prevTree.el),getNextHostNode(prevTree),instance,parentSuspense,namespace),next.el=nextTree.el,originNext===null&&updateHOCHostEl(instance,nextTree.el),u&&queuePostRenderEffect(u,parentSuspense),(vnodeHook=next.props&&next.props.onVnodeUpdated)&&queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook,parent,next,vnode),parentSuspense)}else{let vnodeHook;const{el,props}=initialVNode,{bm,m,parent,root,type}=instance,isAsyncWrapperVNode=isAsyncWrapper(initialVNode);if(toggleRecurse(instance,!1),bm&&invokeArrayFns(bm),!isAsyncWrapperVNode&&(vnodeHook=props&&props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHook,parent,initialVNode),toggleRecurse(instance,!0),el&&hydrateNode){const hydrateSubTree=__name(()=>{instance.subTree=renderComponentRoot(instance),hydrateNode(el,instance.subTree,instance,parentSuspense,null)},"hydrateSubTree");isAsyncWrapperVNode&&type.__asyncHydrate?type.__asyncHydrate(el,instance,hydrateSubTree):hydrateSubTree()}else{root.ce&&root.ce._def.shadowRoot!==!1&&root.ce._injectChildStyle(type);const subTree=instance.subTree=renderComponentRoot(instance);patch(null,subTree,container,anchor,instance,parentSuspense,namespace),initialVNode.el=subTree.el}if(m&&queuePostRenderEffect(m,parentSuspense),!isAsyncWrapperVNode&&(vnodeHook=props&&props.onVnodeMounted)){const scopedInitialVNode=initialVNode;queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook,parent,scopedInitialVNode),parentSuspense)}(initialVNode.shapeFlag&256||parent&&isAsyncWrapper(parent.vnode)&&parent.vnode.shapeFlag&256)&&instance.a&&queuePostRenderEffect(instance.a,parentSuspense),instance.isMounted=!0,initialVNode=container=anchor=null}},"componentUpdateFn");instance.scope.on();const effect2=instance.effect=new ReactiveEffect(componentUpdateFn);instance.scope.off();const update=instance.update=effect2.run.bind(effect2),job=instance.job=effect2.runIfDirty.bind(effect2);job.i=instance,job.id=instance.uid,effect2.scheduler=()=>queueJob(job),toggleRecurse(instance,!0),update()},"setupRenderEffect"),updateComponentPreRender=__name((instance,nextVNode,optimized)=>{nextVNode.component=instance;const prevProps=instance.vnode.props;instance.vnode=nextVNode,instance.next=null,updateProps(instance,nextVNode.props,prevProps,optimized),updateSlots(instance,nextVNode.children,optimized),pauseTracking(),flushPreFlushCbs(instance),resetTracking()},"updateComponentPreRender"),patchChildren=__name((n1,n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized=!1)=>{const c1=n1&&n1.children,prevShapeFlag=n1?n1.shapeFlag:0,c2=n2.children,{patchFlag,shapeFlag}=n2;if(patchFlag>0){if(patchFlag&128){patchKeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized);return}else if(patchFlag&256){patchUnkeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized);return}}shapeFlag&8?(prevShapeFlag&16&&unmountChildren(c1,parentComponent,parentSuspense),c2!==c1&&hostSetElementText(container,c2)):prevShapeFlag&16?shapeFlag&16?patchKeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized):unmountChildren(c1,parentComponent,parentSuspense,!0):(prevShapeFlag&8&&hostSetElementText(container,""),shapeFlag&16&&mountChildren(c2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized))},"patchChildren"),patchUnkeyedChildren=__name((c1,c2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)=>{c1=c1||EMPTY_ARR,c2=c2||EMPTY_ARR;const oldLength=c1.length,newLength=c2.length,commonLength=Math.min(oldLength,newLength);let i;for(i=0;i<commonLength;i++){const nextChild=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);patch(c1[i],nextChild,container,null,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)}oldLength>newLength?unmountChildren(c1,parentComponent,parentSuspense,!0,!1,commonLength):mountChildren(c2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized,commonLength)},"patchUnkeyedChildren"),patchKeyedChildren=__name((c1,c2,container,parentAnchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized)=>{let i=0;const l2=c2.length;let e1=c1.length-1,e2=l2-1;for(;i<=e1&&i<=e2;){const n1=c1[i],n2=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);if(isSameVNodeType(n1,n2))patch(n1,n2,container,null,parentComponent,parentSuspense,namespace,slotScopeIds,optimized);else break;i++}for(;i<=e1&&i<=e2;){const n1=c1[e1],n2=c2[e2]=optimized?cloneIfMounted(c2[e2]):normalizeVNode(c2[e2]);if(isSameVNodeType(n1,n2))patch(n1,n2,container,null,parentComponent,parentSuspense,namespace,slotScopeIds,optimized);else break;e1--,e2--}if(i>e1){if(i<=e2){const nextPos=e2+1,anchor=nextPos<l2?c2[nextPos].el:parentAnchor;for(;i<=e2;)patch(null,c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]),container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized),i++}}else if(i>e2)for(;i<=e1;)unmount(c1[i],parentComponent,parentSuspense,!0),i++;else{const s1=i,s2=i,keyToNewIndexMap=new Map;for(i=s2;i<=e2;i++){const nextChild=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);nextChild.key!=null&&keyToNewIndexMap.set(nextChild.key,i)}let j,patched=0;const toBePatched=e2-s2+1;let moved=!1,maxNewIndexSoFar=0;const newIndexToOldIndexMap=new Array(toBePatched);for(i=0;i<toBePatched;i++)newIndexToOldIndexMap[i]=0;for(i=s1;i<=e1;i++){const prevChild=c1[i];if(patched>=toBePatched){unmount(prevChild,parentComponent,parentSuspense,!0);continue}let newIndex;if(prevChild.key!=null)newIndex=keyToNewIndexMap.get(prevChild.key);else for(j=s2;j<=e2;j++)if(newIndexToOldIndexMap[j-s2]===0&&isSameVNodeType(prevChild,c2[j])){newIndex=j;break}newIndex===void 0?unmount(prevChild,parentComponent,parentSuspense,!0):(newIndexToOldIndexMap[newIndex-s2]=i+1,newIndex>=maxNewIndexSoFar?maxNewIndexSoFar=newIndex:moved=!0,patch(prevChild,c2[newIndex],container,null,parentComponent,parentSuspense,namespace,slotScopeIds,optimized),patched++)}const increasingNewIndexSequence=moved?getSequence(newIndexToOldIndexMap):EMPTY_ARR;for(j=increasingNewIndexSequence.length-1,i=toBePatched-1;i>=0;i--){const nextIndex=s2+i,nextChild=c2[nextIndex],anchorVNode=c2[nextIndex+1],anchor=nextIndex+1<l2?anchorVNode.el||anchorVNode.placeholder:parentAnchor;newIndexToOldIndexMap[i]===0?patch(null,nextChild,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized):moved&&(j<0||i!==increasingNewIndexSequence[j]?move(nextChild,container,anchor,2):j--)}}},"patchKeyedChildren"),move=__name((vnode,container,anchor,moveType,parentSuspense=null)=>{const{el,type,transition,children,shapeFlag}=vnode;if(shapeFlag&6){move(vnode.component.subTree,container,anchor,moveType);return}if(shapeFlag&128){vnode.suspense.move(container,anchor,moveType);return}if(shapeFlag&64){type.move(vnode,container,anchor,internals);return}if(type===Fragment){hostInsert(el,container,anchor);for(let i=0;i<children.length;i++)move(children[i],container,anchor,moveType);hostInsert(vnode.anchor,container,anchor);return}if(type===Static){moveStaticNode(vnode,container,anchor);return}if(moveType!==2&&shapeFlag&1&&transition)if(moveType===0)transition.beforeEnter(el),hostInsert(el,container,anchor),queuePostRenderEffect(()=>transition.enter(el),parentSuspense);else{const{leave,delayLeave,afterLeave}=transition,remove22=__name(()=>{vnode.ctx.isUnmounted?hostRemove(el):hostInsert(el,container,anchor)},"remove22"),performLeave=__name(()=>{leave(el,()=>{remove22(),afterLeave&&afterLeave()})},"performLeave");delayLeave?delayLeave(el,remove22,performLeave):performLeave()}else hostInsert(el,container,anchor)},"move"),unmount=__name((vnode,parentComponent,parentSuspense,doRemove=!1,optimized=!1)=>{const{type,props,ref:ref3,children,dynamicChildren,shapeFlag,patchFlag,dirs,cacheIndex}=vnode;if(patchFlag===-2&&(optimized=!1),ref3!=null&&(pauseTracking(),setRef(ref3,null,parentSuspense,vnode,!0),resetTracking()),cacheIndex!=null&&(parentComponent.renderCache[cacheIndex]=void 0),shapeFlag&256){parentComponent.ctx.deactivate(vnode);return}const shouldInvokeDirs=shapeFlag&1&&dirs,shouldInvokeVnodeHook=!isAsyncWrapper(vnode);let vnodeHook;if(shouldInvokeVnodeHook&&(vnodeHook=props&&props.onVnodeBeforeUnmount)&&invokeVNodeHook(vnodeHook,parentComponent,vnode),shapeFlag&6)unmountComponent(vnode.component,parentSuspense,doRemove);else{if(shapeFlag&128){vnode.suspense.unmount(parentSuspense,doRemove);return}shouldInvokeDirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeUnmount"),shapeFlag&64?vnode.type.remove(vnode,parentComponent,parentSuspense,internals,doRemove):dynamicChildren&&!dynamicChildren.hasOnce&&(type!==Fragment||patchFlag>0&&patchFlag&64)?unmountChildren(dynamicChildren,parentComponent,parentSuspense,!1,!0):(type===Fragment&&patchFlag&384||!optimized&&shapeFlag&16)&&unmountChildren(children,parentComponent,parentSuspense),doRemove&&remove2(vnode)}(shouldInvokeVnodeHook&&(vnodeHook=props&&props.onVnodeUnmounted)||shouldInvokeDirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,vnode),shouldInvokeDirs&&invokeDirectiveHook(vnode,null,parentComponent,"unmounted")},parentSuspense)},"unmount"),remove2=__name(vnode=>{const{type,el,anchor,transition}=vnode;if(type===Fragment){removeFragment(el,anchor);return}if(type===Static){removeStaticNode(vnode);return}const performRemove=__name(()=>{hostRemove(el),transition&&!transition.persisted&&transition.afterLeave&&transition.afterLeave()},"performRemove");if(vnode.shapeFlag&1&&transition&&!transition.persisted){const{leave,delayLeave}=transition,performLeave=__name(()=>leave(el,performRemove),"performLeave");delayLeave?delayLeave(vnode.el,performRemove,performLeave):performLeave()}else performRemove()},"remove2"),removeFragment=__name((cur,end)=>{let next;for(;cur!==end;)next=hostNextSibling(cur),hostRemove(cur),cur=next;hostRemove(end)},"removeFragment"),unmountComponent=__name((instance,parentSuspense,doRemove)=>{const{bum,scope,job,subTree,um,m,a,parent,slots:{__:slotCacheKeys}}=instance;invalidateMount(m),invalidateMount(a),bum&&invokeArrayFns(bum),parent&&isArray$1(slotCacheKeys)&&slotCacheKeys.forEach(v=>{parent.renderCache[v]=void 0}),scope.stop(),job&&(job.flags|=8,unmount(subTree,instance,parentSuspense,doRemove)),um&&queuePostRenderEffect(um,parentSuspense),queuePostRenderEffect(()=>{instance.isUnmounted=!0},parentSuspense),parentSuspense&&parentSuspense.pendingBranch&&!parentSuspense.isUnmounted&&instance.asyncDep&&!instance.asyncResolved&&instance.suspenseId===parentSuspense.pendingId&&(parentSuspense.deps--,parentSuspense.deps===0&&parentSuspense.resolve())},"unmountComponent"),unmountChildren=__name((children,parentComponent,parentSuspense,doRemove=!1,optimized=!1,start=0)=>{for(let i=start;i<children.length;i++)unmount(children[i],parentComponent,parentSuspense,doRemove,optimized)},"unmountChildren"),getNextHostNode=__name(vnode=>{if(vnode.shapeFlag&6)return getNextHostNode(vnode.component.subTree);if(vnode.shapeFlag&128)return vnode.suspense.next();const el=hostNextSibling(vnode.anchor||vnode.el),teleportEnd=el&&el[TeleportEndKey];return teleportEnd?hostNextSibling(teleportEnd):el},"getNextHostNode");let isFlushing=!1;const render2=__name((vnode,container,namespace)=>{vnode==null?container._vnode&&unmount(container._vnode,null,null,!0):patch(container._vnode||null,vnode,container,null,null,null,namespace),container._vnode=vnode,isFlushing||(isFlushing=!0,flushPreFlushCbs(),flushPostFlushCbs(),isFlushing=!1)},"render"),internals={p:patch,um:unmount,m:move,r:remove2,mt:mountComponent,mc:mountChildren,pc:patchChildren,pbc:patchBlockChildren,n:getNextHostNode,o:options};let hydrate2,hydrateNode;return createHydrationFns&&([hydrate2,hydrateNode]=createHydrationFns(internals)),{render:render2,hydrate:hydrate2,createApp:createAppAPI(render2,hydrate2)}}__name(baseCreateRenderer,"baseCreateRenderer");function resolveChildrenNamespace({type,props},currentNamespace){return currentNamespace==="svg"&&type==="foreignObject"||currentNamespace==="mathml"&&type==="annotation-xml"&&props&&props.encoding&&props.encoding.includes("html")?void 0:currentNamespace}__name(resolveChildrenNamespace,"resolveChildrenNamespace");function toggleRecurse({effect:effect2,job},allowed){allowed?(effect2.flags|=32,job.flags|=4):(effect2.flags&=-33,job.flags&=-5)}__name(toggleRecurse,"toggleRecurse");function needTransition(parentSuspense,transition){return(!parentSuspense||parentSuspense&&!parentSuspense.pendingBranch)&&transition&&!transition.persisted}__name(needTransition,"needTransition");function traverseStaticChildren(n1,n2,shallow=!1){const ch1=n1.children,ch2=n2.children;if(isArray$1(ch1)&&isArray$1(ch2))for(let i=0;i<ch1.length;i++){const c1=ch1[i];let c2=ch2[i];c2.shapeFlag&1&&!c2.dynamicChildren&&((c2.patchFlag<=0||c2.patchFlag===32)&&(c2=ch2[i]=cloneIfMounted(ch2[i]),c2.el=c1.el),!shallow&&c2.patchFlag!==-2&&traverseStaticChildren(c1,c2)),c2.type===Text&&(c2.el=c1.el),c2.type===Comment&&!c2.el&&(c2.el=c1.el)}}__name(traverseStaticChildren,"traverseStaticChildren");function getSequence(arr){const p2=arr.slice(),result=[0];let i,j,u,v,c;const len=arr.length;for(i=0;i<len;i++){const arrI=arr[i];if(arrI!==0){if(j=result[result.length-1],arr[j]<arrI){p2[i]=j,result.push(i);continue}for(u=0,v=result.length-1;u<v;)c=u+v>>1,arr[result[c]]<arrI?u=c+1:v=c;arrI<arr[result[u]]&&(u>0&&(p2[i]=result[u-1]),result[u]=i)}}for(u=result.length,v=result[u-1];u-- >0;)result[u]=v,v=p2[v];return result}__name(getSequence,"getSequence");function locateNonHydratedAsyncRoot(instance){const subComponent=instance.subTree.component;if(subComponent)return subComponent.asyncDep&&!subComponent.asyncResolved?subComponent:locateNonHydratedAsyncRoot(subComponent)}__name(locateNonHydratedAsyncRoot,"locateNonHydratedAsyncRoot");function invalidateMount(hooks){if(hooks)for(let i=0;i<hooks.length;i++)hooks[i].flags|=8}__name(invalidateMount,"invalidateMount");const ssrContextKey=Symbol.for("v-scx"),useSSRContext=__name(()=>inject(ssrContextKey),"useSSRContext");function watchEffect(effect2,options){return doWatch(effect2,null,options)}__name(watchEffect,"watchEffect");function watchPostEffect(effect2,options){return doWatch(effect2,null,{flush:"post"})}__name(watchPostEffect,"watchPostEffect");function watchSyncEffect(effect2,options){return doWatch(effect2,null,{flush:"sync"})}__name(watchSyncEffect,"watchSyncEffect");function watch(source,cb,options){return doWatch(source,cb,options)}__name(watch,"watch");function doWatch(source,cb,options=EMPTY_OBJ){const{immediate,deep,flush,once}=options,baseWatchOptions=extend({},options),runsImmediately=cb&&immediate||!cb&&flush!=="post";let ssrCleanup;if(isInSSRComponentSetup){if(flush==="sync"){const ctx=useSSRContext();ssrCleanup=ctx.__watcherHandles||(ctx.__watcherHandles=[])}else if(!runsImmediately){const watchStopHandle=__name(()=>{},"watchStopHandle");return watchStopHandle.stop=NOOP,watchStopHandle.resume=NOOP,watchStopHandle.pause=NOOP,watchStopHandle}}const instance=currentInstance;baseWatchOptions.call=(fn,type,args)=>callWithAsyncErrorHandling(fn,instance,type,args);let isPre=!1;flush==="post"?baseWatchOptions.scheduler=job=>{queuePostRenderEffect(job,instance&&instance.suspense)}:flush!=="sync"&&(isPre=!0,baseWatchOptions.scheduler=(job,isFirstRun)=>{isFirstRun?job():queueJob(job)}),baseWatchOptions.augmentJob=job=>{cb&&(job.flags|=4),isPre&&(job.flags|=2,instance&&(job.id=instance.uid,job.i=instance))};const watchHandle=watch$1(source,cb,baseWatchOptions);return isInSSRComponentSetup&&(ssrCleanup?ssrCleanup.push(watchHandle):runsImmediately&&watchHandle()),watchHandle}__name(doWatch,"doWatch");function instanceWatch(source,value,options){const publicThis=this.proxy,getter=isString(source)?source.includes(".")?createPathGetter(publicThis,source):()=>publicThis[source]:source.bind(publicThis,publicThis);let cb;isFunction(value)?cb=value:(cb=value.handler,options=value);const reset=setCurrentInstance(this),res=doWatch(getter,cb.bind(publicThis),options);return reset(),res}__name(instanceWatch,"instanceWatch");function createPathGetter(ctx,path){const segments=path.split(".");return()=>{let cur=ctx;for(let i=0;i<segments.length&&cur;i++)cur=cur[segments[i]];return cur}}__name(createPathGetter,"createPathGetter");function useModel(props,name,options=EMPTY_OBJ){const i=getCurrentInstance(),camelizedName=camelize(name),hyphenatedName=hyphenate(name),modifiers=getModelModifiers(props,camelizedName),res=customRef((track2,trigger2)=>{let localValue,prevSetValue=EMPTY_OBJ,prevEmittedValue;return watchSyncEffect(()=>{const propValue=props[camelizedName];hasChanged(localValue,propValue)&&(localValue=propValue,trigger2())}),{get(){return track2(),options.get?options.get(localValue):localValue},set(value){const emittedValue=options.set?options.set(value):value;if(!hasChanged(emittedValue,localValue)&&!(prevSetValue!==EMPTY_OBJ&&hasChanged(value,prevSetValue)))return;const rawProps=i.vnode.props;rawProps&&(name in rawProps||camelizedName in rawProps||hyphenatedName in rawProps)&&(`onUpdate:${name}`in rawProps||`onUpdate:${camelizedName}`in rawProps||`onUpdate:${hyphenatedName}`in rawProps)||(localValue=value,trigger2()),i.emit(`update:${name}`,emittedValue),hasChanged(value,emittedValue)&&hasChanged(value,prevSetValue)&&!hasChanged(emittedValue,prevEmittedValue)&&trigger2(),prevSetValue=value,prevEmittedValue=emittedValue}}});return res[Symbol.iterator]=()=>{let i2=0;return{next(){return i2<2?{value:i2++?modifiers||EMPTY_OBJ:res,done:!1}:{done:!0}}}},res}__name(useModel,"useModel");const getModelModifiers=__name((props,modelName)=>modelName==="modelValue"||modelName==="model-value"?props.modelModifiers:props[`${modelName}Modifiers`]||props[`${camelize(modelName)}Modifiers`]||props[`${hyphenate(modelName)}Modifiers`],"getModelModifiers");function emit(instance,event,...rawArgs){if(instance.isUnmounted)return;const props=instance.vnode.props||EMPTY_OBJ;let args=rawArgs;const isModelListener2=event.startsWith("update:"),modifiers=isModelListener2&&getModelModifiers(props,event.slice(7));modifiers&&(modifiers.trim&&(args=rawArgs.map(a=>isString(a)?a.trim():a)),modifiers.number&&(args=rawArgs.map(looseToNumber)));let handlerName,handler=props[handlerName=toHandlerKey(event)]||props[handlerName=toHandlerKey(camelize(event))];!handler&&isModelListener2&&(handler=props[handlerName=toHandlerKey(hyphenate(event))]),handler&&callWithAsyncErrorHandling(handler,instance,6,args);const onceHandler=props[handlerName+"Once"];if(onceHandler){if(!instance.emitted)instance.emitted={};else if(instance.emitted[handlerName])return;instance.emitted[handlerName]=!0,callWithAsyncErrorHandling(onceHandler,instance,6,args)}}__name(emit,"emit");function normalizeEmitsOptions(comp,appContext,asMixin=!1){const cache=appContext.emitsCache,cached=cache.get(comp);if(cached!==void 0)return cached;const raw=comp.emits;let normalized={},hasExtends=!1;if(!isFunction(comp)){const extendEmits=__name(raw2=>{const normalizedFromExtend=normalizeEmitsOptions(raw2,appContext,!0);normalizedFromExtend&&(hasExtends=!0,extend(normalized,normalizedFromExtend))},"extendEmits");!asMixin&&appContext.mixins.length&&appContext.mixins.forEach(extendEmits),comp.extends&&extendEmits(comp.extends),comp.mixins&&comp.mixins.forEach(extendEmits)}return!raw&&!hasExtends?(isObject(comp)&&cache.set(comp,null),null):(isArray$1(raw)?raw.forEach(key=>normalized[key]=null):extend(normalized,raw),isObject(comp)&&cache.set(comp,normalized),normalized)}__name(normalizeEmitsOptions,"normalizeEmitsOptions");function isEmitListener(options,key){return!options||!isOn(key)?!1:(key=key.slice(2).replace(/Once$/,""),hasOwn(options,key[0].toLowerCase()+key.slice(1))||hasOwn(options,hyphenate(key))||hasOwn(options,key))}__name(isEmitListener,"isEmitListener");function renderComponentRoot(instance){const{type:Component,vnode,proxy,withProxy,propsOptions:[propsOptions],slots,attrs,emit:emit2,render:render2,renderCache,props,data,setupState,ctx,inheritAttrs}=instance,prev=setCurrentRenderingInstance(instance);let result,fallthroughAttrs;try{if(vnode.shapeFlag&4){const proxyToUse=withProxy||proxy,thisProxy=proxyToUse;result=normalizeVNode(render2.call(thisProxy,proxyToUse,renderCache,props,setupState,data,ctx)),fallthroughAttrs=attrs}else{const render22=Component;result=normalizeVNode(render22.length>1?render22(props,{attrs,slots,emit:emit2}):render22(props,null)),fallthroughAttrs=Component.props?attrs:getFunctionalFallthrough(attrs)}}catch(err){blockStack.length=0,handleError(err,instance,1),result=createVNode(Comment)}let root=result;if(fallthroughAttrs&&inheritAttrs!==!1){const keys=Object.keys(fallthroughAttrs),{shapeFlag}=root;keys.length&&shapeFlag&7&&(propsOptions&&keys.some(isModelListener)&&(fallthroughAttrs=filterModelListeners(fallthroughAttrs,propsOptions)),root=cloneVNode(root,fallthroughAttrs,!1,!0))}return vnode.dirs&&(root=cloneVNode(root,null,!1,!0),root.dirs=root.dirs?root.dirs.concat(vnode.dirs):vnode.dirs),vnode.transition&&setTransitionHooks(root,vnode.transition),result=root,setCurrentRenderingInstance(prev),result}__name(renderComponentRoot,"renderComponentRoot");function filterSingleRoot(children,recurse=!0){let singleRoot;for(let i=0;i<children.length;i++){const child=children[i];if(isVNode(child)){if(child.type!==Comment||child.children==="v-if"){if(singleRoot)return;singleRoot=child}}else return}return singleRoot}__name(filterSingleRoot,"filterSingleRoot");const getFunctionalFallthrough=__name(attrs=>{let res;for(const key in attrs)(key==="class"||key==="style"||isOn(key))&&((res||(res={}))[key]=attrs[key]);return res},"getFunctionalFallthrough"),filterModelListeners=__name((attrs,props)=>{const res={};for(const key in attrs)(!isModelListener(key)||!(key.slice(9)in props))&&(res[key]=attrs[key]);return res},"filterModelListeners");function shouldUpdateComponent(prevVNode,nextVNode,optimized){const{props:prevProps,children:prevChildren,component}=prevVNode,{props:nextProps,children:nextChildren,patchFlag}=nextVNode,emits=component.emitsOptions;if(nextVNode.dirs||nextVNode.transition)return!0;if(optimized&&patchFlag>=0){if(patchFlag&1024)return!0;if(patchFlag&16)return prevProps?hasPropsChanged(prevProps,nextProps,emits):!!nextProps;if(patchFlag&8){const dynamicProps=nextVNode.dynamicProps;for(let i=0;i<dynamicProps.length;i++){const key=dynamicProps[i];if(nextProps[key]!==prevProps[key]&&!isEmitListener(emits,key))return!0}}}else return(prevChildren||nextChildren)&&(!nextChildren||!nextChildren.$stable)?!0:prevProps===nextProps?!1:prevProps?nextProps?hasPropsChanged(prevProps,nextProps,emits):!0:!!nextProps;return!1}__name(shouldUpdateComponent,"shouldUpdateComponent");function hasPropsChanged(prevProps,nextProps,emitsOptions){const nextKeys=Object.keys(nextProps);if(nextKeys.length!==Object.keys(prevProps).length)return!0;for(let i=0;i<nextKeys.length;i++){const key=nextKeys[i];if(nextProps[key]!==prevProps[key]&&!isEmitListener(emitsOptions,key))return!0}return!1}__name(hasPropsChanged,"hasPropsChanged");function updateHOCHostEl({vnode,parent},el){for(;parent;){const root=parent.subTree;if(root.suspense&&root.suspense.activeBranch===vnode&&(root.el=vnode.el),root===vnode)(vnode=parent.vnode).el=el,parent=parent.parent;else break}}__name(updateHOCHostEl,"updateHOCHostEl");const isSuspense=__name(type=>type.__isSuspense,"isSuspense");let suspenseId=0;const SuspenseImpl={name:"Suspense",__isSuspense:!0,process(n1,n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized,rendererInternals){if(n1==null)mountSuspense(n2,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized,rendererInternals);else{if(parentSuspense&&parentSuspense.deps>0&&!n1.suspense.isInFallback){n2.suspense=n1.suspense,n2.suspense.vnode=n2,n2.el=n1.el;return}patchSuspense(n1,n2,container,anchor,parentComponent,namespace,slotScopeIds,optimized,rendererInternals)}},hydrate:hydrateSuspense,normalize:normalizeSuspenseChildren},Suspense=SuspenseImpl;function triggerEvent(vnode,name){const eventListener=vnode.props&&vnode.props[name];isFunction(eventListener)&&eventListener()}__name(triggerEvent,"triggerEvent");function mountSuspense(vnode,container,anchor,parentComponent,parentSuspense,namespace,slotScopeIds,optimized,rendererInternals){const{p:patch,o:{createElement}}=rendererInternals,hiddenContainer=createElement("div"),suspense=vnode.suspense=createSuspenseBoundary(vnode,parentSuspense,parentComponent,container,hiddenContainer,anchor,namespace,slotScopeIds,optimized,rendererInternals);patch(null,suspense.pendingBranch=vnode.ssContent,hiddenContainer,null,parentComponent,suspense,namespace,slotScopeIds),suspense.deps>0?(triggerEvent(vnode,"onPending"),triggerEvent(vnode,"onFallback"),patch(null,vnode.ssFallback,container,anchor,parentComponent,null,namespace,slotScopeIds),setActiveBranch(suspense,vnode.ssFallback)):suspense.resolve(!1,!0)}__name(mountSuspense,"mountSuspense");function patchSuspense(n1,n2,container,anchor,parentComponent,namespace,slotScopeIds,optimized,{p:patch,um:unmount,o:{createElement}}){const suspense=n2.suspense=n1.suspense;suspense.vnode=n2,n2.el=n1.el;const newBranch=n2.ssContent,newFallback=n2.ssFallback,{activeBranch,pendingBranch,isInFallback,isHydrating}=suspense;if(pendingBranch)suspense.pendingBranch=newBranch,isSameVNodeType(newBranch,pendingBranch)?(patch(pendingBranch,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,namespace,slotScopeIds,optimized),suspense.deps<=0?suspense.resolve():isInFallback&&(isHydrating||(patch(activeBranch,newFallback,container,anchor,parentComponent,null,namespace,slotScopeIds,optimized),setActiveBranch(suspense,newFallback)))):(suspense.pendingId=suspenseId++,isHydrating?(suspense.isHydrating=!1,suspense.activeBranch=pendingBranch):unmount(pendingBranch,parentComponent,suspense),suspense.deps=0,suspense.effects.length=0,suspense.hiddenContainer=createElement("div"),isInFallback?(patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,namespace,slotScopeIds,optimized),suspense.deps<=0?suspense.resolve():(patch(activeBranch,newFallback,container,anchor,parentComponent,null,namespace,slotScopeIds,optimized),setActiveBranch(suspense,newFallback))):activeBranch&&isSameVNodeType(newBranch,activeBranch)?(patch(activeBranch,newBranch,container,anchor,parentComponent,suspense,namespace,slotScopeIds,optimized),suspense.resolve(!0)):(patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,namespace,slotScopeIds,optimized),suspense.deps<=0&&suspense.resolve()));else if(activeBranch&&isSameVNodeType(newBranch,activeBranch))patch(activeBranch,newBranch,container,anchor,parentComponent,suspense,namespace,slotScopeIds,optimized),setActiveBranch(suspense,newBranch);else if(triggerEvent(n2,"onPending"),suspense.pendingBranch=newBranch,newBranch.shapeFlag&512?suspense.pendingId=newBranch.component.suspenseId:suspense.pendingId=suspenseId++,patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,namespace,slotScopeIds,optimized),suspense.deps<=0)suspense.resolve();else{const{timeout,pendingId}=suspense;timeout>0?setTimeout(()=>{suspense.pendingId===pendingId&&suspense.fallback(newFallback)},timeout):timeout===0&&suspense.fallback(newFallback)}}__name(patchSuspense,"patchSuspense");function createSuspenseBoundary(vnode,parentSuspense,parentComponent,container,hiddenContainer,anchor,namespace,slotScopeIds,optimized,rendererInternals,isHydrating=!1){const{p:patch,m:move,um:unmount,n:next,o:{parentNode,remove:remove2}}=rendererInternals;let parentSuspenseId;const isSuspensible=isVNodeSuspensible(vnode);isSuspensible&&parentSuspense&&parentSuspense.pendingBranch&&(parentSuspenseId=parentSuspense.pendingId,parentSuspense.deps++);const timeout=vnode.props?toNumber(vnode.props.timeout):void 0,initialAnchor=anchor,suspense={vnode,parent:parentSuspense,parentComponent,namespace,container,hiddenContainer,deps:0,pendingId:suspenseId++,timeout:typeof timeout=="number"?timeout:-1,activeBranch:null,pendingBranch:null,isInFallback:!isHydrating,isHydrating,isUnmounted:!1,effects:[],resolve(resume=!1,sync=!1){const{vnode:vnode2,activeBranch,pendingBranch,pendingId,effects,parentComponent:parentComponent2,container:container2}=suspense;let delayEnter=!1;suspense.isHydrating?suspense.isHydrating=!1:resume||(delayEnter=activeBranch&&pendingBranch.transition&&pendingBranch.transition.mode==="out-in",delayEnter&&(activeBranch.transition.afterLeave=()=>{pendingId===suspense.pendingId&&(move(pendingBranch,container2,anchor===initialAnchor?next(activeBranch):anchor,0),queuePostFlushCb(effects))}),activeBranch&&(parentNode(activeBranch.el)===container2&&(anchor=next(activeBranch)),unmount(activeBranch,parentComponent2,suspense,!0)),delayEnter||move(pendingBranch,container2,anchor,0)),setActiveBranch(suspense,pendingBranch),suspense.pendingBranch=null,suspense.isInFallback=!1;let parent=suspense.parent,hasUnresolvedAncestor=!1;for(;parent;){if(parent.pendingBranch){parent.effects.push(...effects),hasUnresolvedAncestor=!0;break}parent=parent.parent}!hasUnresolvedAncestor&&!delayEnter&&queuePostFlushCb(effects),suspense.effects=[],isSuspensible&&parentSuspense&&parentSuspense.pendingBranch&&parentSuspenseId===parentSuspense.pendingId&&(parentSuspense.deps--,parentSuspense.deps===0&&!sync&&parentSuspense.resolve()),triggerEvent(vnode2,"onResolve")},fallback(fallbackVNode){if(!suspense.pendingBranch)return;const{vnode:vnode2,activeBranch,parentComponent:parentComponent2,container:container2,namespace:namespace2}=suspense;triggerEvent(vnode2,"onFallback");const anchor2=next(activeBranch),mountFallback=__name(()=>{suspense.isInFallback&&(patch(null,fallbackVNode,container2,anchor2,parentComponent2,null,namespace2,slotScopeIds,optimized),setActiveBranch(suspense,fallbackVNode))},"mountFallback"),delayEnter=fallbackVNode.transition&&fallbackVNode.transition.mode==="out-in";delayEnter&&(activeBranch.transition.afterLeave=mountFallback),suspense.isInFallback=!0,unmount(activeBranch,parentComponent2,null,!0),delayEnter||mountFallback()},move(container2,anchor2,type){suspense.activeBranch&&move(suspense.activeBranch,container2,anchor2,type),suspense.container=container2},next(){return suspense.activeBranch&&next(suspense.activeBranch)},registerDep(instance,setupRenderEffect,optimized2){const isInPendingSuspense=!!suspense.pendingBranch;isInPendingSuspense&&suspense.deps++;const hydratedEl=instance.vnode.el;instance.asyncDep.catch(err=>{handleError(err,instance,0)}).then(asyncSetupResult=>{if(instance.isUnmounted||suspense.isUnmounted||suspense.pendingId!==instance.suspenseId)return;instance.asyncResolved=!0;const{vnode:vnode2}=instance;handleSetupResult(instance,asyncSetupResult,!1),hydratedEl&&(vnode2.el=hydratedEl);const placeholder=!hydratedEl&&instance.subTree.el;setupRenderEffect(instance,vnode2,parentNode(hydratedEl||instance.subTree.el),hydratedEl?null:next(instance.subTree),suspense,namespace,optimized2),placeholder&&remove2(placeholder),updateHOCHostEl(instance,vnode2.el),isInPendingSuspense&&--suspense.deps===0&&suspense.resolve()})},unmount(parentSuspense2,doRemove){suspense.isUnmounted=!0,suspense.activeBranch&&unmount(suspense.activeBranch,parentComponent,parentSuspense2,doRemove),suspense.pendingBranch&&unmount(suspense.pendingBranch,parentComponent,parentSuspense2,doRemove)}};return suspense}__name(createSuspenseBoundary,"createSuspenseBoundary");function hydrateSuspense(node,vnode,parentComponent,parentSuspense,namespace,slotScopeIds,optimized,rendererInternals,hydrateNode){const suspense=vnode.suspense=createSuspenseBoundary(vnode,parentSuspense,parentComponent,node.parentNode,document.createElement("div"),null,namespace,slotScopeIds,optimized,rendererInternals,!0),result=hydrateNode(node,suspense.pendingBranch=vnode.ssContent,parentComponent,suspense,slotScopeIds,optimized);return suspense.deps===0&&suspense.resolve(!1,!0),result}__name(hydrateSuspense,"hydrateSuspense");function normalizeSuspenseChildren(vnode){const{shapeFlag,children}=vnode,isSlotChildren=shapeFlag&32;vnode.ssContent=normalizeSuspenseSlot(isSlotChildren?children.default:children),vnode.ssFallback=isSlotChildren?normalizeSuspenseSlot(children.fallback):createVNode(Comment)}__name(normalizeSuspenseChildren,"normalizeSuspenseChildren");function normalizeSuspenseSlot(s){let block;if(isFunction(s)){const trackBlock=isBlockTreeEnabled&&s._c;trackBlock&&(s._d=!1,openBlock()),s=s(),trackBlock&&(s._d=!0,block=currentBlock,closeBlock())}return isArray$1(s)&&(s=filterSingleRoot(s)),s=normalizeVNode(s),block&&!s.dynamicChildren&&(s.dynamicChildren=block.filter(c=>c!==s)),s}__name(normalizeSuspenseSlot,"normalizeSuspenseSlot");function queueEffectWithSuspense(fn,suspense){suspense&&suspense.pendingBranch?isArray$1(fn)?suspense.effects.push(...fn):suspense.effects.push(fn):queuePostFlushCb(fn)}__name(queueEffectWithSuspense,"queueEffectWithSuspense");function setActiveBranch(suspense,branch){suspense.activeBranch=branch;const{vnode,parentComponent}=suspense;let el=branch.el;for(;!el&&branch.component;)branch=branch.component.subTree,el=branch.el;vnode.el=el,parentComponent&&parentComponent.subTree===vnode&&(parentComponent.vnode.el=el,updateHOCHostEl(parentComponent,el))}__name(setActiveBranch,"setActiveBranch");function isVNodeSuspensible(vnode){const suspensible=vnode.props&&vnode.props.suspensible;return suspensible!=null&&suspensible!==!1}__name(isVNodeSuspensible,"isVNodeSuspensible");const Fragment=Symbol.for("v-fgt"),Text=Symbol.for("v-txt"),Comment=Symbol.for("v-cmt"),Static=Symbol.for("v-stc"),blockStack=[];let currentBlock=null;function openBlock(disableTracking=!1){blockStack.push(currentBlock=disableTracking?null:[])}__name(openBlock,"openBlock");function closeBlock(){blockStack.pop(),currentBlock=blockStack[blockStack.length-1]||null}__name(closeBlock,"closeBlock");let isBlockTreeEnabled=1;function setBlockTracking(value,inVOnce=!1){isBlockTreeEnabled+=value,value<0&&currentBlock&&inVOnce&&(currentBlock.hasOnce=!0)}__name(setBlockTracking,"setBlockTracking");function setupBlock(vnode){return vnode.dynamicChildren=isBlockTreeEnabled>0?currentBlock||EMPTY_ARR:null,closeBlock(),isBlockTreeEnabled>0&&currentBlock&&currentBlock.push(vnode),vnode}__name(setupBlock,"setupBlock");function createElementBlock(type,props,children,patchFlag,dynamicProps,shapeFlag){return setupBlock(createBaseVNode(type,props,children,patchFlag,dynamicProps,shapeFlag,!0))}__name(createElementBlock,"createElementBlock");function createBlock(type,props,children,patchFlag,dynamicProps){return setupBlock(createVNode(type,props,children,patchFlag,dynamicProps,!0))}__name(createBlock,"createBlock");function isVNode(value){return value?value.__v_isVNode===!0:!1}__name(isVNode,"isVNode");function isSameVNodeType(n1,n2){return n1.type===n2.type&&n1.key===n2.key}__name(isSameVNodeType,"isSameVNodeType");function transformVNodeArgs(transformer){}__name(transformVNodeArgs,"transformVNodeArgs");const normalizeKey=__name(({key})=>key??null,"normalizeKey"),normalizeRef=__name(({ref:ref3,ref_key,ref_for})=>(typeof ref3=="number"&&(ref3=""+ref3),ref3!=null?isString(ref3)||isRef(ref3)||isFunction(ref3)?{i:currentRenderingInstance,r:ref3,k:ref_key,f:!!ref_for}:ref3:null),"normalizeRef");function createBaseVNode(type,props=null,children=null,patchFlag=0,dynamicProps=null,shapeFlag=type===Fragment?0:1,isBlockNode=!1,needFullChildrenNormalization=!1){const vnode={__v_isVNode:!0,__v_skip:!0,type,props,key:props&&normalizeKey(props),ref:props&&normalizeRef(props),scopeId:currentScopeId,slotScopeIds:null,children,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag,patchFlag,dynamicProps,dynamicChildren:null,appContext:null,ctx:currentRenderingInstance};return needFullChildrenNormalization?(normalizeChildren(vnode,children),shapeFlag&128&&type.normalize(vnode)):children&&(vnode.shapeFlag|=isString(children)?8:16),isBlockTreeEnabled>0&&!isBlockNode&&currentBlock&&(vnode.patchFlag>0||shapeFlag&6)&&vnode.patchFlag!==32&&currentBlock.push(vnode),vnode}__name(createBaseVNode,"createBaseVNode");const createVNode=_createVNode;function _createVNode(type,props=null,children=null,patchFlag=0,dynamicProps=null,isBlockNode=!1){if((!type||type===NULL_DYNAMIC_COMPONENT)&&(type=Comment),isVNode(type)){const cloned=cloneVNode(type,props,!0);return children&&normalizeChildren(cloned,children),isBlockTreeEnabled>0&&!isBlockNode&&currentBlock&&(cloned.shapeFlag&6?currentBlock[currentBlock.indexOf(type)]=cloned:currentBlock.push(cloned)),cloned.patchFlag=-2,cloned}if(isClassComponent(type)&&(type=type.__vccOpts),props){props=guardReactiveProps(props);let{class:klass,style}=props;klass&&!isString(klass)&&(props.class=normalizeClass(klass)),isObject(style)&&(isProxy(style)&&!isArray$1(style)&&(style=extend({},style)),props.style=normalizeStyle(style))}const shapeFlag=isString(type)?1:isSuspense(type)?128:isTeleport(type)?64:isObject(type)?4:isFunction(type)?2:0;return createBaseVNode(type,props,children,patchFlag,dynamicProps,shapeFlag,isBlockNode,!0)}__name(_createVNode,"_createVNode");function guardReactiveProps(props){return props?isProxy(props)||isInternalObject(props)?extend({},props):props:null}__name(guardReactiveProps,"guardReactiveProps");function cloneVNode(vnode,extraProps,mergeRef=!1,cloneTransition=!1){const{props,ref:ref3,patchFlag,children,transition}=vnode,mergedProps=extraProps?mergeProps(props||{},extraProps):props,cloned={__v_isVNode:!0,__v_skip:!0,type:vnode.type,props:mergedProps,key:mergedProps&&normalizeKey(mergedProps),ref:extraProps&&extraProps.ref?mergeRef&&ref3?isArray$1(ref3)?ref3.concat(normalizeRef(extraProps)):[ref3,normalizeRef(extraProps)]:normalizeRef(extraProps):ref3,scopeId:vnode.scopeId,slotScopeIds:vnode.slotScopeIds,children,target:vnode.target,targetStart:vnode.targetStart,targetAnchor:vnode.targetAnchor,staticCount:vnode.staticCount,shapeFlag:vnode.shapeFlag,patchFlag:extraProps&&vnode.type!==Fragment?patchFlag===-1?16:patchFlag|16:patchFlag,dynamicProps:vnode.dynamicProps,dynamicChildren:vnode.dynamicChildren,appContext:vnode.appContext,dirs:vnode.dirs,transition,component:vnode.component,suspense:vnode.suspense,ssContent:vnode.ssContent&&cloneVNode(vnode.ssContent),ssFallback:vnode.ssFallback&&cloneVNode(vnode.ssFallback),placeholder:vnode.placeholder,el:vnode.el,anchor:vnode.anchor,ctx:vnode.ctx,ce:vnode.ce};return transition&&cloneTransition&&setTransitionHooks(cloned,transition.clone(cloned)),cloned}__name(cloneVNode,"cloneVNode");function createTextVNode(text=" ",flag=0){return createVNode(Text,null,text,flag)}__name(createTextVNode,"createTextVNode");function createStaticVNode(content,numberOfNodes){const vnode=createVNode(Static,null,content);return vnode.staticCount=numberOfNodes,vnode}__name(createStaticVNode,"createStaticVNode");function createCommentVNode(text="",asBlock=!1){return asBlock?(openBlock(),createBlock(Comment,null,text)):createVNode(Comment,null,text)}__name(createCommentVNode,"createCommentVNode");function normalizeVNode(child){return child==null||typeof child=="boolean"?createVNode(Comment):isArray$1(child)?createVNode(Fragment,null,child.slice()):isVNode(child)?cloneIfMounted(child):createVNode(Text,null,String(child))}__name(normalizeVNode,"normalizeVNode");function cloneIfMounted(child){return child.el===null&&child.patchFlag!==-1||child.memo?child:cloneVNode(child)}__name(cloneIfMounted,"cloneIfMounted");function normalizeChildren(vnode,children){let type=0;const{shapeFlag}=vnode;if(children==null)children=null;else if(isArray$1(children))type=16;else if(typeof children=="object")if(shapeFlag&65){const slot=children.default;slot&&(slot._c&&(slot._d=!1),normalizeChildren(vnode,slot()),slot._c&&(slot._d=!0));return}else{type=32;const slotFlag=children._;!slotFlag&&!isInternalObject(children)?children._ctx=currentRenderingInstance:slotFlag===3&&currentRenderingInstance&&(currentRenderingInstance.slots._===1?children._=1:(children._=2,vnode.patchFlag|=1024))}else isFunction(children)?(children={default:children,_ctx:currentRenderingInstance},type=32):(children=String(children),shapeFlag&64?(type=16,children=[createTextVNode(children)]):type=8);vnode.children=children,vnode.shapeFlag|=type}__name(normalizeChildren,"normalizeChildren");function mergeProps(...args){const ret={};for(let i=0;i<args.length;i++){const toMerge=args[i];for(const key in toMerge)if(key==="class")ret.class!==toMerge.class&&(ret.class=normalizeClass([ret.class,toMerge.class]));else if(key==="style")ret.style=normalizeStyle([ret.style,toMerge.style]);else if(isOn(key)){const existing=ret[key],incoming=toMerge[key];incoming&&existing!==incoming&&!(isArray$1(existing)&&existing.includes(incoming))&&(ret[key]=existing?[].concat(existing,incoming):incoming)}else key!==""&&(ret[key]=toMerge[key])}return ret}__name(mergeProps,"mergeProps");function invokeVNodeHook(hook,instance,vnode,prevVNode=null){callWithAsyncErrorHandling(hook,instance,7,[vnode,prevVNode])}__name(invokeVNodeHook,"invokeVNodeHook");const emptyAppContext=createAppContext();let uid=0;function createComponentInstance(vnode,parent,suspense){const type=vnode.type,appContext=(parent?parent.appContext:vnode.appContext)||emptyAppContext,instance={uid:uid++,vnode,type,parent,appContext,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new EffectScope(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:parent?parent.provides:Object.create(appContext.provides),ids:parent?parent.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:normalizePropsOptions(type,appContext),emitsOptions:normalizeEmitsOptions(type,appContext),emit:null,emitted:null,propsDefaults:EMPTY_OBJ,inheritAttrs:type.inheritAttrs,ctx:EMPTY_OBJ,data:EMPTY_OBJ,props:EMPTY_OBJ,attrs:EMPTY_OBJ,slots:EMPTY_OBJ,refs:EMPTY_OBJ,setupState:EMPTY_OBJ,setupContext:null,suspense,suspenseId:suspense?suspense.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return instance.ctx={_:instance},instance.root=parent?parent.root:instance,instance.emit=emit.bind(null,instance),vnode.ce&&vnode.ce(instance),instance}__name(createComponentInstance,"createComponentInstance");let currentInstance=null;const getCurrentInstance=__name(()=>currentInstance||currentRenderingInstance,"getCurrentInstance");let internalSetCurrentInstance,setInSSRSetupState;{const g=getGlobalThis(),registerGlobalSetter=__name((key,setter)=>{let setters;return(setters=g[key])||(setters=g[key]=[]),setters.push(setter),v=>{setters.length>1?setters.forEach(set=>set(v)):setters[0](v)}},"registerGlobalSetter");internalSetCurrentInstance=registerGlobalSetter("__VUE_INSTANCE_SETTERS__",v=>currentInstance=v),setInSSRSetupState=registerGlobalSetter("__VUE_SSR_SETTERS__",v=>isInSSRComponentSetup=v)}const setCurrentInstance=__name(instance=>{const prev=currentInstance;return internalSetCurrentInstance(instance),instance.scope.on(),()=>{instance.scope.off(),internalSetCurrentInstance(prev)}},"setCurrentInstance"),unsetCurrentInstance=__name(()=>{currentInstance&&currentInstance.scope.off(),internalSetCurrentInstance(null)},"unsetCurrentInstance");function isStatefulComponent(instance){return instance.vnode.shapeFlag&4}__name(isStatefulComponent,"isStatefulComponent");let isInSSRComponentSetup=!1;function setupComponent(instance,isSSR=!1,optimized=!1){isSSR&&setInSSRSetupState(isSSR);const{props,children}=instance.vnode,isStateful=isStatefulComponent(instance);initProps(instance,props,isStateful,isSSR),initSlots(instance,children,optimized||isSSR);const setupResult=isStateful?setupStatefulComponent(instance,isSSR):void 0;return isSSR&&setInSSRSetupState(!1),setupResult}__name(setupComponent,"setupComponent");function setupStatefulComponent(instance,isSSR){const Component=instance.type;instance.accessCache=Object.create(null),instance.proxy=new Proxy(instance.ctx,PublicInstanceProxyHandlers);const{setup}=Component;if(setup){pauseTracking();const setupContext=instance.setupContext=setup.length>1?createSetupContext(instance):null,reset=setCurrentInstance(instance),setupResult=callWithErrorHandling(setup,instance,0,[instance.props,setupContext]),isAsyncSetup=isPromise(setupResult);if(resetTracking(),reset(),(isAsyncSetup||instance.sp)&&!isAsyncWrapper(instance)&&markAsyncBoundary(instance),isAsyncSetup){if(setupResult.then(unsetCurrentInstance,unsetCurrentInstance),isSSR)return setupResult.then(resolvedResult=>{handleSetupResult(instance,resolvedResult,isSSR)}).catch(e=>{handleError(e,instance,0)});instance.asyncDep=setupResult}else handleSetupResult(instance,setupResult,isSSR)}else finishComponentSetup(instance,isSSR)}__name(setupStatefulComponent,"setupStatefulComponent");function handleSetupResult(instance,setupResult,isSSR){isFunction(setupResult)?instance.type.__ssrInlineRender?instance.ssrRender=setupResult:instance.render=setupResult:isObject(setupResult)&&(instance.setupState=proxyRefs(setupResult)),finishComponentSetup(instance,isSSR)}__name(handleSetupResult,"handleSetupResult");let compile$1,installWithProxy;function registerRuntimeCompiler(_compile){compile$1=_compile,installWithProxy=__name(i=>{i.render._rc&&(i.withProxy=new Proxy(i.ctx,RuntimeCompiledPublicInstanceProxyHandlers))},"installWithProxy")}__name(registerRuntimeCompiler,"registerRuntimeCompiler");const isRuntimeOnly=__name(()=>!compile$1,"isRuntimeOnly");function finishComponentSetup(instance,isSSR,skipOptions){const Component=instance.type;if(!instance.render){if(!isSSR&&compile$1&&!Component.render){const template=Component.template||resolveMergedOptions(instance).template;if(template){const{isCustomElement,compilerOptions}=instance.appContext.config,{delimiters,compilerOptions:componentCompilerOptions}=Component,finalCompilerOptions=extend(extend({isCustomElement,delimiters},compilerOptions),componentCompilerOptions);Component.render=compile$1(template,finalCompilerOptions)}}instance.render=Component.render||NOOP,installWithProxy&&installWithProxy(instance)}{const reset=setCurrentInstance(instance);pauseTracking();try{applyOptions(instance)}finally{resetTracking(),reset()}}}__name(finishComponentSetup,"finishComponentSetup");const attrsProxyHandlers={get(target,key){return track(target,"get",""),target[key]}};function createSetupContext(instance){const expose=__name(exposed=>{instance.exposed=exposed||{}},"expose");return{attrs:new Proxy(instance.attrs,attrsProxyHandlers),slots:instance.slots,emit:instance.emit,expose}}__name(createSetupContext,"createSetupContext");function getComponentPublicInstance(instance){return instance.exposed?instance.exposeProxy||(instance.exposeProxy=new Proxy(proxyRefs(markRaw(instance.exposed)),{get(target,key){if(key in target)return target[key];if(key in publicPropertiesMap)return publicPropertiesMap[key](instance)},has(target,key){return key in target||key in publicPropertiesMap}})):instance.proxy}__name(getComponentPublicInstance,"getComponentPublicInstance");function getComponentName(Component,includeInferred=!0){return isFunction(Component)?Component.displayName||Component.name:Component.name||includeInferred&&Component.__name}__name(getComponentName,"getComponentName");function isClassComponent(value){return isFunction(value)&&"__vccOpts"in value}__name(isClassComponent,"isClassComponent");const computed=__name((getterOrOptions,debugOptions)=>computed$1(getterOrOptions,debugOptions,isInSSRComponentSetup),"computed");function h(type,propsOrChildren,children){const l=arguments.length;return l===2?isObject(propsOrChildren)&&!isArray$1(propsOrChildren)?isVNode(propsOrChildren)?createVNode(type,null,[propsOrChildren]):createVNode(type,propsOrChildren):createVNode(type,null,propsOrChildren):(l>3?children=Array.prototype.slice.call(arguments,2):l===3&&isVNode(children)&&(children=[children]),createVNode(type,propsOrChildren,children))}__name(h,"h");function initCustomFormatter(){}__name(initCustomFormatter,"initCustomFormatter");function withMemo(memo,render2,cache,index){const cached=cache[index];if(cached&&isMemoSame(cached,memo))return cached;const ret=render2();return ret.memo=memo.slice(),ret.cacheIndex=index,cache[index]=ret}__name(withMemo,"withMemo");function isMemoSame(cached,memo){const prev=cached.memo;if(prev.length!=memo.length)return!1;for(let i=0;i<prev.length;i++)if(hasChanged(prev[i],memo[i]))return!1;return isBlockTreeEnabled>0&&currentBlock&&currentBlock.push(cached),!0}__name(isMemoSame,"isMemoSame");const version="3.5.18",warn=NOOP,ErrorTypeStrings=ErrorTypeStrings$1,devtools=devtools$1,setDevtoolsHook=setDevtoolsHook$1,_ssrUtils={createComponentInstance,setupComponent,renderComponentRoot,setCurrentRenderingInstance,isVNode,normalizeVNode,getComponentPublicInstance,ensureValidVNode,pushWarningContext,popWarningContext},ssrUtils=_ssrUtils,resolveFilter=null,compatUtils=null,DeprecationTypes=null;/**
* @vue/runtime-dom v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let policy;const tt=typeof window<"u"&&window.trustedTypes;if(tt)try{policy=tt.createPolicy("vue",{createHTML:__name(val=>val,"createHTML")})}catch{}const unsafeToTrustedHTML=policy?val=>policy.createHTML(val):val=>val,svgNS="http://www.w3.org/2000/svg",mathmlNS="http://www.w3.org/1998/Math/MathML",doc=typeof document<"u"?document:null,templateContainer=doc&&doc.createElement("template"),nodeOps={insert:__name((child,parent,anchor)=>{parent.insertBefore(child,anchor||null)},"insert"),remove:__name(child=>{const parent=child.parentNode;parent&&parent.removeChild(child)},"remove"),createElement:__name((tag,namespace,is,props)=>{const el=namespace==="svg"?doc.createElementNS(svgNS,tag):namespace==="mathml"?doc.createElementNS(mathmlNS,tag):is?doc.createElement(tag,{is}):doc.createElement(tag);return tag==="select"&&props&&props.multiple!=null&&el.setAttribute("multiple",props.multiple),el},"createElement"),createText:__name(text=>doc.createTextNode(text),"createText"),createComment:__name(text=>doc.createComment(text),"createComment"),setText:__name((node,text)=>{node.nodeValue=text},"setText"),setElementText:__name((el,text)=>{el.textContent=text},"setElementText"),parentNode:__name(node=>node.parentNode,"parentNode"),nextSibling:__name(node=>node.nextSibling,"nextSibling"),querySelector:__name(selector=>doc.querySelector(selector),"querySelector"),setScopeId(el,id){el.setAttribute(id,"")},insertStaticContent(content,parent,anchor,namespace,start,end){const before=anchor?anchor.previousSibling:parent.lastChild;if(start&&(start===end||start.nextSibling))for(;parent.insertBefore(start.cloneNode(!0),anchor),!(start===end||!(start=start.nextSibling)););else{templateContainer.innerHTML=unsafeToTrustedHTML(namespace==="svg"?`<svg>${content}</svg>`:namespace==="mathml"?`<math>${content}</math>`:content);const template=templateContainer.content;if(namespace==="svg"||namespace==="mathml"){const wrapper=template.firstChild;for(;wrapper.firstChild;)template.appendChild(wrapper.firstChild);template.removeChild(wrapper)}parent.insertBefore(template,anchor)}return[before?before.nextSibling:parent.firstChild,anchor?anchor.previousSibling:parent.lastChild]}},TRANSITION="transition",ANIMATION="animation",vtcKey=Symbol("_vtc"),DOMTransitionPropsValidators={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},TransitionPropsValidators=extend({},BaseTransitionPropsValidators,DOMTransitionPropsValidators),decorate$1=__name(t=>(t.displayName="Transition",t.props=TransitionPropsValidators,t),"decorate$1"),Transition=decorate$1((props,{slots})=>h(BaseTransition,resolveTransitionProps(props),slots)),callHook=__name((hook,args=[])=>{isArray$1(hook)?hook.forEach(h2=>h2(...args)):hook&&hook(...args)},"callHook"),hasExplicitCallback=__name(hook=>hook?isArray$1(hook)?hook.some(h2=>h2.length>1):hook.length>1:!1,"hasExplicitCallback");function resolveTransitionProps(rawProps){const baseProps={};for(const key in rawProps)key in DOMTransitionPropsValidators||(baseProps[key]=rawProps[key]);if(rawProps.css===!1)return baseProps;const{name="v",type,duration,enterFromClass=`${name}-enter-from`,enterActiveClass=`${name}-enter-active`,enterToClass=`${name}-enter-to`,appearFromClass=enterFromClass,appearActiveClass=enterActiveClass,appearToClass=enterToClass,leaveFromClass=`${name}-leave-from`,leaveActiveClass=`${name}-leave-active`,leaveToClass=`${name}-leave-to`}=rawProps,durations=normalizeDuration(duration),enterDuration=durations&&durations[0],leaveDuration=durations&&durations[1],{onBeforeEnter,onEnter,onEnterCancelled,onLeave,onLeaveCancelled,onBeforeAppear=onBeforeEnter,onAppear=onEnter,onAppearCancelled=onEnterCancelled}=baseProps,finishEnter=__name((el,isAppear,done,isCancelled)=>{el._enterCancelled=isCancelled,removeTransitionClass(el,isAppear?appearToClass:enterToClass),removeTransitionClass(el,isAppear?appearActiveClass:enterActiveClass),done&&done()},"finishEnter"),finishLeave=__name((el,done)=>{el._isLeaving=!1,removeTransitionClass(el,leaveFromClass),removeTransitionClass(el,leaveToClass),removeTransitionClass(el,leaveActiveClass),done&&done()},"finishLeave"),makeEnterHook=__name(isAppear=>(el,done)=>{const hook=isAppear?onAppear:onEnter,resolve2=__name(()=>finishEnter(el,isAppear,done),"resolve");callHook(hook,[el,resolve2]),nextFrame(()=>{removeTransitionClass(el,isAppear?appearFromClass:enterFromClass),addTransitionClass(el,isAppear?appearToClass:enterToClass),hasExplicitCallback(hook)||whenTransitionEnds(el,type,enterDuration,resolve2)})},"makeEnterHook");return extend(baseProps,{onBeforeEnter(el){callHook(onBeforeEnter,[el]),addTransitionClass(el,enterFromClass),addTransitionClass(el,enterActiveClass)},onBeforeAppear(el){callHook(onBeforeAppear,[el]),addTransitionClass(el,appearFromClass),addTransitionClass(el,appearActiveClass)},onEnter:makeEnterHook(!1),onAppear:makeEnterHook(!0),onLeave(el,done){el._isLeaving=!0;const resolve2=__name(()=>finishLeave(el,done),"resolve");addTransitionClass(el,leaveFromClass),el._enterCancelled?(addTransitionClass(el,leaveActiveClass),forceReflow()):(forceReflow(),addTransitionClass(el,leaveActiveClass)),nextFrame(()=>{el._isLeaving&&(removeTransitionClass(el,leaveFromClass),addTransitionClass(el,leaveToClass),hasExplicitCallback(onLeave)||whenTransitionEnds(el,type,leaveDuration,resolve2))}),callHook(onLeave,[el,resolve2])},onEnterCancelled(el){finishEnter(el,!1,void 0,!0),callHook(onEnterCancelled,[el])},onAppearCancelled(el){finishEnter(el,!0,void 0,!0),callHook(onAppearCancelled,[el])},onLeaveCancelled(el){finishLeave(el),callHook(onLeaveCancelled,[el])}})}__name(resolveTransitionProps,"resolveTransitionProps");function normalizeDuration(duration){if(duration==null)return null;if(isObject(duration))return[NumberOf(duration.enter),NumberOf(duration.leave)];{const n=NumberOf(duration);return[n,n]}}__name(normalizeDuration,"normalizeDuration");function NumberOf(val){return toNumber(val)}__name(NumberOf,"NumberOf");function addTransitionClass(el,cls){cls.split(/\s+/).forEach(c=>c&&el.classList.add(c)),(el[vtcKey]||(el[vtcKey]=new Set)).add(cls)}__name(addTransitionClass,"addTransitionClass");function removeTransitionClass(el,cls){cls.split(/\s+/).forEach(c=>c&&el.classList.remove(c));const _vtc=el[vtcKey];_vtc&&(_vtc.delete(cls),_vtc.size||(el[vtcKey]=void 0))}__name(removeTransitionClass,"removeTransitionClass");function nextFrame(cb){requestAnimationFrame(()=>{requestAnimationFrame(cb)})}__name(nextFrame,"nextFrame");let endId=0;function whenTransitionEnds(el,expectedType,explicitTimeout,resolve2){const id=el._endId=++endId,resolveIfNotStale=__name(()=>{id===el._endId&&resolve2()},"resolveIfNotStale");if(explicitTimeout!=null)return setTimeout(resolveIfNotStale,explicitTimeout);const{type,timeout,propCount}=getTransitionInfo(el,expectedType);if(!type)return resolve2();const endEvent=type+"end";let ended=0;const end=__name(()=>{el.removeEventListener(endEvent,onEnd),resolveIfNotStale()},"end"),onEnd=__name(e=>{e.target===el&&++ended>=propCount&&end()},"onEnd");setTimeout(()=>{ended<propCount&&end()},timeout+1),el.addEventListener(endEvent,onEnd)}__name(whenTransitionEnds,"whenTransitionEnds");function getTransitionInfo(el,expectedType){const styles=window.getComputedStyle(el),getStyleProperties=__name(key=>(styles[key]||"").split(", "),"getStyleProperties"),transitionDelays=getStyleProperties(`${TRANSITION}Delay`),transitionDurations=getStyleProperties(`${TRANSITION}Duration`),transitionTimeout=getTimeout(transitionDelays,transitionDurations),animationDelays=getStyleProperties(`${ANIMATION}Delay`),animationDurations=getStyleProperties(`${ANIMATION}Duration`),animationTimeout=getTimeout(animationDelays,animationDurations);let type=null,timeout=0,propCount=0;expectedType===TRANSITION?transitionTimeout>0&&(type=TRANSITION,timeout=transitionTimeout,propCount=transitionDurations.length):expectedType===ANIMATION?animationTimeout>0&&(type=ANIMATION,timeout=animationTimeout,propCount=animationDurations.length):(timeout=Math.max(transitionTimeout,animationTimeout),type=timeout>0?transitionTimeout>animationTimeout?TRANSITION:ANIMATION:null,propCount=type?type===TRANSITION?transitionDurations.length:animationDurations.length:0);const hasTransform=type===TRANSITION&&/\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());return{type,timeout,propCount,hasTransform}}__name(getTransitionInfo,"getTransitionInfo");function getTimeout(delays,durations){for(;delays.length<durations.length;)delays=delays.concat(delays);return Math.max(...durations.map((d,i)=>toMs(d)+toMs(delays[i])))}__name(getTimeout,"getTimeout");function toMs(s){return s==="auto"?0:Number(s.slice(0,-1).replace(",","."))*1e3}__name(toMs,"toMs");function forceReflow(){return document.body.offsetHeight}__name(forceReflow,"forceReflow");function patchClass(el,value,isSVG){const transitionClasses=el[vtcKey];transitionClasses&&(value=(value?[value,...transitionClasses]:[...transitionClasses]).join(" ")),value==null?el.removeAttribute("class"):isSVG?el.setAttribute("class",value):el.className=value}__name(patchClass,"patchClass");const vShowOriginalDisplay=Symbol("_vod"),vShowHidden=Symbol("_vsh"),vShow={beforeMount(el,{value},{transition}){el[vShowOriginalDisplay]=el.style.display==="none"?"":el.style.display,transition&&value?transition.beforeEnter(el):setDisplay(el,value)},mounted(el,{value},{transition}){transition&&value&&transition.enter(el)},updated(el,{value,oldValue},{transition}){!value!=!oldValue&&(transition?value?(transition.beforeEnter(el),setDisplay(el,!0),transition.enter(el)):transition.leave(el,()=>{setDisplay(el,!1)}):setDisplay(el,value))},beforeUnmount(el,{value}){setDisplay(el,value)}};function setDisplay(el,value){el.style.display=value?el[vShowOriginalDisplay]:"none",el[vShowHidden]=!value}__name(setDisplay,"setDisplay");function initVShowForSSR(){vShow.getSSRProps=({value})=>{if(!value)return{style:{display:"none"}}}}__name(initVShowForSSR,"initVShowForSSR");const CSS_VAR_TEXT=Symbol("");function useCssVars(getter){const instance=getCurrentInstance();if(!instance)return;const updateTeleports=instance.ut=(vars=getter(instance.proxy))=>{Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach(node=>setVarsOnNode(node,vars))},setVars=__name(()=>{const vars=getter(instance.proxy);instance.ce?setVarsOnNode(instance.ce,vars):setVarsOnVNode(instance.subTree,vars),updateTeleports(vars)},"setVars");onBeforeUpdate(()=>{queuePostFlushCb(setVars)}),onMounted(()=>{watch(setVars,NOOP,{flush:"post"});const ob=new MutationObserver(setVars);ob.observe(instance.subTree.el.parentNode,{childList:!0}),onUnmounted(()=>ob.disconnect())})}__name(useCssVars,"useCssVars");function setVarsOnVNode(vnode,vars){if(vnode.shapeFlag&128){const suspense=vnode.suspense;vnode=suspense.activeBranch,suspense.pendingBranch&&!suspense.isHydrating&&suspense.effects.push(()=>{setVarsOnVNode(suspense.activeBranch,vars)})}for(;vnode.component;)vnode=vnode.component.subTree;if(vnode.shapeFlag&1&&vnode.el)setVarsOnNode(vnode.el,vars);else if(vnode.type===Fragment)vnode.children.forEach(c=>setVarsOnVNode(c,vars));else if(vnode.type===Static){let{el,anchor}=vnode;for(;el&&(setVarsOnNode(el,vars),el!==anchor);)el=el.nextSibling}}__name(setVarsOnVNode,"setVarsOnVNode");function setVarsOnNode(el,vars){if(el.nodeType===1){const style=el.style;let cssText="";for(const key in vars){const value=normalizeCssVarValue(vars[key]);style.setProperty(`--${key}`,value),cssText+=`--${key}: ${value};`}style[CSS_VAR_TEXT]=cssText}}__name(setVarsOnNode,"setVarsOnNode");const displayRE=/(^|;)\s*display\s*:/;function patchStyle(el,prev,next){const style=el.style,isCssString=isString(next);let hasControlledDisplay=!1;if(next&&!isCssString){if(prev)if(isString(prev))for(const prevStyle of prev.split(";")){const key=prevStyle.slice(0,prevStyle.indexOf(":")).trim();next[key]==null&&setStyle(style,key,"")}else for(const key in prev)next[key]==null&&setStyle(style,key,"");for(const key in next)key==="display"&&(hasControlledDisplay=!0),setStyle(style,key,next[key])}else if(isCssString){if(prev!==next){const cssVarText=style[CSS_VAR_TEXT];cssVarText&&(next+=";"+cssVarText),style.cssText=next,hasControlledDisplay=displayRE.test(next)}}else prev&&el.removeAttribute("style");vShowOriginalDisplay in el&&(el[vShowOriginalDisplay]=hasControlledDisplay?style.display:"",el[vShowHidden]&&(style.display="none"))}__name(patchStyle,"patchStyle");const importantRE=/\s*!important$/;function setStyle(style,name,val){if(isArray$1(val))val.forEach(v=>setStyle(style,name,v));else if(val==null&&(val=""),name.startsWith("--"))style.setProperty(name,val);else{const prefixed=autoPrefix(style,name);importantRE.test(val)?style.setProperty(hyphenate(prefixed),val.replace(importantRE,""),"important"):style[prefixed]=val}}__name(setStyle,"setStyle");const prefixes=["Webkit","Moz","ms"],prefixCache={};function autoPrefix(style,rawName){const cached=prefixCache[rawName];if(cached)return cached;let name=camelize(rawName);if(name!=="filter"&&name in style)return prefixCache[rawName]=name;name=capitalize(name);for(let i=0;i<prefixes.length;i++){const prefixed=prefixes[i]+name;if(prefixed in style)return prefixCache[rawName]=prefixed}return rawName}__name(autoPrefix,"autoPrefix");const xlinkNS="http://www.w3.org/1999/xlink";function patchAttr(el,key,value,isSVG,instance,isBoolean=isSpecialBooleanAttr(key)){isSVG&&key.startsWith("xlink:")?value==null?el.removeAttributeNS(xlinkNS,key.slice(6,key.length)):el.setAttributeNS(xlinkNS,key,value):value==null||isBoolean&&!includeBooleanAttr(value)?el.removeAttribute(key):el.setAttribute(key,isBoolean?"":isSymbol(value)?String(value):value)}__name(patchAttr,"patchAttr");function patchDOMProp(el,key,value,parentComponent,attrName){if(key==="innerHTML"||key==="textContent"){value!=null&&(el[key]=key==="innerHTML"?unsafeToTrustedHTML(value):value);return}const tag=el.tagName;if(key==="value"&&tag!=="PROGRESS"&&!tag.includes("-")){const oldValue=tag==="OPTION"?el.getAttribute("value")||"":el.value,newValue=value==null?el.type==="checkbox"?"on":"":String(value);(oldValue!==newValue||!("_value"in el))&&(el.value=newValue),value==null&&el.removeAttribute(key),el._value=value;return}let needRemove=!1;if(value===""||value==null){const type=typeof el[key];type==="boolean"?value=includeBooleanAttr(value):value==null&&type==="string"?(value="",needRemove=!0):type==="number"&&(value=0,needRemove=!0)}try{el[key]=value}catch{}needRemove&&el.removeAttribute(attrName||key)}__name(patchDOMProp,"patchDOMProp");function addEventListener(el,event,handler,options){el.addEventListener(event,handler,options)}__name(addEventListener,"addEventListener");function removeEventListener(el,event,handler,options){el.removeEventListener(event,handler,options)}__name(removeEventListener,"removeEventListener");const veiKey=Symbol("_vei");function patchEvent(el,rawName,prevValue,nextValue,instance=null){const invokers=el[veiKey]||(el[veiKey]={}),existingInvoker=invokers[rawName];if(nextValue&&existingInvoker)existingInvoker.value=nextValue;else{const[name,options]=parseName(rawName);if(nextValue){const invoker=invokers[rawName]=createInvoker(nextValue,instance);addEventListener(el,name,invoker,options)}else existingInvoker&&(removeEventListener(el,name,existingInvoker,options),invokers[rawName]=void 0)}}__name(patchEvent,"patchEvent");const optionsModifierRE=/(?:Once|Passive|Capture)$/;function parseName(name){let options;if(optionsModifierRE.test(name)){options={};let m;for(;m=name.match(optionsModifierRE);)name=name.slice(0,name.length-m[0].length),options[m[0].toLowerCase()]=!0}return[name[2]===":"?name.slice(3):hyphenate(name.slice(2)),options]}__name(parseName,"parseName");let cachedNow=0;const p=Promise.resolve(),getNow=__name(()=>cachedNow||(p.then(()=>cachedNow=0),cachedNow=Date.now()),"getNow");function createInvoker(initialValue,instance){const invoker=__name(e=>{if(!e._vts)e._vts=Date.now();else if(e._vts<=invoker.attached)return;callWithAsyncErrorHandling(patchStopImmediatePropagation(e,invoker.value),instance,5,[e])},"invoker");return invoker.value=initialValue,invoker.attached=getNow(),invoker}__name(createInvoker,"createInvoker");function patchStopImmediatePropagation(e,value){if(isArray$1(value)){const originalStop=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{originalStop.call(e),e._stopped=!0},value.map(fn=>e2=>!e2._stopped&&fn&&fn(e2))}else return value}__name(patchStopImmediatePropagation,"patchStopImmediatePropagation");const isNativeOn=__name(key=>key.charCodeAt(0)===111&&key.charCodeAt(1)===110&&key.charCodeAt(2)>96&&key.charCodeAt(2)<123,"isNativeOn"),patchProp=__name((el,key,prevValue,nextValue,namespace,parentComponent)=>{const isSVG=namespace==="svg";key==="class"?patchClass(el,nextValue,isSVG):key==="style"?patchStyle(el,prevValue,nextValue):isOn(key)?isModelListener(key)||patchEvent(el,key,prevValue,nextValue,parentComponent):(key[0]==="."?(key=key.slice(1),!0):key[0]==="^"?(key=key.slice(1),!1):shouldSetAsProp(el,key,nextValue,isSVG))?(patchDOMProp(el,key,nextValue),!el.tagName.includes("-")&&(key==="value"||key==="checked"||key==="selected")&&patchAttr(el,key,nextValue,isSVG,parentComponent,key!=="value")):el._isVueCE&&(/[A-Z]/.test(key)||!isString(nextValue))?patchDOMProp(el,camelize(key),nextValue,parentComponent,key):(key==="true-value"?el._trueValue=nextValue:key==="false-value"&&(el._falseValue=nextValue),patchAttr(el,key,nextValue,isSVG))},"patchProp");function shouldSetAsProp(el,key,value,isSVG){if(isSVG)return!!(key==="innerHTML"||key==="textContent"||key in el&&isNativeOn(key)&&isFunction(value));if(key==="spellcheck"||key==="draggable"||key==="translate"||key==="autocorrect"||key==="form"||key==="list"&&el.tagName==="INPUT"||key==="type"&&el.tagName==="TEXTAREA")return!1;if(key==="width"||key==="height"){const tag=el.tagName;if(tag==="IMG"||tag==="VIDEO"||tag==="CANVAS"||tag==="SOURCE")return!1}return isNativeOn(key)&&isString(value)?!1:key in el}__name(shouldSetAsProp,"shouldSetAsProp");const REMOVAL={};/*! #__NO_SIDE_EFFECTS__ */function defineCustomElement(options,extraOptions,_createApp){const Comp=defineComponent(options,extraOptions);isPlainObject$1(Comp)&&extend(Comp,extraOptions);const _VueCustomElement=class _VueCustomElement extends VueElement{constructor(initialProps){super(Comp,initialProps,_createApp)}};__name(_VueCustomElement,"VueCustomElement");let VueCustomElement=_VueCustomElement;return VueCustomElement.def=Comp,VueCustomElement}__name(defineCustomElement,"defineCustomElement");/*! #__NO_SIDE_EFFECTS__ */const defineSSRCustomElement=__name((options,extraOptions)=>defineCustomElement(options,extraOptions,createSSRApp),"defineSSRCustomElement"),BaseClass=typeof HTMLElement<"u"?HTMLElement:class{},_VueElement=class _VueElement extends BaseClass{constructor(_def,_props={},_createApp=createApp){super(),this._def=_def,this._props=_props,this._createApp=_createApp,this._isVueCE=!0,this._instance=null,this._app=null,this._nonce=this._def.nonce,this._connected=!1,this._resolved=!1,this._numberProps=null,this._styleChildren=new WeakSet,this._ob=null,this.shadowRoot&&_createApp!==createApp?this._root=this.shadowRoot:_def.shadowRoot!==!1?(this.attachShadow({mode:"open"}),this._root=this.shadowRoot):this._root=this}connectedCallback(){if(!this.isConnected)return;!this.shadowRoot&&!this._resolved&&this._parseSlots(),this._connected=!0;let parent=this;for(;parent=parent&&(parent.parentNode||parent.host);)if(parent instanceof _VueElement){this._parent=parent;break}this._instance||(this._resolved?this._mount(this._def):parent&&parent._pendingResolve?this._pendingResolve=parent._pendingResolve.then(()=>{this._pendingResolve=void 0,this._resolveDef()}):this._resolveDef())}_setParent(parent=this._parent){parent&&(this._instance.parent=parent._instance,this._inheritParentContext(parent))}_inheritParentContext(parent=this._parent){parent&&this._app&&Object.setPrototypeOf(this._app._context.provides,parent._instance.provides)}disconnectedCallback(){this._connected=!1,nextTick(()=>{this._connected||(this._ob&&(this._ob.disconnect(),this._ob=null),this._app&&this._app.unmount(),this._instance&&(this._instance.ce=void 0),this._app=this._instance=null)})}_resolveDef(){if(this._pendingResolve)return;for(let i=0;i<this.attributes.length;i++)this._setAttr(this.attributes[i].name);this._ob=new MutationObserver(mutations=>{for(const m of mutations)this._setAttr(m.attributeName)}),this._ob.observe(this,{attributes:!0});const resolve2=__name((def2,isAsync=!1)=>{this._resolved=!0,this._pendingResolve=void 0;const{props,styles}=def2;let numberProps;if(props&&!isArray$1(props))for(const key in props){const opt=props[key];(opt===Number||opt&&opt.type===Number)&&(key in this._props&&(this._props[key]=toNumber(this._props[key])),(numberProps||(numberProps=Object.create(null)))[camelize(key)]=!0)}this._numberProps=numberProps,this._resolveProps(def2),this.shadowRoot&&this._applyStyles(styles),this._mount(def2)},"resolve"),asyncDef=this._def.__asyncLoader;asyncDef?this._pendingResolve=asyncDef().then(def2=>{def2.configureApp=this._def.configureApp,resolve2(this._def=def2,!0)}):resolve2(this._def)}_mount(def2){this._app=this._createApp(def2),this._inheritParentContext(),def2.configureApp&&def2.configureApp(this._app),this._app._ceVNode=this._createVNode(),this._app.mount(this._root);const exposed=this._instance&&this._instance.exposed;if(exposed)for(const key in exposed)hasOwn(this,key)||Object.defineProperty(this,key,{get:__name(()=>unref(exposed[key]),"get")})}_resolveProps(def2){const{props}=def2,declaredPropKeys=isArray$1(props)?props:Object.keys(props||{});for(const key of Object.keys(this))key[0]!=="_"&&declaredPropKeys.includes(key)&&this._setProp(key,this[key]);for(const key of declaredPropKeys.map(camelize))Object.defineProperty(this,key,{get(){return this._getProp(key)},set(val){this._setProp(key,val,!0,!0)}})}_setAttr(key){if(key.startsWith("data-v-"))return;const has=this.hasAttribute(key);let value=has?this.getAttribute(key):REMOVAL;const camelKey=camelize(key);has&&this._numberProps&&this._numberProps[camelKey]&&(value=toNumber(value)),this._setProp(camelKey,value,!1,!0)}_getProp(key){return this._props[key]}_setProp(key,val,shouldReflect=!0,shouldUpdate=!1){if(val!==this._props[key]&&(val===REMOVAL?delete this._props[key]:(this._props[key]=val,key==="key"&&this._app&&(this._app._ceVNode.key=val)),shouldUpdate&&this._instance&&this._update(),shouldReflect)){const ob=this._ob;ob&&ob.disconnect(),val===!0?this.setAttribute(hyphenate(key),""):typeof val=="string"||typeof val=="number"?this.setAttribute(hyphenate(key),val+""):val||this.removeAttribute(hyphenate(key)),ob&&ob.observe(this,{attributes:!0})}}_update(){const vnode=this._createVNode();this._app&&(vnode.appContext=this._app._context),render(vnode,this._root)}_createVNode(){const baseProps={};this.shadowRoot||(baseProps.onVnodeMounted=baseProps.onVnodeUpdated=this._renderSlots.bind(this));const vnode=createVNode(this._def,extend(baseProps,this._props));return this._instance||(vnode.ce=instance=>{this._instance=instance,instance.ce=this,instance.isCE=!0;const dispatch=__name((event,args)=>{this.dispatchEvent(new CustomEvent(event,isPlainObject$1(args[0])?extend({detail:args},args[0]):{detail:args}))},"dispatch");instance.emit=(event,...args)=>{dispatch(event,args),hyphenate(event)!==event&&dispatch(hyphenate(event),args)},this._setParent()}),vnode}_applyStyles(styles,owner){if(!styles)return;if(owner){if(owner===this._def||this._styleChildren.has(owner))return;this._styleChildren.add(owner)}const nonce=this._nonce;for(let i=styles.length-1;i>=0;i--){const s=document.createElement("style");nonce&&s.setAttribute("nonce",nonce),s.textContent=styles[i],this.shadowRoot.prepend(s)}}_parseSlots(){const slots=this._slots={};let n;for(;n=this.firstChild;){const slotName=n.nodeType===1&&n.getAttribute("slot")||"default";(slots[slotName]||(slots[slotName]=[])).push(n),this.removeChild(n)}}_renderSlots(){const outlets=(this._teleportTarget||this).querySelectorAll("slot"),scopeId=this._instance.type.__scopeId;for(let i=0;i<outlets.length;i++){const o=outlets[i],slotName=o.getAttribute("name")||"default",content=this._slots[slotName],parent=o.parentNode;if(content)for(const n of content){if(scopeId&&n.nodeType===1){const id=scopeId+"-s",walker=document.createTreeWalker(n,1);n.setAttribute(id,"");let child;for(;child=walker.nextNode();)child.setAttribute(id,"")}parent.insertBefore(n,o)}else for(;o.firstChild;)parent.insertBefore(o.firstChild,o);parent.removeChild(o)}}_injectChildStyle(comp){this._applyStyles(comp.styles,comp)}_removeChildStyle(comp){}};__name(_VueElement,"VueElement");let VueElement=_VueElement;function useHost(caller){const instance=getCurrentInstance(),el=instance&&instance.ce;return el||null}__name(useHost,"useHost");function useShadowRoot(){const el=useHost();return el&&el.shadowRoot}__name(useShadowRoot,"useShadowRoot");function useCssModule(name="$style"){{const instance=getCurrentInstance();if(!instance)return EMPTY_OBJ;const modules=instance.type.__cssModules;if(!modules)return EMPTY_OBJ;const mod=modules[name];return mod||EMPTY_OBJ}}__name(useCssModule,"useCssModule");const positionMap=new WeakMap,newPositionMap=new WeakMap,moveCbKey=Symbol("_moveCb"),enterCbKey=Symbol("_enterCb"),decorate=__name(t=>(delete t.props.mode,t),"decorate"),TransitionGroupImpl=decorate({name:"TransitionGroup",props:extend({},TransitionPropsValidators,{tag:String,moveClass:String}),setup(props,{slots}){const instance=getCurrentInstance(),state=useTransitionState();let prevChildren,children;return onUpdated(()=>{if(!prevChildren.length)return;const moveClass=props.moveClass||`${props.name||"v"}-move`;if(!hasCSSTransform(prevChildren[0].el,instance.vnode.el,moveClass)){prevChildren=[];return}prevChildren.forEach(callPendingCbs),prevChildren.forEach(recordPosition);const movedChildren=prevChildren.filter(applyTranslation);forceReflow(),movedChildren.forEach(c=>{const el=c.el,style=el.style;addTransitionClass(el,moveClass),style.transform=style.webkitTransform=style.transitionDuration="";const cb=el[moveCbKey]=e=>{e&&e.target!==el||(!e||/transform$/.test(e.propertyName))&&(el.removeEventListener("transitionend",cb),el[moveCbKey]=null,removeTransitionClass(el,moveClass))};el.addEventListener("transitionend",cb)}),prevChildren=[]}),()=>{const rawProps=toRaw(props),cssTransitionProps=resolveTransitionProps(rawProps);let tag=rawProps.tag||Fragment;if(prevChildren=[],children)for(let i=0;i<children.length;i++){const child=children[i];child.el&&child.el instanceof Element&&(prevChildren.push(child),setTransitionHooks(child,resolveTransitionHooks(child,cssTransitionProps,state,instance)),positionMap.set(child,child.el.getBoundingClientRect()))}children=slots.default?getTransitionRawChildren(slots.default()):[];for(let i=0;i<children.length;i++){const child=children[i];child.key!=null&&setTransitionHooks(child,resolveTransitionHooks(child,cssTransitionProps,state,instance))}return createVNode(tag,null,children)}}}),TransitionGroup=TransitionGroupImpl;function callPendingCbs(c){const el=c.el;el[moveCbKey]&&el[moveCbKey](),el[enterCbKey]&&el[enterCbKey]()}__name(callPendingCbs,"callPendingCbs");function recordPosition(c){newPositionMap.set(c,c.el.getBoundingClientRect())}__name(recordPosition,"recordPosition");function applyTranslation(c){const oldPos=positionMap.get(c),newPos=newPositionMap.get(c),dx=oldPos.left-newPos.left,dy=oldPos.top-newPos.top;if(dx||dy){const s=c.el.style;return s.transform=s.webkitTransform=`translate(${dx}px,${dy}px)`,s.transitionDuration="0s",c}}__name(applyTranslation,"applyTranslation");function hasCSSTransform(el,root,moveClass){const clone=el.cloneNode(),_vtc=el[vtcKey];_vtc&&_vtc.forEach(cls=>{cls.split(/\s+/).forEach(c=>c&&clone.classList.remove(c))}),moveClass.split(/\s+/).forEach(c=>c&&clone.classList.add(c)),clone.style.display="none";const container=root.nodeType===1?root:root.parentNode;container.appendChild(clone);const{hasTransform}=getTransitionInfo(clone);return container.removeChild(clone),hasTransform}__name(hasCSSTransform,"hasCSSTransform");const getModelAssigner=__name(vnode=>{const fn=vnode.props["onUpdate:modelValue"]||!1;return isArray$1(fn)?value=>invokeArrayFns(fn,value):fn},"getModelAssigner");function onCompositionStart(e){e.target.composing=!0}__name(onCompositionStart,"onCompositionStart");function onCompositionEnd(e){const target=e.target;target.composing&&(target.composing=!1,target.dispatchEvent(new Event("input")))}__name(onCompositionEnd,"onCompositionEnd");const assignKey=Symbol("_assign"),vModelText={created(el,{modifiers:{lazy,trim,number}},vnode){el[assignKey]=getModelAssigner(vnode);const castToNumber=number||vnode.props&&vnode.props.type==="number";addEventListener(el,lazy?"change":"input",e=>{if(e.target.composing)return;let domValue=el.value;trim&&(domValue=domValue.trim()),castToNumber&&(domValue=looseToNumber(domValue)),el[assignKey](domValue)}),trim&&addEventListener(el,"change",()=>{el.value=el.value.trim()}),lazy||(addEventListener(el,"compositionstart",onCompositionStart),addEventListener(el,"compositionend",onCompositionEnd),addEventListener(el,"change",onCompositionEnd))},mounted(el,{value}){el.value=value??""},beforeUpdate(el,{value,oldValue,modifiers:{lazy,trim,number}},vnode){if(el[assignKey]=getModelAssigner(vnode),el.composing)return;const elValue=(number||el.type==="number")&&!/^0\d/.test(el.value)?looseToNumber(el.value):el.value,newValue=value??"";elValue!==newValue&&(document.activeElement===el&&el.type!=="range"&&(lazy&&value===oldValue||trim&&el.value.trim()===newValue)||(el.value=newValue))}},vModelCheckbox={deep:!0,created(el,_,vnode){el[assignKey]=getModelAssigner(vnode),addEventListener(el,"change",()=>{const modelValue=el._modelValue,elementValue=getValue(el),checked=el.checked,assign2=el[assignKey];if(isArray$1(modelValue)){const index=looseIndexOf(modelValue,elementValue),found=index!==-1;if(checked&&!found)assign2(modelValue.concat(elementValue));else if(!checked&&found){const filtered=[...modelValue];filtered.splice(index,1),assign2(filtered)}}else if(isSet(modelValue)){const cloned=new Set(modelValue);checked?cloned.add(elementValue):cloned.delete(elementValue),assign2(cloned)}else assign2(getCheckboxValue(el,checked))})},mounted:setChecked,beforeUpdate(el,binding,vnode){el[assignKey]=getModelAssigner(vnode),setChecked(el,binding,vnode)}};function setChecked(el,{value,oldValue},vnode){el._modelValue=value;let checked;if(isArray$1(value))checked=looseIndexOf(value,vnode.props.value)>-1;else if(isSet(value))checked=value.has(vnode.props.value);else{if(value===oldValue)return;checked=looseEqual(value,getCheckboxValue(el,!0))}el.checked!==checked&&(el.checked=checked)}__name(setChecked,"setChecked");const vModelRadio={created(el,{value},vnode){el.checked=looseEqual(value,vnode.props.value),el[assignKey]=getModelAssigner(vnode),addEventListener(el,"change",()=>{el[assignKey](getValue(el))})},beforeUpdate(el,{value,oldValue},vnode){el[assignKey]=getModelAssigner(vnode),value!==oldValue&&(el.checked=looseEqual(value,vnode.props.value))}},vModelSelect={deep:!0,created(el,{value,modifiers:{number}},vnode){const isSetModel=isSet(value);addEventListener(el,"change",()=>{const selectedVal=Array.prototype.filter.call(el.options,o=>o.selected).map(o=>number?looseToNumber(getValue(o)):getValue(o));el[assignKey](el.multiple?isSetModel?new Set(selectedVal):selectedVal:selectedVal[0]),el._assigning=!0,nextTick(()=>{el._assigning=!1})}),el[assignKey]=getModelAssigner(vnode)},mounted(el,{value}){setSelected(el,value)},beforeUpdate(el,_binding,vnode){el[assignKey]=getModelAssigner(vnode)},updated(el,{value}){el._assigning||setSelected(el,value)}};function setSelected(el,value){const isMultiple=el.multiple,isArrayValue=isArray$1(value);if(!(isMultiple&&!isArrayValue&&!isSet(value))){for(let i=0,l=el.options.length;i<l;i++){const option=el.options[i],optionValue=getValue(option);if(isMultiple)if(isArrayValue){const optionType=typeof optionValue;optionType==="string"||optionType==="number"?option.selected=value.some(v=>String(v)===String(optionValue)):option.selected=looseIndexOf(value,optionValue)>-1}else option.selected=value.has(optionValue);else if(looseEqual(getValue(option),value)){el.selectedIndex!==i&&(el.selectedIndex=i);return}}!isMultiple&&el.selectedIndex!==-1&&(el.selectedIndex=-1)}}__name(setSelected,"setSelected");function getValue(el){return"_value"in el?el._value:el.value}__name(getValue,"getValue");function getCheckboxValue(el,checked){const key=checked?"_trueValue":"_falseValue";return key in el?el[key]:checked}__name(getCheckboxValue,"getCheckboxValue");const vModelDynamic={created(el,binding,vnode){callModelHook(el,binding,vnode,null,"created")},mounted(el,binding,vnode){callModelHook(el,binding,vnode,null,"mounted")},beforeUpdate(el,binding,vnode,prevVNode){callModelHook(el,binding,vnode,prevVNode,"beforeUpdate")},updated(el,binding,vnode,prevVNode){callModelHook(el,binding,vnode,prevVNode,"updated")}};function resolveDynamicModel(tagName,type){switch(tagName){case"SELECT":return vModelSelect;case"TEXTAREA":return vModelText;default:switch(type){case"checkbox":return vModelCheckbox;case"radio":return vModelRadio;default:return vModelText}}}__name(resolveDynamicModel,"resolveDynamicModel");function callModelHook(el,binding,vnode,prevVNode,hook){const fn=resolveDynamicModel(el.tagName,vnode.props&&vnode.props.type)[hook];fn&&fn(el,binding,vnode,prevVNode)}__name(callModelHook,"callModelHook");function initVModelForSSR(){vModelText.getSSRProps=({value})=>({value}),vModelRadio.getSSRProps=({value},vnode)=>{if(vnode.props&&looseEqual(vnode.props.value,value))return{checked:!0}},vModelCheckbox.getSSRProps=({value},vnode)=>{if(isArray$1(value)){if(vnode.props&&looseIndexOf(value,vnode.props.value)>-1)return{checked:!0}}else if(isSet(value)){if(vnode.props&&value.has(vnode.props.value))return{checked:!0}}else if(value)return{checked:!0}},vModelDynamic.getSSRProps=(binding,vnode)=>{if(typeof vnode.type!="string")return;const modelToUse=resolveDynamicModel(vnode.type.toUpperCase(),vnode.props&&vnode.props.type);if(modelToUse.getSSRProps)return modelToUse.getSSRProps(binding,vnode)}}__name(initVModelForSSR,"initVModelForSSR");const systemModifiers=["ctrl","shift","alt","meta"],modifierGuards={stop:__name(e=>e.stopPropagation(),"stop"),prevent:__name(e=>e.preventDefault(),"prevent"),self:__name(e=>e.target!==e.currentTarget,"self"),ctrl:__name(e=>!e.ctrlKey,"ctrl"),shift:__name(e=>!e.shiftKey,"shift"),alt:__name(e=>!e.altKey,"alt"),meta:__name(e=>!e.metaKey,"meta"),left:__name(e=>"button"in e&&e.button!==0,"left"),middle:__name(e=>"button"in e&&e.button!==1,"middle"),right:__name(e=>"button"in e&&e.button!==2,"right"),exact:__name((e,modifiers)=>systemModifiers.some(m=>e[`${m}Key`]&&!modifiers.includes(m)),"exact")},withModifiers=__name((fn,modifiers)=>{const cache=fn._withMods||(fn._withMods={}),cacheKey=modifiers.join(".");return cache[cacheKey]||(cache[cacheKey]=(event,...args)=>{for(let i=0;i<modifiers.length;i++){const guard=modifierGuards[modifiers[i]];if(guard&&guard(event,modifiers))return}return fn(event,...args)})},"withModifiers"),keyNames={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},withKeys=__name((fn,modifiers)=>{const cache=fn._withKeys||(fn._withKeys={}),cacheKey=modifiers.join(".");return cache[cacheKey]||(cache[cacheKey]=event=>{if(!("key"in event))return;const eventKey=hyphenate(event.key);if(modifiers.some(k=>k===eventKey||keyNames[k]===eventKey))return fn(event)})},"withKeys"),rendererOptions=extend({patchProp},nodeOps);let renderer,enabledHydration=!1;function ensureRenderer(){return renderer||(renderer=createRenderer(rendererOptions))}__name(ensureRenderer,"ensureRenderer");function ensureHydrationRenderer(){return renderer=enabledHydration?renderer:createHydrationRenderer(rendererOptions),enabledHydration=!0,renderer}__name(ensureHydrationRenderer,"ensureHydrationRenderer");const render=__name((...args)=>{ensureRenderer().render(...args)},"render"),hydrate=__name((...args)=>{ensureHydrationRenderer().hydrate(...args)},"hydrate"),createApp=__name((...args)=>{const app=ensureRenderer().createApp(...args),{mount}=app;return app.mount=containerOrSelector=>{const container=normalizeContainer(containerOrSelector);if(!container)return;const component=app._component;!isFunction(component)&&!component.render&&!component.template&&(component.template=container.innerHTML),container.nodeType===1&&(container.textContent="");const proxy=mount(container,!1,resolveRootNamespace(container));return container instanceof Element&&(container.removeAttribute("v-cloak"),container.setAttribute("data-v-app","")),proxy},app},"createApp"),createSSRApp=__name((...args)=>{const app=ensureHydrationRenderer().createApp(...args),{mount}=app;return app.mount=containerOrSelector=>{const container=normalizeContainer(containerOrSelector);if(container)return mount(container,!0,resolveRootNamespace(container))},app},"createSSRApp");function resolveRootNamespace(container){if(container instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&container instanceof MathMLElement)return"mathml"}__name(resolveRootNamespace,"resolveRootNamespace");function normalizeContainer(container){return isString(container)?document.querySelector(container):container}__name(normalizeContainer,"normalizeContainer");let ssrDirectiveInitialized=!1;const initDirectivesForSSR=__name(()=>{ssrDirectiveInitialized||(ssrDirectiveInitialized=!0,initVModelForSSR(),initVShowForSSR())},"initDirectivesForSSR");/**
* vue v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const compile=__name(()=>{},"compile"),vue=Object.freeze(Object.defineProperty({__proto__:null,BaseTransition,BaseTransitionPropsValidators,Comment,DeprecationTypes,EffectScope,ErrorCodes,ErrorTypeStrings,Fragment,KeepAlive,ReactiveEffect,Static,Suspense,Teleport,Text,TrackOpTypes,Transition,TransitionGroup,TriggerOpTypes,VueElement,assertNumber,callWithAsyncErrorHandling,callWithErrorHandling,camelize,capitalize,cloneVNode,compatUtils,compile,computed,createApp,createBlock,createCommentVNode,createElementBlock,createElementVNode:createBaseVNode,createHydrationRenderer,createPropsRestProxy,createRenderer,createSSRApp,createSlots,createStaticVNode,createTextVNode,createVNode,customRef,defineAsyncComponent,defineComponent,defineCustomElement,defineEmits,defineExpose,defineModel,defineOptions,defineProps,defineSSRCustomElement,defineSlots,devtools,effect,effectScope,getCurrentInstance,getCurrentScope,getCurrentWatcher,getTransitionRawChildren,guardReactiveProps,h,handleError,hasInjectionContext,hydrate,hydrateOnIdle,hydrateOnInteraction,hydrateOnMediaQuery,hydrateOnVisible,initCustomFormatter,initDirectivesForSSR,inject,isMemoSame,isProxy,isReactive,isReadonly,isRef,isRuntimeOnly,isShallow,isVNode,markRaw,mergeDefaults,mergeModels,mergeProps,nextTick,normalizeClass,normalizeProps,normalizeStyle,onActivated,onBeforeMount,onBeforeUnmount,onBeforeUpdate,onDeactivated,onErrorCaptured,onMounted,onRenderTracked,onRenderTriggered,onScopeDispose,onServerPrefetch,onUnmounted,onUpdated,onWatcherCleanup,openBlock,popScopeId,provide,proxyRefs,pushScopeId,queuePostFlushCb,reactive,readonly,ref,registerRuntimeCompiler,render,renderList,renderSlot,resolveComponent,resolveDirective,resolveDynamicComponent,resolveFilter,resolveTransitionHooks,setBlockTracking,setDevtoolsHook,setTransitionHooks,shallowReactive,shallowReadonly,shallowRef,ssrContextKey,ssrUtils,stop,toDisplayString,toHandlerKey,toHandlers,toRaw,toRef,toRefs,toValue,transformVNodeArgs,triggerRef,unref,useAttrs,useCssModule,useCssVars,useHost,useId,useModel,useSSRContext,useShadowRoot,useSlots,useTemplateRef,useTransitionState,vModelCheckbox,vModelDynamic,vModelRadio,vModelSelect,vModelText,vShow,version,warn,watch,watchEffect,watchPostEffect,watchSyncEffect,withAsyncContext,withCtx,withDefaults,withDirectives,withKeys,withMemo,withModifiers,withScopeId},Symbol.toStringTag,{value:"Module"}));function flatHooks(configHooks,hooks={},parentName){for(const key in configHooks){const subHook=configHooks[key],name=parentName?`${parentName}:${key}`:key;typeof subHook=="object"&&subHook!==null?flatHooks(subHook,hooks,name):typeof subHook=="function"&&(hooks[name]=subHook)}return hooks}__name(flatHooks,"flatHooks");const defaultTask={run:__name(function_=>function_(),"run")},_createTask=__name(()=>defaultTask,"_createTask"),createTask=typeof console.createTask<"u"?console.createTask:_createTask;function serialTaskCaller(hooks,args){const name=args.shift(),task=createTask(name);return hooks.reduce((promise,hookFunction)=>promise.then(()=>task.run(()=>hookFunction(...args))),Promise.resolve())}__name(serialTaskCaller,"serialTaskCaller");function parallelTaskCaller(hooks,args){const name=args.shift(),task=createTask(name);return Promise.all(hooks.map(hook=>task.run(()=>hook(...args))))}__name(parallelTaskCaller,"parallelTaskCaller");function callEachWith(callbacks,arg0){for(const callback of[...callbacks])callback(arg0)}__name(callEachWith,"callEachWith");const _Hookable=class _Hookable{constructor(){this._hooks={},this._before=void 0,this._after=void 0,this._deprecatedMessages=void 0,this._deprecatedHooks={},this.hook=this.hook.bind(this),this.callHook=this.callHook.bind(this),this.callHookWith=this.callHookWith.bind(this)}hook(name,function_,options={}){if(!name||typeof function_!="function")return()=>{};const originalName=name;let dep;for(;this._deprecatedHooks[name];)dep=this._deprecatedHooks[name],name=dep.to;if(dep&&!options.allowDeprecated){let message=dep.message;message||(message=`${originalName} hook has been deprecated`+(dep.to?`, please use ${dep.to}`:"")),this._deprecatedMessages||(this._deprecatedMessages=new Set),this._deprecatedMessages.has(message)||(console.warn(message),this._deprecatedMessages.add(message))}if(!function_.name)try{Object.defineProperty(function_,"name",{get:__name(()=>"_"+name.replace(/\W+/g,"_")+"_hook_cb","get"),configurable:!0})}catch{}return this._hooks[name]=this._hooks[name]||[],this._hooks[name].push(function_),()=>{function_&&(this.removeHook(name,function_),function_=void 0)}}hookOnce(name,function_){let _unreg,_function=__name((...arguments_)=>(typeof _unreg=="function"&&_unreg(),_unreg=void 0,_function=void 0,function_(...arguments_)),"_function");return _unreg=this.hook(name,_function),_unreg}removeHook(name,function_){if(this._hooks[name]){const index=this._hooks[name].indexOf(function_);index!==-1&&this._hooks[name].splice(index,1),this._hooks[name].length===0&&delete this._hooks[name]}}deprecateHook(name,deprecated){this._deprecatedHooks[name]=typeof deprecated=="string"?{to:deprecated}:deprecated;const _hooks=this._hooks[name]||[];delete this._hooks[name];for(const hook of _hooks)this.hook(name,hook)}deprecateHooks(deprecatedHooks){Object.assign(this._deprecatedHooks,deprecatedHooks);for(const name in deprecatedHooks)this.deprecateHook(name,deprecatedHooks[name])}addHooks(configHooks){const hooks=flatHooks(configHooks),removeFns=Object.keys(hooks).map(key=>this.hook(key,hooks[key]));return()=>{for(const unreg of removeFns.splice(0,removeFns.length))unreg()}}removeHooks(configHooks){const hooks=flatHooks(configHooks);for(const key in hooks)this.removeHook(key,hooks[key])}removeAllHooks(){for(const key in this._hooks)delete this._hooks[key]}callHook(name,...arguments_){return arguments_.unshift(name),this.callHookWith(serialTaskCaller,name,...arguments_)}callHookParallel(name,...arguments_){return arguments_.unshift(name),this.callHookWith(parallelTaskCaller,name,...arguments_)}callHookWith(caller,name,...arguments_){const event=this._before||this._after?{name,args:arguments_,context:{}}:void 0;this._before&&callEachWith(this._before,event);const result=caller(name in this._hooks?[...this._hooks[name]]:[],arguments_);return result instanceof Promise?result.finally(()=>{this._after&&event&&callEachWith(this._after,event)}):(this._after&&event&&callEachWith(this._after,event),result)}beforeEach(function_){return this._before=this._before||[],this._before.push(function_),()=>{if(this._before!==void 0){const index=this._before.indexOf(function_);index!==-1&&this._before.splice(index,1)}}}afterEach(function_){return this._after=this._after||[],this._after.push(function_),()=>{if(this._after!==void 0){const index=this._after.indexOf(function_);index!==-1&&this._after.splice(index,1)}}}};__name(_Hookable,"Hookable");let Hookable=_Hookable;function createHooks(){return new Hookable}__name(createHooks,"createHooks");const DEBOUNCE_DEFAULTS={trailing:!0};function debounce(fn,wait=25,options={}){if(options={...DEBOUNCE_DEFAULTS,...options},!Number.isFinite(wait))throw new TypeError("Expected `wait` to be a finite number");let leadingValue,timeout,resolveList=[],currentPromise,trailingArgs;const applyFn=__name((_this,args)=>(currentPromise=_applyPromised(fn,_this,args),currentPromise.finally(()=>{if(currentPromise=null,options.trailing&&trailingArgs&&!timeout){const promise=applyFn(_this,trailingArgs);return trailingArgs=null,promise}}),currentPromise),"applyFn");return function(...args){return currentPromise?(options.trailing&&(trailingArgs=args),currentPromise):new Promise(resolve2=>{const shouldCallNow=!timeout&&options.leading;clearTimeout(timeout),timeout=setTimeout(()=>{timeout=null;const promise=options.leading?leadingValue:applyFn(this,args);for(const _resolve of resolveList)_resolve(promise);resolveList=[]},wait),shouldCallNow?(leadingValue=applyFn(this,args),resolve2(leadingValue)):resolveList.push(resolve2)})}}__name(debounce,"debounce");async function _applyPromised(fn,_this,args){return await fn.apply(_this,args)}__name(_applyPromised,"_applyPromised");/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */let activePinia;const setActivePinia=__name(pinia=>activePinia=pinia,"setActivePinia"),piniaSymbol=Symbol();function isPlainObject(o){return o&&typeof o=="object"&&Object.prototype.toString.call(o)==="[object Object]"&&typeof o.toJSON!="function"}__name(isPlainObject,"isPlainObject");var MutationType;(function(MutationType2){MutationType2.direct="direct",MutationType2.patchObject="patch object",MutationType2.patchFunction="patch function"})(MutationType||(MutationType={}));function createPinia(){const scope=effectScope(!0),state=scope.run(()=>ref({}));let _p=[],toBeInstalled=[];const pinia=markRaw({install(app){setActivePinia(pinia),pinia._a=app,app.provide(piniaSymbol,pinia),app.config.globalProperties.$pinia=pinia,toBeInstalled.forEach(plugin=>_p.push(plugin)),toBeInstalled=[]},use(plugin){return this._a?_p.push(plugin):toBeInstalled.push(plugin),this},_p,_a:null,_e:scope,_s:new Map,state});return pinia}__name(createPinia,"createPinia");const noop$1=__name(()=>{},"noop$1");function addSubscription(subscriptions,callback,detached,onCleanup=noop$1){subscriptions.push(callback);const removeSubscription=__name(()=>{const idx=subscriptions.indexOf(callback);idx>-1&&(subscriptions.splice(idx,1),onCleanup())},"removeSubscription");return!detached&&getCurrentScope()&&onScopeDispose(removeSubscription),removeSubscription}__name(addSubscription,"addSubscription");function triggerSubscriptions(subscriptions,...args){subscriptions.slice().forEach(callback=>{callback(...args)})}__name(triggerSubscriptions,"triggerSubscriptions");const fallbackRunWithContext=__name(fn=>fn(),"fallbackRunWithContext"),ACTION_MARKER=Symbol(),ACTION_NAME=Symbol();function mergeReactiveObjects(target,patchToApply){target instanceof Map&&patchToApply instanceof Map?patchToApply.forEach((value,key)=>target.set(key,value)):target instanceof Set&&patchToApply instanceof Set&&patchToApply.forEach(target.add,target);for(const key in patchToApply){if(!patchToApply.hasOwnProperty(key))continue;const subPatch=patchToApply[key],targetValue=target[key];isPlainObject(targetValue)&&isPlainObject(subPatch)&&target.hasOwnProperty(key)&&!isRef(subPatch)&&!isReactive(subPatch)?target[key]=mergeReactiveObjects(targetValue,subPatch):target[key]=subPatch}return target}__name(mergeReactiveObjects,"mergeReactiveObjects");const skipHydrateSymbol=Symbol();function shouldHydrate(obj){return!isPlainObject(obj)||!Object.prototype.hasOwnProperty.call(obj,skipHydrateSymbol)}__name(shouldHydrate,"shouldHydrate");const{assign:assign$1}=Object;function isComputed(o){return!!(isRef(o)&&o.effect)}__name(isComputed,"isComputed");function createOptionsStore(id,options,pinia,hot){const{state,actions,getters}=options,initialState=pinia.state.value[id];let store;function setup(){initialState||(pinia.state.value[id]=state?state():{});const localState=toRefs(pinia.state.value[id]);return assign$1(localState,actions,Object.keys(getters||{}).reduce((computedGetters,name)=>(computedGetters[name]=markRaw(computed(()=>{setActivePinia(pinia);const store2=pinia._s.get(id);return getters[name].call(store2,store2)})),computedGetters),{}))}return __name(setup,"setup"),store=createSetupStore(id,setup,options,pinia,hot,!0),store}__name(createOptionsStore,"createOptionsStore");function createSetupStore($id,setup,options={},pinia,hot,isOptionsStore){let scope;const optionsForPlugin=assign$1({actions:{}},options),$subscribeOptions={deep:!0};let isListening,isSyncListening,subscriptions=[],actionSubscriptions=[],debuggerEvents;const initialState=pinia.state.value[$id];!isOptionsStore&&!initialState&&(pinia.state.value[$id]={}),ref({});let activeListener;function $patch(partialStateOrMutator){let subscriptionMutation;isListening=isSyncListening=!1,typeof partialStateOrMutator=="function"?(partialStateOrMutator(pinia.state.value[$id]),subscriptionMutation={type:MutationType.patchFunction,storeId:$id,events:debuggerEvents}):(mergeReactiveObjects(pinia.state.value[$id],partialStateOrMutator),subscriptionMutation={type:MutationType.patchObject,payload:partialStateOrMutator,storeId:$id,events:debuggerEvents});const myListenerId=activeListener=Symbol();nextTick().then(()=>{activeListener===myListenerId&&(isListening=!0)}),isSyncListening=!0,triggerSubscriptions(subscriptions,subscriptionMutation,pinia.state.value[$id])}__name($patch,"$patch");const $reset=isOptionsStore?__name(function(){const{state}=options,newState=state?state():{};this.$patch($state=>{assign$1($state,newState)})},"$reset2"):noop$1;function $dispose(){scope.stop(),subscriptions=[],actionSubscriptions=[],pinia._s.delete($id)}__name($dispose,"$dispose");const action=__name((fn,name="")=>{if(ACTION_MARKER in fn)return fn[ACTION_NAME]=name,fn;const wrappedAction=__name(function(){setActivePinia(pinia);const args=Array.from(arguments),afterCallbackList=[],onErrorCallbackList=[];function after(callback){afterCallbackList.push(callback)}__name(after,"after");function onError(callback){onErrorCallbackList.push(callback)}__name(onError,"onError"),triggerSubscriptions(actionSubscriptions,{args,name:wrappedAction[ACTION_NAME],store,after,onError});let ret;try{ret=fn.apply(this&&this.$id===$id?this:store,args)}catch(error){throw triggerSubscriptions(onErrorCallbackList,error),error}return ret instanceof Promise?ret.then(value=>(triggerSubscriptions(afterCallbackList,value),value)).catch(error=>(triggerSubscriptions(onErrorCallbackList,error),Promise.reject(error))):(triggerSubscriptions(afterCallbackList,ret),ret)},"wrappedAction");return wrappedAction[ACTION_MARKER]=!0,wrappedAction[ACTION_NAME]=name,wrappedAction},"action"),partialStore={_p:pinia,$id,$onAction:addSubscription.bind(null,actionSubscriptions),$patch,$reset,$subscribe(callback,options2={}){const removeSubscription=addSubscription(subscriptions,callback,options2.detached,()=>stopWatcher()),stopWatcher=scope.run(()=>watch(()=>pinia.state.value[$id],state=>{(options2.flush==="sync"?isSyncListening:isListening)&&callback({storeId:$id,type:MutationType.direct,events:debuggerEvents},state)},assign$1({},$subscribeOptions,options2)));return removeSubscription},$dispose},store=reactive(partialStore);pinia._s.set($id,store);const setupStore=(pinia._a&&pinia._a.runWithContext||fallbackRunWithContext)(()=>pinia._e.run(()=>(scope=effectScope()).run(()=>setup({action}))));for(const key in setupStore){const prop=setupStore[key];if(isRef(prop)&&!isComputed(prop)||isReactive(prop))isOptionsStore||(initialState&&shouldHydrate(prop)&&(isRef(prop)?prop.value=initialState[key]:mergeReactiveObjects(prop,initialState[key])),pinia.state.value[$id][key]=prop);else if(typeof prop=="function"){const actionValue=action(prop,key);setupStore[key]=actionValue,optionsForPlugin.actions[key]=prop}}return assign$1(store,setupStore),assign$1(toRaw(store),setupStore),Object.defineProperty(store,"$state",{get:__name(()=>pinia.state.value[$id],"get"),set:__name(state=>{$patch($state=>{assign$1($state,state)})},"set")}),pinia._p.forEach(extender=>{assign$1(store,scope.run(()=>extender({store,app:pinia._a,pinia,options:optionsForPlugin})))}),initialState&&isOptionsStore&&options.hydrate&&options.hydrate(store.$state,initialState),isListening=!0,isSyncListening=!0,store}__name(createSetupStore,"createSetupStore");/*! #__NO_SIDE_EFFECTS__ */function defineStore(id,setup,setupOptions){let options;const isSetupStore=typeof setup=="function";options=isSetupStore?setupOptions:setup;function useStore(pinia,hot){const hasContext=hasInjectionContext();return pinia=pinia||(hasContext?inject(piniaSymbol,null):null),pinia&&setActivePinia(pinia),pinia=activePinia,pinia._s.has(id)||(isSetupStore?createSetupStore(id,setup,options,pinia):createOptionsStore(id,options,pinia)),pinia._s.get(id)}return __name(useStore,"useStore"),useStore.$id=id,useStore}__name(defineStore,"defineStore");/*!
  * vue-router v4.5.1
  * (c) 2025 Eduardo San Martin Morote
  * @license MIT
  */const isBrowser=typeof document<"u";function isRouteComponent(component){return typeof component=="object"||"displayName"in component||"props"in component||"__vccOpts"in component}__name(isRouteComponent,"isRouteComponent");function isESModule(obj){return obj.__esModule||obj[Symbol.toStringTag]==="Module"||obj.default&&isRouteComponent(obj.default)}__name(isESModule,"isESModule");const assign=Object.assign;function applyToParams(fn,params){const newParams={};for(const key in params){const value=params[key];newParams[key]=isArray(value)?value.map(fn):fn(value)}return newParams}__name(applyToParams,"applyToParams");const noop=__name(()=>{},"noop"),isArray=Array.isArray,HASH_RE=/#/g,AMPERSAND_RE=/&/g,SLASH_RE=/\//g,EQUAL_RE=/=/g,IM_RE=/\?/g,PLUS_RE=/\+/g,ENC_BRACKET_OPEN_RE=/%5B/g,ENC_BRACKET_CLOSE_RE=/%5D/g,ENC_CARET_RE=/%5E/g,ENC_BACKTICK_RE=/%60/g,ENC_CURLY_OPEN_RE=/%7B/g,ENC_PIPE_RE=/%7C/g,ENC_CURLY_CLOSE_RE=/%7D/g,ENC_SPACE_RE=/%20/g;function commonEncode(text){return encodeURI(""+text).replace(ENC_PIPE_RE,"|").replace(ENC_BRACKET_OPEN_RE,"[").replace(ENC_BRACKET_CLOSE_RE,"]")}__name(commonEncode,"commonEncode");function encodeHash(text){return commonEncode(text).replace(ENC_CURLY_OPEN_RE,"{").replace(ENC_CURLY_CLOSE_RE,"}").replace(ENC_CARET_RE,"^")}__name(encodeHash,"encodeHash");function encodeQueryValue(text){return commonEncode(text).replace(PLUS_RE,"%2B").replace(ENC_SPACE_RE,"+").replace(HASH_RE,"%23").replace(AMPERSAND_RE,"%26").replace(ENC_BACKTICK_RE,"`").replace(ENC_CURLY_OPEN_RE,"{").replace(ENC_CURLY_CLOSE_RE,"}").replace(ENC_CARET_RE,"^")}__name(encodeQueryValue,"encodeQueryValue");function encodeQueryKey(text){return encodeQueryValue(text).replace(EQUAL_RE,"%3D")}__name(encodeQueryKey,"encodeQueryKey");function encodePath(text){return commonEncode(text).replace(HASH_RE,"%23").replace(IM_RE,"%3F")}__name(encodePath,"encodePath");function encodeParam(text){return text==null?"":encodePath(text).replace(SLASH_RE,"%2F")}__name(encodeParam,"encodeParam");function decode(text){try{return decodeURIComponent(""+text)}catch{}return""+text}__name(decode,"decode");const TRAILING_SLASH_RE=/\/$/,removeTrailingSlash=__name(path=>path.replace(TRAILING_SLASH_RE,""),"removeTrailingSlash");function parseURL(parseQuery2,location2,currentLocation="/"){let path,query={},searchString="",hash="";const hashPos=location2.indexOf("#");let searchPos=location2.indexOf("?");return hashPos<searchPos&&hashPos>=0&&(searchPos=-1),searchPos>-1&&(path=location2.slice(0,searchPos),searchString=location2.slice(searchPos+1,hashPos>-1?hashPos:location2.length),query=parseQuery2(searchString)),hashPos>-1&&(path=path||location2.slice(0,hashPos),hash=location2.slice(hashPos,location2.length)),path=resolveRelativePath(path??location2,currentLocation),{fullPath:path+(searchString&&"?")+searchString+hash,path,query,hash:decode(hash)}}__name(parseURL,"parseURL");function stringifyURL(stringifyQuery2,location2){const query=location2.query?stringifyQuery2(location2.query):"";return location2.path+(query&&"?")+query+(location2.hash||"")}__name(stringifyURL,"stringifyURL");function stripBase(pathname,base){return!base||!pathname.toLowerCase().startsWith(base.toLowerCase())?pathname:pathname.slice(base.length)||"/"}__name(stripBase,"stripBase");function isSameRouteLocation(stringifyQuery2,a,b){const aLastIndex=a.matched.length-1,bLastIndex=b.matched.length-1;return aLastIndex>-1&&aLastIndex===bLastIndex&&isSameRouteRecord(a.matched[aLastIndex],b.matched[bLastIndex])&&isSameRouteLocationParams(a.params,b.params)&&stringifyQuery2(a.query)===stringifyQuery2(b.query)&&a.hash===b.hash}__name(isSameRouteLocation,"isSameRouteLocation");function isSameRouteRecord(a,b){return(a.aliasOf||a)===(b.aliasOf||b)}__name(isSameRouteRecord,"isSameRouteRecord");function isSameRouteLocationParams(a,b){if(Object.keys(a).length!==Object.keys(b).length)return!1;for(const key in a)if(!isSameRouteLocationParamsValue(a[key],b[key]))return!1;return!0}__name(isSameRouteLocationParams,"isSameRouteLocationParams");function isSameRouteLocationParamsValue(a,b){return isArray(a)?isEquivalentArray(a,b):isArray(b)?isEquivalentArray(b,a):a===b}__name(isSameRouteLocationParamsValue,"isSameRouteLocationParamsValue");function isEquivalentArray(a,b){return isArray(b)?a.length===b.length&&a.every((value,i)=>value===b[i]):a.length===1&&a[0]===b}__name(isEquivalentArray,"isEquivalentArray");function resolveRelativePath(to,from){if(to.startsWith("/"))return to;if(!to)return from;const fromSegments=from.split("/"),toSegments=to.split("/"),lastToSegment=toSegments[toSegments.length-1];(lastToSegment===".."||lastToSegment===".")&&toSegments.push("");let position=fromSegments.length-1,toPosition,segment;for(toPosition=0;toPosition<toSegments.length;toPosition++)if(segment=toSegments[toPosition],segment!==".")if(segment==="..")position>1&&position--;else break;return fromSegments.slice(0,position).join("/")+"/"+toSegments.slice(toPosition).join("/")}__name(resolveRelativePath,"resolveRelativePath");const START_LOCATION_NORMALIZED={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0};var NavigationType;(function(NavigationType2){NavigationType2.pop="pop",NavigationType2.push="push"})(NavigationType||(NavigationType={}));var NavigationDirection;(function(NavigationDirection2){NavigationDirection2.back="back",NavigationDirection2.forward="forward",NavigationDirection2.unknown=""})(NavigationDirection||(NavigationDirection={}));function normalizeBase(base){if(!base)if(isBrowser){const baseEl=document.querySelector("base");base=baseEl&&baseEl.getAttribute("href")||"/",base=base.replace(/^\w+:\/\/[^\/]+/,"")}else base="/";return base[0]!=="/"&&base[0]!=="#"&&(base="/"+base),removeTrailingSlash(base)}__name(normalizeBase,"normalizeBase");const BEFORE_HASH_RE=/^[^#]+#/;function createHref(base,location2){return base.replace(BEFORE_HASH_RE,"#")+location2}__name(createHref,"createHref");function getElementPosition(el,offset){const docRect=document.documentElement.getBoundingClientRect(),elRect=el.getBoundingClientRect();return{behavior:offset.behavior,left:elRect.left-docRect.left-(offset.left||0),top:elRect.top-docRect.top-(offset.top||0)}}__name(getElementPosition,"getElementPosition");const computeScrollPosition=__name(()=>({left:window.scrollX,top:window.scrollY}),"computeScrollPosition");function scrollToPosition(position){let scrollToOptions;if("el"in position){const positionEl=position.el,isIdSelector=typeof positionEl=="string"&&positionEl.startsWith("#"),el=typeof positionEl=="string"?isIdSelector?document.getElementById(positionEl.slice(1)):document.querySelector(positionEl):positionEl;if(!el)return;scrollToOptions=getElementPosition(el,position)}else scrollToOptions=position;"scrollBehavior"in document.documentElement.style?window.scrollTo(scrollToOptions):window.scrollTo(scrollToOptions.left!=null?scrollToOptions.left:window.scrollX,scrollToOptions.top!=null?scrollToOptions.top:window.scrollY)}__name(scrollToPosition,"scrollToPosition");function getScrollKey(path,delta){return(history.state?history.state.position-delta:-1)+path}__name(getScrollKey,"getScrollKey");const scrollPositions=new Map;function saveScrollPosition(key,scrollPosition){scrollPositions.set(key,scrollPosition)}__name(saveScrollPosition,"saveScrollPosition");function getSavedScrollPosition(key){const scroll=scrollPositions.get(key);return scrollPositions.delete(key),scroll}__name(getSavedScrollPosition,"getSavedScrollPosition");let createBaseLocation=__name(()=>location.protocol+"//"+location.host,"createBaseLocation");function createCurrentLocation(base,location2){const{pathname,search,hash}=location2,hashPos=base.indexOf("#");if(hashPos>-1){let slicePos=hash.includes(base.slice(hashPos))?base.slice(hashPos).length:1,pathFromHash=hash.slice(slicePos);return pathFromHash[0]!=="/"&&(pathFromHash="/"+pathFromHash),stripBase(pathFromHash,"")}return stripBase(pathname,base)+search+hash}__name(createCurrentLocation,"createCurrentLocation");function useHistoryListeners(base,historyState,currentLocation,replace){let listeners=[],teardowns=[],pauseState=null;const popStateHandler=__name(({state})=>{const to=createCurrentLocation(base,location),from=currentLocation.value,fromState=historyState.value;let delta=0;if(state){if(currentLocation.value=to,historyState.value=state,pauseState&&pauseState===from){pauseState=null;return}delta=fromState?state.position-fromState.position:0}else replace(to);listeners.forEach(listener=>{listener(currentLocation.value,from,{delta,type:NavigationType.pop,direction:delta?delta>0?NavigationDirection.forward:NavigationDirection.back:NavigationDirection.unknown})})},"popStateHandler");function pauseListeners(){pauseState=currentLocation.value}__name(pauseListeners,"pauseListeners");function listen(callback){listeners.push(callback);const teardown=__name(()=>{const index=listeners.indexOf(callback);index>-1&&listeners.splice(index,1)},"teardown");return teardowns.push(teardown),teardown}__name(listen,"listen");function beforeUnloadListener(){const{history:history2}=window;history2.state&&history2.replaceState(assign({},history2.state,{scroll:computeScrollPosition()}),"")}__name(beforeUnloadListener,"beforeUnloadListener");function destroy(){for(const teardown of teardowns)teardown();teardowns=[],window.removeEventListener("popstate",popStateHandler),window.removeEventListener("beforeunload",beforeUnloadListener)}return __name(destroy,"destroy"),window.addEventListener("popstate",popStateHandler),window.addEventListener("beforeunload",beforeUnloadListener,{passive:!0}),{pauseListeners,listen,destroy}}__name(useHistoryListeners,"useHistoryListeners");function buildState(back,current,forward,replaced=!1,computeScroll=!1){return{back,current,forward,replaced,position:window.history.length,scroll:computeScroll?computeScrollPosition():null}}__name(buildState,"buildState");function useHistoryStateNavigation(base){const{history:history2,location:location2}=window,currentLocation={value:createCurrentLocation(base,location2)},historyState={value:history2.state};historyState.value||changeLocation(currentLocation.value,{back:null,current:currentLocation.value,forward:null,position:history2.length-1,replaced:!0,scroll:null},!0);function changeLocation(to,state,replace2){const hashIndex=base.indexOf("#"),url=hashIndex>-1?(location2.host&&document.querySelector("base")?base:base.slice(hashIndex))+to:createBaseLocation()+base+to;try{history2[replace2?"replaceState":"pushState"](state,"",url),historyState.value=state}catch(err){console.error(err),location2[replace2?"replace":"assign"](url)}}__name(changeLocation,"changeLocation");function replace(to,data){const state=assign({},history2.state,buildState(historyState.value.back,to,historyState.value.forward,!0),data,{position:historyState.value.position});changeLocation(to,state,!0),currentLocation.value=to}__name(replace,"replace");function push(to,data){const currentState=assign({},historyState.value,history2.state,{forward:to,scroll:computeScrollPosition()});changeLocation(currentState.current,currentState,!0);const state=assign({},buildState(currentLocation.value,to,null),{position:currentState.position+1},data);changeLocation(to,state,!1),currentLocation.value=to}return __name(push,"push"),{location:currentLocation,state:historyState,push,replace}}__name(useHistoryStateNavigation,"useHistoryStateNavigation");function createWebHistory(base){base=normalizeBase(base);const historyNavigation=useHistoryStateNavigation(base),historyListeners=useHistoryListeners(base,historyNavigation.state,historyNavigation.location,historyNavigation.replace);function go(delta,triggerListeners=!0){triggerListeners||historyListeners.pauseListeners(),history.go(delta)}__name(go,"go");const routerHistory=assign({location:"",base,go,createHref:createHref.bind(null,base)},historyNavigation,historyListeners);return Object.defineProperty(routerHistory,"location",{enumerable:!0,get:__name(()=>historyNavigation.location.value,"get")}),Object.defineProperty(routerHistory,"state",{enumerable:!0,get:__name(()=>historyNavigation.state.value,"get")}),routerHistory}__name(createWebHistory,"createWebHistory");function isRouteLocation(route){return typeof route=="string"||route&&typeof route=="object"}__name(isRouteLocation,"isRouteLocation");function isRouteName(name){return typeof name=="string"||typeof name=="symbol"}__name(isRouteName,"isRouteName");const NavigationFailureSymbol=Symbol("");var NavigationFailureType;(function(NavigationFailureType2){NavigationFailureType2[NavigationFailureType2.aborted=4]="aborted",NavigationFailureType2[NavigationFailureType2.cancelled=8]="cancelled",NavigationFailureType2[NavigationFailureType2.duplicated=16]="duplicated"})(NavigationFailureType||(NavigationFailureType={}));function createRouterError(type,params){return assign(new Error,{type,[NavigationFailureSymbol]:!0},params)}__name(createRouterError,"createRouterError");function isNavigationFailure(error,type){return error instanceof Error&&NavigationFailureSymbol in error&&(type==null||!!(error.type&type))}__name(isNavigationFailure,"isNavigationFailure");const BASE_PARAM_PATTERN="[^/]+?",BASE_PATH_PARSER_OPTIONS={sensitive:!1,strict:!1,start:!0,end:!0},REGEX_CHARS_RE=/[.+*?^${}()[\]/\\]/g;function tokensToParser(segments,extraOptions){const options=assign({},BASE_PATH_PARSER_OPTIONS,extraOptions),score=[];let pattern=options.start?"^":"";const keys=[];for(const segment of segments){const segmentScores=segment.length?[]:[90];options.strict&&!segment.length&&(pattern+="/");for(let tokenIndex=0;tokenIndex<segment.length;tokenIndex++){const token=segment[tokenIndex];let subSegmentScore=40+(options.sensitive?.25:0);if(token.type===0)tokenIndex||(pattern+="/"),pattern+=token.value.replace(REGEX_CHARS_RE,"\\$&"),subSegmentScore+=40;else if(token.type===1){const{value,repeatable,optional,regexp}=token;keys.push({name:value,repeatable,optional});const re2=regexp||BASE_PARAM_PATTERN;if(re2!==BASE_PARAM_PATTERN){subSegmentScore+=10;try{new RegExp(`(${re2})`)}catch(err){throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): `+err.message)}}let subPattern=repeatable?`((?:${re2})(?:/(?:${re2}))*)`:`(${re2})`;tokenIndex||(subPattern=optional&&segment.length<2?`(?:/${subPattern})`:"/"+subPattern),optional&&(subPattern+="?"),pattern+=subPattern,subSegmentScore+=20,optional&&(subSegmentScore+=-8),repeatable&&(subSegmentScore+=-20),re2===".*"&&(subSegmentScore+=-50)}segmentScores.push(subSegmentScore)}score.push(segmentScores)}if(options.strict&&options.end){const i=score.length-1;score[i][score[i].length-1]+=.7000000000000001}options.strict||(pattern+="/?"),options.end?pattern+="$":options.strict&&!pattern.endsWith("/")&&(pattern+="(?:/|$)");const re=new RegExp(pattern,options.sensitive?"":"i");function parse(path){const match=path.match(re),params={};if(!match)return null;for(let i=1;i<match.length;i++){const value=match[i]||"",key=keys[i-1];params[key.name]=value&&key.repeatable?value.split("/"):value}return params}__name(parse,"parse");function stringify(params){let path="",avoidDuplicatedSlash=!1;for(const segment of segments){(!avoidDuplicatedSlash||!path.endsWith("/"))&&(path+="/"),avoidDuplicatedSlash=!1;for(const token of segment)if(token.type===0)path+=token.value;else if(token.type===1){const{value,repeatable,optional}=token,param=value in params?params[value]:"";if(isArray(param)&&!repeatable)throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);const text=isArray(param)?param.join("/"):param;if(!text)if(optional)segment.length<2&&(path.endsWith("/")?path=path.slice(0,-1):avoidDuplicatedSlash=!0);else throw new Error(`Missing required param "${value}"`);path+=text}}return path||"/"}return __name(stringify,"stringify"),{re,score,keys,parse,stringify}}__name(tokensToParser,"tokensToParser");function compareScoreArray(a,b){let i=0;for(;i<a.length&&i<b.length;){const diff=b[i]-a[i];if(diff)return diff;i++}return a.length<b.length?a.length===1&&a[0]===80?-1:1:a.length>b.length?b.length===1&&b[0]===80?1:-1:0}__name(compareScoreArray,"compareScoreArray");function comparePathParserScore(a,b){let i=0;const aScore=a.score,bScore=b.score;for(;i<aScore.length&&i<bScore.length;){const comp=compareScoreArray(aScore[i],bScore[i]);if(comp)return comp;i++}if(Math.abs(bScore.length-aScore.length)===1){if(isLastScoreNegative(aScore))return 1;if(isLastScoreNegative(bScore))return-1}return bScore.length-aScore.length}__name(comparePathParserScore,"comparePathParserScore");function isLastScoreNegative(score){const last=score[score.length-1];return score.length>0&&last[last.length-1]<0}__name(isLastScoreNegative,"isLastScoreNegative");const ROOT_TOKEN={type:0,value:""},VALID_PARAM_RE=/[a-zA-Z0-9_]/;function tokenizePath(path){if(!path)return[[]];if(path==="/")return[[ROOT_TOKEN]];if(!path.startsWith("/"))throw new Error(`Invalid path "${path}"`);function crash(message){throw new Error(`ERR (${state})/"${buffer2}": ${message}`)}__name(crash,"crash");let state=0,previousState=state;const tokens=[];let segment;function finalizeSegment(){segment&&tokens.push(segment),segment=[]}__name(finalizeSegment,"finalizeSegment");let i=0,char,buffer2="",customRe="";function consumeBuffer(){buffer2&&(state===0?segment.push({type:0,value:buffer2}):state===1||state===2||state===3?(segment.length>1&&(char==="*"||char==="+")&&crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`),segment.push({type:1,value:buffer2,regexp:customRe,repeatable:char==="*"||char==="+",optional:char==="*"||char==="?"})):crash("Invalid state to consume buffer"),buffer2="")}__name(consumeBuffer,"consumeBuffer");function addCharToBuffer(){buffer2+=char}for(__name(addCharToBuffer,"addCharToBuffer");i<path.length;){if(char=path[i++],char==="\\"&&state!==2){previousState=state,state=4;continue}switch(state){case 0:char==="/"?(buffer2&&consumeBuffer(),finalizeSegment()):char===":"?(consumeBuffer(),state=1):addCharToBuffer();break;case 4:addCharToBuffer(),state=previousState;break;case 1:char==="("?state=2:VALID_PARAM_RE.test(char)?addCharToBuffer():(consumeBuffer(),state=0,char!=="*"&&char!=="?"&&char!=="+"&&i--);break;case 2:char===")"?customRe[customRe.length-1]=="\\"?customRe=customRe.slice(0,-1)+char:state=3:customRe+=char;break;case 3:consumeBuffer(),state=0,char!=="*"&&char!=="?"&&char!=="+"&&i--,customRe="";break;default:crash("Unknown state");break}}return state===2&&crash(`Unfinished custom RegExp for param "${buffer2}"`),consumeBuffer(),finalizeSegment(),tokens}__name(tokenizePath,"tokenizePath");function createRouteRecordMatcher(record,parent,options){const parser=tokensToParser(tokenizePath(record.path),options),matcher=assign(parser,{record,parent,children:[],alias:[]});return parent&&!matcher.record.aliasOf==!parent.record.aliasOf&&parent.children.push(matcher),matcher}__name(createRouteRecordMatcher,"createRouteRecordMatcher");function createRouterMatcher(routes,globalOptions){const matchers=[],matcherMap=new Map;globalOptions=mergeOptions({strict:!1,end:!0,sensitive:!1},globalOptions);function getRecordMatcher(name){return matcherMap.get(name)}__name(getRecordMatcher,"getRecordMatcher");function addRoute(record,parent,originalRecord){const isRootAdd=!originalRecord,mainNormalizedRecord=normalizeRouteRecord(record);mainNormalizedRecord.aliasOf=originalRecord&&originalRecord.record;const options=mergeOptions(globalOptions,record),normalizedRecords=[mainNormalizedRecord];if("alias"in record){const aliases=typeof record.alias=="string"?[record.alias]:record.alias;for(const alias of aliases)normalizedRecords.push(normalizeRouteRecord(assign({},mainNormalizedRecord,{components:originalRecord?originalRecord.record.components:mainNormalizedRecord.components,path:alias,aliasOf:originalRecord?originalRecord.record:mainNormalizedRecord})))}let matcher,originalMatcher;for(const normalizedRecord of normalizedRecords){const{path}=normalizedRecord;if(parent&&path[0]!=="/"){const parentPath=parent.record.path,connectingSlash=parentPath[parentPath.length-1]==="/"?"":"/";normalizedRecord.path=parent.record.path+(path&&connectingSlash+path)}if(matcher=createRouteRecordMatcher(normalizedRecord,parent,options),originalRecord?originalRecord.alias.push(matcher):(originalMatcher=originalMatcher||matcher,originalMatcher!==matcher&&originalMatcher.alias.push(matcher),isRootAdd&&record.name&&!isAliasRecord(matcher)&&removeRoute(record.name)),isMatchable(matcher)&&insertMatcher(matcher),mainNormalizedRecord.children){const children=mainNormalizedRecord.children;for(let i=0;i<children.length;i++)addRoute(children[i],matcher,originalRecord&&originalRecord.children[i])}originalRecord=originalRecord||matcher}return originalMatcher?()=>{removeRoute(originalMatcher)}:noop}__name(addRoute,"addRoute");function removeRoute(matcherRef){if(isRouteName(matcherRef)){const matcher=matcherMap.get(matcherRef);matcher&&(matcherMap.delete(matcherRef),matchers.splice(matchers.indexOf(matcher),1),matcher.children.forEach(removeRoute),matcher.alias.forEach(removeRoute))}else{const index=matchers.indexOf(matcherRef);index>-1&&(matchers.splice(index,1),matcherRef.record.name&&matcherMap.delete(matcherRef.record.name),matcherRef.children.forEach(removeRoute),matcherRef.alias.forEach(removeRoute))}}__name(removeRoute,"removeRoute");function getRoutes(){return matchers}__name(getRoutes,"getRoutes");function insertMatcher(matcher){const index=findInsertionIndex(matcher,matchers);matchers.splice(index,0,matcher),matcher.record.name&&!isAliasRecord(matcher)&&matcherMap.set(matcher.record.name,matcher)}__name(insertMatcher,"insertMatcher");function resolve2(location2,currentLocation){let matcher,params={},path,name;if("name"in location2&&location2.name){if(matcher=matcherMap.get(location2.name),!matcher)throw createRouterError(1,{location:location2});name=matcher.record.name,params=assign(paramsFromLocation(currentLocation.params,matcher.keys.filter(k=>!k.optional).concat(matcher.parent?matcher.parent.keys.filter(k=>k.optional):[]).map(k=>k.name)),location2.params&&paramsFromLocation(location2.params,matcher.keys.map(k=>k.name))),path=matcher.stringify(params)}else if(location2.path!=null)path=location2.path,matcher=matchers.find(m=>m.re.test(path)),matcher&&(params=matcher.parse(path),name=matcher.record.name);else{if(matcher=currentLocation.name?matcherMap.get(currentLocation.name):matchers.find(m=>m.re.test(currentLocation.path)),!matcher)throw createRouterError(1,{location:location2,currentLocation});name=matcher.record.name,params=assign({},currentLocation.params,location2.params),path=matcher.stringify(params)}const matched=[];let parentMatcher=matcher;for(;parentMatcher;)matched.unshift(parentMatcher.record),parentMatcher=parentMatcher.parent;return{name,path,params,matched,meta:mergeMetaFields(matched)}}__name(resolve2,"resolve"),routes.forEach(route=>addRoute(route));function clearRoutes(){matchers.length=0,matcherMap.clear()}return __name(clearRoutes,"clearRoutes"),{addRoute,resolve:resolve2,removeRoute,clearRoutes,getRoutes,getRecordMatcher}}__name(createRouterMatcher,"createRouterMatcher");function paramsFromLocation(params,keys){const newParams={};for(const key of keys)key in params&&(newParams[key]=params[key]);return newParams}__name(paramsFromLocation,"paramsFromLocation");function normalizeRouteRecord(record){const normalized={path:record.path,redirect:record.redirect,name:record.name,meta:record.meta||{},aliasOf:record.aliasOf,beforeEnter:record.beforeEnter,props:normalizeRecordProps(record),children:record.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in record?record.components||null:record.component&&{default:record.component}};return Object.defineProperty(normalized,"mods",{value:{}}),normalized}__name(normalizeRouteRecord,"normalizeRouteRecord");function normalizeRecordProps(record){const propsObject={},props=record.props||!1;if("component"in record)propsObject.default=props;else for(const name in record.components)propsObject[name]=typeof props=="object"?props[name]:props;return propsObject}__name(normalizeRecordProps,"normalizeRecordProps");function isAliasRecord(record){for(;record;){if(record.record.aliasOf)return!0;record=record.parent}return!1}__name(isAliasRecord,"isAliasRecord");function mergeMetaFields(matched){return matched.reduce((meta,record)=>assign(meta,record.meta),{})}__name(mergeMetaFields,"mergeMetaFields");function mergeOptions(defaults,partialOptions){const options={};for(const key in defaults)options[key]=key in partialOptions?partialOptions[key]:defaults[key];return options}__name(mergeOptions,"mergeOptions");function findInsertionIndex(matcher,matchers){let lower=0,upper=matchers.length;for(;lower!==upper;){const mid=lower+upper>>1;comparePathParserScore(matcher,matchers[mid])<0?upper=mid:lower=mid+1}const insertionAncestor=getInsertionAncestor(matcher);return insertionAncestor&&(upper=matchers.lastIndexOf(insertionAncestor,upper-1)),upper}__name(findInsertionIndex,"findInsertionIndex");function getInsertionAncestor(matcher){let ancestor=matcher;for(;ancestor=ancestor.parent;)if(isMatchable(ancestor)&&comparePathParserScore(matcher,ancestor)===0)return ancestor}__name(getInsertionAncestor,"getInsertionAncestor");function isMatchable({record}){return!!(record.name||record.components&&Object.keys(record.components).length||record.redirect)}__name(isMatchable,"isMatchable");function parseQuery(search){const query={};if(search===""||search==="?")return query;const searchParams=(search[0]==="?"?search.slice(1):search).split("&");for(let i=0;i<searchParams.length;++i){const searchParam=searchParams[i].replace(PLUS_RE," "),eqPos=searchParam.indexOf("="),key=decode(eqPos<0?searchParam:searchParam.slice(0,eqPos)),value=eqPos<0?null:decode(searchParam.slice(eqPos+1));if(key in query){let currentValue=query[key];isArray(currentValue)||(currentValue=query[key]=[currentValue]),currentValue.push(value)}else query[key]=value}return query}__name(parseQuery,"parseQuery");function stringifyQuery(query){let search="";for(let key in query){const value=query[key];if(key=encodeQueryKey(key),value==null){value!==void 0&&(search+=(search.length?"&":"")+key);continue}(isArray(value)?value.map(v=>v&&encodeQueryValue(v)):[value&&encodeQueryValue(value)]).forEach(value2=>{value2!==void 0&&(search+=(search.length?"&":"")+key,value2!=null&&(search+="="+value2))})}return search}__name(stringifyQuery,"stringifyQuery");function normalizeQuery(query){const normalizedQuery={};for(const key in query){const value=query[key];value!==void 0&&(normalizedQuery[key]=isArray(value)?value.map(v=>v==null?null:""+v):value==null?value:""+value)}return normalizedQuery}__name(normalizeQuery,"normalizeQuery");const matchedRouteKey=Symbol(""),viewDepthKey=Symbol(""),routerKey=Symbol(""),routeLocationKey=Symbol(""),routerViewLocationKey=Symbol("");function useCallbacks(){let handlers=[];function add(handler){return handlers.push(handler),()=>{const i=handlers.indexOf(handler);i>-1&&handlers.splice(i,1)}}__name(add,"add");function reset(){handlers=[]}return __name(reset,"reset"),{add,list:__name(()=>handlers.slice(),"list"),reset}}__name(useCallbacks,"useCallbacks");function guardToPromiseFn(guard,to,from,record,name,runWithContext=fn=>fn()){const enterCallbackArray=record&&(record.enterCallbacks[name]=record.enterCallbacks[name]||[]);return()=>new Promise((resolve2,reject)=>{const next=__name(valid=>{valid===!1?reject(createRouterError(4,{from,to})):valid instanceof Error?reject(valid):isRouteLocation(valid)?reject(createRouterError(2,{from:to,to:valid})):(enterCallbackArray&&record.enterCallbacks[name]===enterCallbackArray&&typeof valid=="function"&&enterCallbackArray.push(valid),resolve2())},"next"),guardReturn=runWithContext(()=>guard.call(record&&record.instances[name],to,from,next));let guardCall=Promise.resolve(guardReturn);guard.length<3&&(guardCall=guardCall.then(next)),guardCall.catch(err=>reject(err))})}__name(guardToPromiseFn,"guardToPromiseFn");function extractComponentsGuards(matched,guardType,to,from,runWithContext=fn=>fn()){const guards=[];for(const record of matched)for(const name in record.components){let rawComponent=record.components[name];if(!(guardType!=="beforeRouteEnter"&&!record.instances[name]))if(isRouteComponent(rawComponent)){const guard=(rawComponent.__vccOpts||rawComponent)[guardType];guard&&guards.push(guardToPromiseFn(guard,to,from,record,name,runWithContext))}else{let componentPromise=rawComponent();guards.push(()=>componentPromise.then(resolved=>{if(!resolved)throw new Error(`Couldn't resolve component "${name}" at "${record.path}"`);const resolvedComponent=isESModule(resolved)?resolved.default:resolved;record.mods[name]=resolved,record.components[name]=resolvedComponent;const guard=(resolvedComponent.__vccOpts||resolvedComponent)[guardType];return guard&&guardToPromiseFn(guard,to,from,record,name,runWithContext)()}))}}return guards}__name(extractComponentsGuards,"extractComponentsGuards");function useLink(props){const router=inject(routerKey),currentRoute=inject(routeLocationKey),route=computed(()=>{const to=unref(props.to);return router.resolve(to)}),activeRecordIndex=computed(()=>{const{matched}=route.value,{length}=matched,routeMatched=matched[length-1],currentMatched=currentRoute.matched;if(!routeMatched||!currentMatched.length)return-1;const index=currentMatched.findIndex(isSameRouteRecord.bind(null,routeMatched));if(index>-1)return index;const parentRecordPath=getOriginalPath(matched[length-2]);return length>1&&getOriginalPath(routeMatched)===parentRecordPath&&currentMatched[currentMatched.length-1].path!==parentRecordPath?currentMatched.findIndex(isSameRouteRecord.bind(null,matched[length-2])):index}),isActive=computed(()=>activeRecordIndex.value>-1&&includesParams(currentRoute.params,route.value.params)),isExactActive=computed(()=>activeRecordIndex.value>-1&&activeRecordIndex.value===currentRoute.matched.length-1&&isSameRouteLocationParams(currentRoute.params,route.value.params));function navigate(e={}){if(guardEvent(e)){const p2=router[unref(props.replace)?"replace":"push"](unref(props.to)).catch(noop);return props.viewTransition&&typeof document<"u"&&"startViewTransition"in document&&document.startViewTransition(()=>p2),p2}return Promise.resolve()}return __name(navigate,"navigate"),{route,href:computed(()=>route.value.href),isActive,isExactActive,navigate}}__name(useLink,"useLink");function preferSingleVNode(vnodes){return vnodes.length===1?vnodes[0]:vnodes}__name(preferSingleVNode,"preferSingleVNode");const RouterLinkImpl=defineComponent({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"},viewTransition:Boolean},useLink,setup(props,{slots}){const link=reactive(useLink(props)),{options}=inject(routerKey),elClass=computed(()=>({[getLinkClass(props.activeClass,options.linkActiveClass,"router-link-active")]:link.isActive,[getLinkClass(props.exactActiveClass,options.linkExactActiveClass,"router-link-exact-active")]:link.isExactActive}));return()=>{const children=slots.default&&preferSingleVNode(slots.default(link));return props.custom?children:h("a",{"aria-current":link.isExactActive?props.ariaCurrentValue:null,href:link.href,onClick:link.navigate,class:elClass.value},children)}}}),RouterLink=RouterLinkImpl;function guardEvent(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)&&!e.defaultPrevented&&!(e.button!==void 0&&e.button!==0)){if(e.currentTarget&&e.currentTarget.getAttribute){const target=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(target))return}return e.preventDefault&&e.preventDefault(),!0}}__name(guardEvent,"guardEvent");function includesParams(outer,inner){for(const key in inner){const innerValue=inner[key],outerValue=outer[key];if(typeof innerValue=="string"){if(innerValue!==outerValue)return!1}else if(!isArray(outerValue)||outerValue.length!==innerValue.length||innerValue.some((value,i)=>value!==outerValue[i]))return!1}return!0}__name(includesParams,"includesParams");function getOriginalPath(record){return record?record.aliasOf?record.aliasOf.path:record.path:""}__name(getOriginalPath,"getOriginalPath");const getLinkClass=__name((propClass,globalClass,defaultClass)=>propClass??globalClass??defaultClass,"getLinkClass"),RouterViewImpl=defineComponent({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(props,{attrs,slots}){const injectedRoute=inject(routerViewLocationKey),routeToDisplay=computed(()=>props.route||injectedRoute.value),injectedDepth=inject(viewDepthKey,0),depth=computed(()=>{let initialDepth=unref(injectedDepth);const{matched}=routeToDisplay.value;let matchedRoute;for(;(matchedRoute=matched[initialDepth])&&!matchedRoute.components;)initialDepth++;return initialDepth}),matchedRouteRef=computed(()=>routeToDisplay.value.matched[depth.value]);provide(viewDepthKey,computed(()=>depth.value+1)),provide(matchedRouteKey,matchedRouteRef),provide(routerViewLocationKey,routeToDisplay);const viewRef=ref();return watch(()=>[viewRef.value,matchedRouteRef.value,props.name],([instance,to,name],[oldInstance,from,oldName])=>{to&&(to.instances[name]=instance,from&&from!==to&&instance&&instance===oldInstance&&(to.leaveGuards.size||(to.leaveGuards=from.leaveGuards),to.updateGuards.size||(to.updateGuards=from.updateGuards))),instance&&to&&(!from||!isSameRouteRecord(to,from)||!oldInstance)&&(to.enterCallbacks[name]||[]).forEach(callback=>callback(instance))},{flush:"post"}),()=>{const route=routeToDisplay.value,currentName=props.name,matchedRoute=matchedRouteRef.value,ViewComponent=matchedRoute&&matchedRoute.components[currentName];if(!ViewComponent)return normalizeSlot(slots.default,{Component:ViewComponent,route});const routePropsOption=matchedRoute.props[currentName],routeProps=routePropsOption?routePropsOption===!0?route.params:typeof routePropsOption=="function"?routePropsOption(route):routePropsOption:null,component=h(ViewComponent,assign({},routeProps,attrs,{onVnodeUnmounted:__name(vnode=>{vnode.component.isUnmounted&&(matchedRoute.instances[currentName]=null)},"onVnodeUnmounted"),ref:viewRef}));return normalizeSlot(slots.default,{Component:component,route})||component}}});function normalizeSlot(slot,data){if(!slot)return null;const slotContent=slot(data);return slotContent.length===1?slotContent[0]:slotContent}__name(normalizeSlot,"normalizeSlot");const RouterView=RouterViewImpl;function createRouter(options){const matcher=createRouterMatcher(options.routes,options),parseQuery$1=options.parseQuery||parseQuery,stringifyQuery$1=options.stringifyQuery||stringifyQuery,routerHistory=options.history,beforeGuards=useCallbacks(),beforeResolveGuards=useCallbacks(),afterGuards=useCallbacks(),currentRoute=shallowRef(START_LOCATION_NORMALIZED);let pendingLocation=START_LOCATION_NORMALIZED;isBrowser&&options.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const normalizeParams=applyToParams.bind(null,paramValue=>""+paramValue),encodeParams=applyToParams.bind(null,encodeParam),decodeParams=applyToParams.bind(null,decode);function addRoute(parentOrRoute,route){let parent,record;return isRouteName(parentOrRoute)?(parent=matcher.getRecordMatcher(parentOrRoute),record=route):record=parentOrRoute,matcher.addRoute(record,parent)}__name(addRoute,"addRoute");function removeRoute(name){const recordMatcher=matcher.getRecordMatcher(name);recordMatcher&&matcher.removeRoute(recordMatcher)}__name(removeRoute,"removeRoute");function getRoutes(){return matcher.getRoutes().map(routeMatcher=>routeMatcher.record)}__name(getRoutes,"getRoutes");function hasRoute(name){return!!matcher.getRecordMatcher(name)}__name(hasRoute,"hasRoute");function resolve2(rawLocation,currentLocation){if(currentLocation=assign({},currentLocation||currentRoute.value),typeof rawLocation=="string"){const locationNormalized=parseURL(parseQuery$1,rawLocation,currentLocation.path),matchedRoute2=matcher.resolve({path:locationNormalized.path},currentLocation),href2=routerHistory.createHref(locationNormalized.fullPath);return assign(locationNormalized,matchedRoute2,{params:decodeParams(matchedRoute2.params),hash:decode(locationNormalized.hash),redirectedFrom:void 0,href:href2})}let matcherLocation;if(rawLocation.path!=null)matcherLocation=assign({},rawLocation,{path:parseURL(parseQuery$1,rawLocation.path,currentLocation.path).path});else{const targetParams=assign({},rawLocation.params);for(const key in targetParams)targetParams[key]==null&&delete targetParams[key];matcherLocation=assign({},rawLocation,{params:encodeParams(targetParams)}),currentLocation.params=encodeParams(currentLocation.params)}const matchedRoute=matcher.resolve(matcherLocation,currentLocation),hash=rawLocation.hash||"";matchedRoute.params=normalizeParams(decodeParams(matchedRoute.params));const fullPath=stringifyURL(stringifyQuery$1,assign({},rawLocation,{hash:encodeHash(hash),path:matchedRoute.path})),href=routerHistory.createHref(fullPath);return assign({fullPath,hash,query:stringifyQuery$1===stringifyQuery?normalizeQuery(rawLocation.query):rawLocation.query||{}},matchedRoute,{redirectedFrom:void 0,href})}__name(resolve2,"resolve");function locationAsObject(to){return typeof to=="string"?parseURL(parseQuery$1,to,currentRoute.value.path):assign({},to)}__name(locationAsObject,"locationAsObject");function checkCanceledNavigation(to,from){if(pendingLocation!==to)return createRouterError(8,{from,to})}__name(checkCanceledNavigation,"checkCanceledNavigation");function push(to){return pushWithRedirect(to)}__name(push,"push");function replace(to){return push(assign(locationAsObject(to),{replace:!0}))}__name(replace,"replace");function handleRedirectRecord(to){const lastMatched=to.matched[to.matched.length-1];if(lastMatched&&lastMatched.redirect){const{redirect}=lastMatched;let newTargetLocation=typeof redirect=="function"?redirect(to):redirect;return typeof newTargetLocation=="string"&&(newTargetLocation=newTargetLocation.includes("?")||newTargetLocation.includes("#")?newTargetLocation=locationAsObject(newTargetLocation):{path:newTargetLocation},newTargetLocation.params={}),assign({query:to.query,hash:to.hash,params:newTargetLocation.path!=null?{}:to.params},newTargetLocation)}}__name(handleRedirectRecord,"handleRedirectRecord");function pushWithRedirect(to,redirectedFrom){const targetLocation=pendingLocation=resolve2(to),from=currentRoute.value,data=to.state,force=to.force,replace2=to.replace===!0,shouldRedirect=handleRedirectRecord(targetLocation);if(shouldRedirect)return pushWithRedirect(assign(locationAsObject(shouldRedirect),{state:typeof shouldRedirect=="object"?assign({},data,shouldRedirect.state):data,force,replace:replace2}),redirectedFrom||targetLocation);const toLocation=targetLocation;toLocation.redirectedFrom=redirectedFrom;let failure;return!force&&isSameRouteLocation(stringifyQuery$1,from,targetLocation)&&(failure=createRouterError(16,{to:toLocation,from}),handleScroll(from,from,!0,!1)),(failure?Promise.resolve(failure):navigate(toLocation,from)).catch(error=>isNavigationFailure(error)?isNavigationFailure(error,2)?error:markAsReady(error):triggerError(error,toLocation,from)).then(failure2=>{if(failure2){if(isNavigationFailure(failure2,2))return pushWithRedirect(assign({replace:replace2},locationAsObject(failure2.to),{state:typeof failure2.to=="object"?assign({},data,failure2.to.state):data,force}),redirectedFrom||toLocation)}else failure2=finalizeNavigation(toLocation,from,!0,replace2,data);return triggerAfterEach(toLocation,from,failure2),failure2})}__name(pushWithRedirect,"pushWithRedirect");function checkCanceledNavigationAndReject(to,from){const error=checkCanceledNavigation(to,from);return error?Promise.reject(error):Promise.resolve()}__name(checkCanceledNavigationAndReject,"checkCanceledNavigationAndReject");function runWithContext(fn){const app=installedApps.values().next().value;return app&&typeof app.runWithContext=="function"?app.runWithContext(fn):fn()}__name(runWithContext,"runWithContext");function navigate(to,from){let guards;const[leavingRecords,updatingRecords,enteringRecords]=extractChangingRecords(to,from);guards=extractComponentsGuards(leavingRecords.reverse(),"beforeRouteLeave",to,from);for(const record of leavingRecords)record.leaveGuards.forEach(guard=>{guards.push(guardToPromiseFn(guard,to,from))});const canceledNavigationCheck=checkCanceledNavigationAndReject.bind(null,to,from);return guards.push(canceledNavigationCheck),runGuardQueue(guards).then(()=>{guards=[];for(const guard of beforeGuards.list())guards.push(guardToPromiseFn(guard,to,from));return guards.push(canceledNavigationCheck),runGuardQueue(guards)}).then(()=>{guards=extractComponentsGuards(updatingRecords,"beforeRouteUpdate",to,from);for(const record of updatingRecords)record.updateGuards.forEach(guard=>{guards.push(guardToPromiseFn(guard,to,from))});return guards.push(canceledNavigationCheck),runGuardQueue(guards)}).then(()=>{guards=[];for(const record of enteringRecords)if(record.beforeEnter)if(isArray(record.beforeEnter))for(const beforeEnter of record.beforeEnter)guards.push(guardToPromiseFn(beforeEnter,to,from));else guards.push(guardToPromiseFn(record.beforeEnter,to,from));return guards.push(canceledNavigationCheck),runGuardQueue(guards)}).then(()=>(to.matched.forEach(record=>record.enterCallbacks={}),guards=extractComponentsGuards(enteringRecords,"beforeRouteEnter",to,from,runWithContext),guards.push(canceledNavigationCheck),runGuardQueue(guards))).then(()=>{guards=[];for(const guard of beforeResolveGuards.list())guards.push(guardToPromiseFn(guard,to,from));return guards.push(canceledNavigationCheck),runGuardQueue(guards)}).catch(err=>isNavigationFailure(err,8)?err:Promise.reject(err))}__name(navigate,"navigate");function triggerAfterEach(to,from,failure){afterGuards.list().forEach(guard=>runWithContext(()=>guard(to,from,failure)))}__name(triggerAfterEach,"triggerAfterEach");function finalizeNavigation(toLocation,from,isPush,replace2,data){const error=checkCanceledNavigation(toLocation,from);if(error)return error;const isFirstNavigation=from===START_LOCATION_NORMALIZED,state=isBrowser?history.state:{};isPush&&(replace2||isFirstNavigation?routerHistory.replace(toLocation.fullPath,assign({scroll:isFirstNavigation&&state&&state.scroll},data)):routerHistory.push(toLocation.fullPath,data)),currentRoute.value=toLocation,handleScroll(toLocation,from,isPush,isFirstNavigation),markAsReady()}__name(finalizeNavigation,"finalizeNavigation");let removeHistoryListener;function setupListeners(){removeHistoryListener||(removeHistoryListener=routerHistory.listen((to,_from,info)=>{if(!router.listening)return;const toLocation=resolve2(to),shouldRedirect=handleRedirectRecord(toLocation);if(shouldRedirect){pushWithRedirect(assign(shouldRedirect,{replace:!0,force:!0}),toLocation).catch(noop);return}pendingLocation=toLocation;const from=currentRoute.value;isBrowser&&saveScrollPosition(getScrollKey(from.fullPath,info.delta),computeScrollPosition()),navigate(toLocation,from).catch(error=>isNavigationFailure(error,12)?error:isNavigationFailure(error,2)?(pushWithRedirect(assign(locationAsObject(error.to),{force:!0}),toLocation).then(failure=>{isNavigationFailure(failure,20)&&!info.delta&&info.type===NavigationType.pop&&routerHistory.go(-1,!1)}).catch(noop),Promise.reject()):(info.delta&&routerHistory.go(-info.delta,!1),triggerError(error,toLocation,from))).then(failure=>{failure=failure||finalizeNavigation(toLocation,from,!1),failure&&(info.delta&&!isNavigationFailure(failure,8)?routerHistory.go(-info.delta,!1):info.type===NavigationType.pop&&isNavigationFailure(failure,20)&&routerHistory.go(-1,!1)),triggerAfterEach(toLocation,from,failure)}).catch(noop)}))}__name(setupListeners,"setupListeners");let readyHandlers=useCallbacks(),errorListeners=useCallbacks(),ready;function triggerError(error,to,from){markAsReady(error);const list=errorListeners.list();return list.length?list.forEach(handler=>handler(error,to,from)):console.error(error),Promise.reject(error)}__name(triggerError,"triggerError");function isReady(){return ready&&currentRoute.value!==START_LOCATION_NORMALIZED?Promise.resolve():new Promise((resolve22,reject)=>{readyHandlers.add([resolve22,reject])})}__name(isReady,"isReady");function markAsReady(err){return ready||(ready=!err,setupListeners(),readyHandlers.list().forEach(([resolve22,reject])=>err?reject(err):resolve22()),readyHandlers.reset()),err}__name(markAsReady,"markAsReady");function handleScroll(to,from,isPush,isFirstNavigation){const{scrollBehavior}=options;if(!isBrowser||!scrollBehavior)return Promise.resolve();const scrollPosition=!isPush&&getSavedScrollPosition(getScrollKey(to.fullPath,0))||(isFirstNavigation||!isPush)&&history.state&&history.state.scroll||null;return nextTick().then(()=>scrollBehavior(to,from,scrollPosition)).then(position=>position&&scrollToPosition(position)).catch(err=>triggerError(err,to,from))}__name(handleScroll,"handleScroll");const go=__name(delta=>routerHistory.go(delta),"go");let started;const installedApps=new Set,router={currentRoute,listening:!0,addRoute,removeRoute,clearRoutes:matcher.clearRoutes,hasRoute,getRoutes,resolve:resolve2,options,push,replace,go,back:__name(()=>go(-1),"back"),forward:__name(()=>go(1),"forward"),beforeEach:beforeGuards.add,beforeResolve:beforeResolveGuards.add,afterEach:afterGuards.add,onError:errorListeners.add,isReady,install(app){const router2=this;app.component("RouterLink",RouterLink),app.component("RouterView",RouterView),app.config.globalProperties.$router=router2,Object.defineProperty(app.config.globalProperties,"$route",{enumerable:!0,get:__name(()=>unref(currentRoute),"get")}),isBrowser&&!started&&currentRoute.value===START_LOCATION_NORMALIZED&&(started=!0,push(routerHistory.location).catch(err=>{}));const reactiveRoute={};for(const key in START_LOCATION_NORMALIZED)Object.defineProperty(reactiveRoute,key,{get:__name(()=>currentRoute.value[key],"get"),enumerable:!0});app.provide(routerKey,router2),app.provide(routeLocationKey,shallowReactive(reactiveRoute)),app.provide(routerViewLocationKey,currentRoute);const unmountApp=app.unmount;installedApps.add(app),app.unmount=function(){installedApps.delete(app),installedApps.size<1&&(pendingLocation=START_LOCATION_NORMALIZED,removeHistoryListener&&removeHistoryListener(),removeHistoryListener=null,currentRoute.value=START_LOCATION_NORMALIZED,started=!1,ready=!1),unmountApp()}}};function runGuardQueue(guards){return guards.reduce((promise,guard)=>promise.then(()=>runWithContext(guard)),Promise.resolve())}return __name(runGuardQueue,"runGuardQueue"),router}__name(createRouter,"createRouter");function extractChangingRecords(to,from){const leavingRecords=[],updatingRecords=[],enteringRecords=[],len=Math.max(from.matched.length,to.matched.length);for(let i=0;i<len;i++){const recordFrom=from.matched[i];recordFrom&&(to.matched.find(record=>isSameRouteRecord(record,recordFrom))?updatingRecords.push(recordFrom):leavingRecords.push(recordFrom));const recordTo=to.matched[i];recordTo&&(from.matched.find(record=>isSameRouteRecord(record,recordTo))||enteringRecords.push(recordTo))}return[leavingRecords,updatingRecords,enteringRecords]}__name(extractChangingRecords,"extractChangingRecords");function useRouter(){return inject(routerKey)}__name(useRouter,"useRouter");function useRoute(_name){return inject(routeLocationKey)}__name(useRoute,"useRoute");export{resolveDynamicComponent as $,onMounted as A,onUnmounted as B,nextTick as C,defineStore as D,computed as E,readonly as F,unref as G,onScopeDispose as H,provide as I,Suspense as J,KeepAlive as K,Fragment as L,useRoute as M,mergeProps as N,createElementBlock as O,openBlock as P,renderSlot as Q,RouterView as R,START_LOCATION_NORMALIZED as S,Transition as T,normalizeClass as U,createBlock as V,withCtx as W,createVNode as X,normalizeProps as Y,guardReactiveProps as Z,onErrorCaptured as _,getCurrentInstance as a,createSSRApp as a0,createApp as a1,createBaseVNode as a2,toDisplayString as a3,createTextVNode as a4,createCommentVNode as a5,withModifiers as a6,resolveComponent as a7,renderList as a8,createStaticVNode as a9,useRouter as aa,withDirectives as ab,vModelCheckbox as ac,Teleport as ad,withAsyncContext as ae,shallowReadonly as af,toRefs as ag,withKeys as ah,useId as ai,onBeforeMount as aj,debounce as ak,useSlots as al,vModelDynamic as am,Comment as an,cloneVNode as ao,normalizeStyle as ap,createSlots as aq,customRef as ar,toHandlerKey as as,camelize as at,vue as au,markRaw as av,watchPostEffect as aw,mergeDefaults as ax,toValue as b,createHooks as c,isRef as d,effectScope as e,ref as f,getCurrentScope as g,hasInjectionContext as h,inject as i,onDeactivated as j,onActivated as k,shallowRef as l,h as m,createWebHistory as n,onBeforeUnmount as o,createRouter as p,isReadonly as q,reactive as r,shallowReactive as s,toRef as t,createPinia as u,setActivePinia as v,watchEffect as w,defineAsyncComponent as x,watch as y,defineComponent as z};
